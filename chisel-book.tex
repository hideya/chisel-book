% This Japanese translation is based on:
%   Commit b20a7910ef3c02186fd009fb48dd74fa29c04e54
%   Date:   Mon Mar 2 18:22:01 2020 +0100
% The original lines is 4941.

\documentclass[%draft,
    10pt,
    headinclude, footexclude,
    % twoside, % this produces strange margins!
    openright, % for new chapters
    notitlepage,
    cleardoubleempty,
    headsepline,
    pointlessnumbers,
    bibtotoc, idxtotoc,
    ]{scrbook}

% 2020-10-07 added for Overleaf
%\usepackage[utf8]{inputenc}
% 2020-10-10 igonore inoutenc errors
\nonstopmode

% iPad Air 2 resolution: 1536 x 2048
% 1.3333 ratio (4:3)
% LeeSeshia is 15,73 ? 20,96 cm, ratio 1.332
%%\setlength{\paperwidth}{15.73cm} \setlength{\paperheight}{20.96cm}
%\setlength{\paperwidth}{15.72cm} \setlength{\paperheight}{20.95cm}
%\typearea{calc} % without BCOR results to a DIV of 8 for 11pt
\typearea[1cm]{18} % TODO: check if 1 cm is the correct number


% A4 for Japanese version （しばらくは、A4で印刷して校正用する体裁にしたいと思います）
\setlength{\paperwidth}{21.0cm} \setlength{\paperheight}{29.7cm}
% B5 for Japanese version
%\setlength{\paperwidth}{18.2cm} \setlength{\paperheight}{25.7cm}

\usepackage{scrlayer-scrpage}
\setkomafont{pagehead}{\scshape\small}
\setkomafont{pagenumber}{\scshape\small}

\newif\ifbook
%\booktrue % comment out for the print book version

%\booktrue % comment out for the print book version

\ifbook
\else
\cfoot{\hyperlink{contents}{{\textnormal{Contents}}}}
\fi

\usepackage{pslatex} % -- times instead of computer modern, especially for the plain article class
\usepackage[colorlinks=true,bookmarks=false]{hyperref}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{cite}
\usepackage{dirtree}
\usepackage{pdfpages}
\usepackage{makeidx}
%\usepackage{showidx} % for index debugging
% For alignment on tables
\usepackage{dcolumn}
\newcommand{\cc}[1]{\multicolumn{1}{c}{#1}}

\newcommand{\code}[1]{{\small{\texttt{#1}}}}
\newcommand{\codefoot}[1]{{\footnotesize{\texttt{#1}}}}

% fatter TT font
\renewcommand*\ttdefault{txtt}
% another TT, suggested by Alex
% \usepackage{inconsolata}
% \usepackage[T1]{fontenc} % needed as well?

\usepackage[procnames]{listings}

% process Japanese by pdflatex
\usepackage[whole]{bxcjkjatype}

\ifbook
\hypersetup{
  linkcolor  = black,
  citecolor  = black,
  urlcolor   = black,
  colorlinks = black,
  bookmarks=false,
}
\else
\hypersetup{
  linkcolor  = blue,
  citecolor  = blue,
  urlcolor   = blue,
  colorlinks = true,
  bookmarks=true,
}
\fi

% not really used
\newenvironment{comment}
{ \vspace{-0.1in}
  \begin{quotation}
  \noindent
  \small \em
  \rule{\linewidth}{0.5pt}\\
}
{
  \\
  \rule{\linewidth}{0.5pt}
  \end{quotation}
}

\newcommand{\scale}{0.7}

\input{shared/chisel.tex}

\newcommand{\todo}[1]{{\emph{TODO: #1}}}
\newcommand{\martin}[1]{{\color{blue} Martin: #1}}
\newcommand{\myref}[2]{\href{#1}{#2}}

\ifbook
\renewcommand{\myref}[2]{{#2}{\footnote{\url{#1}}}}
\fi

% uncomment following for final submission
\renewcommand{\todo}[1]{}
\renewcommand{\martin}[1]{}

% uncomment following for final submission
\newif\ifshoworiginal
\newif\ifshowtransfirst
\newif\ifshowtranssecond

% 原文、自動翻訳、校正済み、全部表示
\showoriginaltrue
\showtransfirsttrue
\showtranssecondtrue

% 機械翻訳のみ
\showoriginalfalse
\showtransfirsttrue
\showtranssecondfalse

% 校正済日本語のみ表示
\showoriginalfalse
\showtransfirstfalse
\showtranssecondtrue

\makeindex

\begin{document}

\ifbook
\else
\includepdf{chisel-cover.pdf}
\newpage
\thispagestyle{empty}
~
\newpage
\fi

\begin{flushleft}
\pagestyle{empty}
\ \\
\vspace{1cm}
%{\usekomafont{title}\mdseries\huge Digital Design with Chisel}
{\usekomafont{title}\mdseries\huge Chiselで始めるデジタル回路設計}
\ \\
\vspace{1cm}
%{\usekomafont{title}\mdseries\Large Second Edition}
{\usekomafont{title}\mdseries\Large 第二版(日本語版)}
\cleardoublepage
\end{flushleft}
\newpage

%{\large\itshape Beta Edition}\\
%{\large\itshape martin@jopdesign.com}
%\vspace{10cm} \emph{Version: \today}
\begin{flushleft}
\pagestyle{empty}
\ \\
\vspace{1cm}
%{\usekomafont{title}\Huge Digital Design with Chisel\\
{\usekomafont{title}\Huge Chiselで始める\\デジタル回路設計\\
\bigskip
%{\usekomafont{title}\huge Second Edition}\\
{\usekomafont{title}\huge 第二版(日本語版)}\\
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
%{\usekomafont{title}\huge Martin Schoeberl}
{\usekomafont{title}\huge マーチン・シェーベル 著\\Chisel勉強会 訳}
\medskip\\
}

\newpage
\end{flushleft}

\thispagestyle{empty}
%\lowertitleback{
%}
\begin{flushleft}
{\small

Copyright \copyright{} 2016--2019 Martin Schoeberl
  \medskip\\
  \begin{tabular}{lp{.8\textwidth}}
    \raisebox{-12pt}{\includegraphics[height=18pt]{figures/cc_by_sa}} &
     This work is licensed under a Creative Commons Attribution-ShareAlike
     4.0 International License.
     \url{http://creativecommons.org/licenses/by-sa/4.0/}\\
  \end{tabular}

\medskip

Email: \url{martin@jopdesign.com}\\
Visit the source at \url{https://github.com/schoeberl/chisel-book}
\medskip

Published 2019 by Kindle Direct Publishing,\\
\url{https://kdp.amazon.com/}
\medskip
\medskip


\textbf{Library of Congress Cataloging-in-Publication Data}
\medskip

Schoeberl, Martin
\begin{quote}
Digital Design with Chisel\\
Martin Schoeberl\\
Includes bibliographical references and an index.\\
ISBN 9781689336031
\end{quote}

\bigskip

Manufactured in the United States of America.

Typeset by Martin Schoeberl.}
\end{flushleft}

\frontmatter

\phantomsection
\hypertarget{contents}{}
\tableofcontents

\begingroup
\let\cleardoublepage\clearpage
\listoffigures
\listoftables
\lstlistoflistings
\endgroup

\ifshoworiginal
\chapter{Foreword}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{まえがき}
\fi
\ifshowtranssecond %(校正)
\chapter{まえがき (L274 mune10 初回校正済)} %(校正  初回終了 ========================================================================)
\fi

\medskip
\medskip

\ifshoworiginal
It is an exciting time to be in the world of digital design. With the end of Dennard Scaling and the slowing of Moore's Law, there has perhaps never been a greater need for innovation in the field. Semiconductor companies continue to squeeze out every drop of performance they can, but the cost of these improvements has been rising drastically. Chisel reduces this cost by improving productivity. If designers can build more in less time, while amortizing the cost of verification through reuse, companies can spend less on Non-Recurring Engineering (NRE). In addition, both students and individual contributors can innovate more easily on their own.
\fi

\ifshowtransfirst %(自動翻訳)
デジタルデザインの世界になるようにエキサイティングな時間です。
DENNARDスケーリングの終わりとムーアの法則の減速で、おそらく分野における技術革新のための大きい必要はありませんでした。
半導体企業は、彼らができるパフォーマンスの一滴を絞り出すしていきますが、これらの改善のコストが大幅に上昇しています。
Chiselは、生産性を向上させることによって、このコストを削減します。
再利用による検証のコストを償却しながら、設計者は、より少ない時間でより多く構築することができた場合、企業は、非経常的エンジニアリング（NRE）に以下を過ごすことができます。
また、学生や個々の貢献者の両方が自分自身でより簡単に革新することができます。
\fi

\ifshowtranssecond %(校正 3/5 mune10)
デジタルデザインの世界で作業することはとてもエキサイティングなことです。デナード・スケーリングの終わりとムーアの法則の減速で、この分野での技術革新が必要となっています。
半導体製造に関わる企業は、依然として性能向上に尽力していますが、性能改善のためのコストが大幅に上昇しています。
Chiselは、デジタルデザインの生産性向上により、このコストの削減します。設計の再利用による検証のコストの削減や、開発初期投資（Non-Recurring Engineering、NRE） の削減により、設計者はより少ない時間でより多くのデザインを開発することができます。
また、学生や個人でも、イノベーションに取り組むことが簡単にできます。
\fi

\ifshoworiginal
Chisel is unlike most languages in that it is embedded in another programming language, Scala. Fundamentally, Chisel is a library of classes and functions representing the primitives necessary to express synchronous, digital circuits. A Chisel design is really a Scala program that \emph{generates} a circuit as it executes. To many, this may seem counterintuitive: ``Why not just make Chisel a stand-alone language like VHDL or SystemVerilog?'' My answer to this question is as follows: the software world has seen a substantial amount of innovation in design methodology in the past couple of decades. Rather than attempting to adapt these techniques to a new hardware language, we can simply \emph{use} a modern programming language and gain those benefits for free.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselは、それが他のプログラミング言語、Scalaの中に埋め込まれているという点で、ほとんどの言語とは異なります。
基本的に、Chiselは、同期、デジタル回路を表現するのに必要なプリミティブを表すクラスおよび機能のライブラリです。
Chiselのデザインは本当にScalaのプログラム\emph{generates}それが実行されるような回路であること。
多くの人にとって、これは直感に反するように見えることがあります。 ``なぜ、ChiselVHDLまたはSystemVerilogのようなスタンドアロンの言語にしない「」次のようにこの質問に対する私の答えは次のとおりです。？ソフトウェアの世界は、設計手法の革新のかなりの量のを見てきました過去数十年。
これらの手法を新しいハードウェア言語に適応させるのではなく、我々は単に現代のプログラミング言語を\emph{use}と自由のためのこれらの利点を得ることができます。
\fi

\ifshowtranssecond %(校正 3/5 mune10)
ChiselはそれがScalaの中に埋め込まれているという点で、他のプログラミング言語とは異なります。
基本的には、同期デジタル回路を表現するために必要なプリミティブを含むクラスと機能をライブラリ化したものが Chisel です。
Chiselのデザインは実際にはにScalaのプログラムで、実行可能な回路を、\emph{生成}します。
多くの人にとって、これは直感に反するかもしれません： 「なぜ、Chisel を VHDLやSystemVerilogのようなスタンドアロンの言語にしないのだろうか？」。
この質問に対する私の答えは次のとおりです。過去数十年間、ソフトウェアの世界はその設計手法の様々なイノベーションが起こりました。 
新しいハードウェアの言語にこれらの技術を適用しなくても、り最新のプログラミング言語を \emph{使用する} だけで、これらのメリットを享受することができるのです。
\fi

\ifshoworiginal
A longstanding criticism of Chisel is that it is ``difficult to learn.'' Much of this perception is due to the prevalence of large, complex designs created by experts to solve their own research or commercial needs. When learning a popular language like C++, one does not start by reading the source code of GCC. Rather, there are a plethora of courses, textbooks, and other learning materials that cater toward newcomers. In \emph{Digital Design with Chisel}, Martin has created an important resource for anyone who wishes to learn Chisel.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselの長年の批判は、学ぶことは、 ``困難であるということです。
「」このような認識の多くは、自分の研究や商業のニーズを解決するために専門家によって作成された大規模、複雑な設計の普及によるものです。
C ++のような人気のある言語を学習するとき、人はGCCのソースコードを読むことによって開始されません。
むしろ、新規参入に向け応えるコー​​ス、教科書、およびその他の学習教材の茄多があります。
\emph{Digital Design with Chisel}では、マーティンは、Chiselを学びたい人のための重要なリソースを作成しました。
\fi

\ifshowtranssecond %(校正 3/5 mune10)
Chiselに対して、「学ぶことが困難である」と長年の批判されてきました。このような認識の多くは、自分の研究や、商業的なニーズを満足させるために、専門家によって作成された大規模で複雑な設計が普及したことによるものです。
C ++のような人気のある言語を学習するとき、人々は GCCのソースコードを読んだりしません。
むしろ、新たにChiselを使う人に向けた、様々な研修コースや、教科書、様々な学習教材が必要です。
Chiselを学びたい人のための重要なリソースとして、この\emph{Digital Design with Chisel}をマーティンは書いてくれました。
\fi

\ifshoworiginal
Martin is an experienced educator, and it shows in the organization of this book. Starting with installation and primitives, he builds the reader's understanding like a building, brick-by-brick. The included exercises are the mortar that solidifies understanding, ensuring that each concept sets in the reader's mind. The book culminates with \emph{hardware generators} like a roof giving the rest of the structure purpose. At the end, the reader is left with the knowledge to build a simple, yet useful design: a RISC processor.
\fi

\ifshowtransfirst %(自動翻訳)
マーティンは、経験豊富な教育者であり、それは本書の組織で示したものです。
インストールおよびプリミティブから始めて、彼は建物のように、レンガで、レンガ造りの読者の理解を構築します。
付属の演習は、読者の心の中の各概念セットすることを保証し、固化が理解していることモルタルです。
構造の目的の残りの部分を与え、屋根のような\emph{hardware generators}付きブック最高潮に達します。
RISCプロセッサ：終わりに、読者は簡単なを構築するための知識、まだ便利なデザインが残されています。
\fi

\ifshowtranssecond %(校正 3/5 mune10)
マーティンは、経験豊富な教育者であり、それは本書の内容からもみてとれます。
インストールおよびプリミティブの解説から始めて、レンガ造り建物を、レンガを一つ一つ積み上げるように、読者の理解を深めてゆきます。
付属の演習例題は、読者の理解を強固にするための接着剤です。　心の中の各概念セットすることを保証し、固化が理解していることモルタルです。
この本は、\emph{hハードウェアジェネレーター} で頂点に達し、この屋根が残りの部分に目的を与えます。
最終的には、RISCプロセッサのようなシンプルで有用なデザインを構築するための知識をこの本の読者は得ることになるでしょう。
\fi

\ifshoworiginal
In \emph{Digital Design with Chisel}, Martin has laid a strong foundation for productive digital design. What you build with it is up to you.
\fi

\ifshowtransfirst %(自動翻訳)
\emph{Digital Design with Chisel}では、マーティンは生産デジタル設計のための強力な基盤を築きました。
あなたがそれを構築することはあなた次第です。
\fi

\ifshowtranssecond %(校正 3/5 mune10)
マーティンは\emph{Digital Design with Chisel}で生産的なデジタル設計のための強力なベースを築きました。次に何を作るかはあなた次第です。
\fi

\medskip

\ifshoworiginal
\noindent Jack Koenig\\
Chisel and FIRRTL Maintainer\\
Staff Engineer, SiFive \\
\fi

\ifshowtranssecond %(校正 3/5 mune10)
\noindent ジャック・ケーニッヒ\\
ChiselとFIRRTLメンテナ\\
スタッフエンジニア、SiFive社
\fi

\ifshoworiginal
\chapter{Preface 序文}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Preface 序文}
\fi
\ifshowtranssecond %(校正)
\chapter{序文 (L394 mune10 初回校正済)} %(校正  初回終了 ========================================================================)
\fi

\ifshoworiginal
% This text goes on the backside of the book, and in Amazon description
This book is an introduction to digital design with the focus on using the hardware construction language Chisel. Chisel brings advances from software engineering, such as object-orientated and functional languages, into digital design.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselは、デジタル設計には、そのようなオブジェクト指向と関数型言語などのソフトウェアエンジニアリングからの進歩をもたらします。
\fi

\ifshowtranssecond %(校正 3/6 mune10)
この本は、ハードウェア構築言語であるChiselを使ったデジタル・デザインについて解説します。 
Chiselは、オブジェクト指向言語や関数型言語などの先進のソフトウェアエンジニアリングの技術をデジタル・デザインの世界にもたらします。
\fi

\ifshoworiginal
This book addresses hardware designers and software engineers. Hardware designers, with knowledge of Verilog or VHDL, can upgrade their productivity with a modern language for their next ASIC or FPGA design. Software engineers, with knowledge of object-oriented and functional programming, can leverage their knowledge to program hardware, for example, FPGA accelerators executing in the cloud.
\fi

\ifshowtransfirst %(自動翻訳)
この本は、ハードウェア設計者とソフトウェア・エンジニアを対象としています。 ハードウェア設計者は、VerilogまたはVHDLの知識があれば、次のASICまたはFPGA設計のために最新の言語で生産性をアップグレードできます。 オブジェクト指向および機能プログラミングの知識を持つソフトウェアエンジニアは、その知識を活用して、クラウドで実行されるFPGAアクセラレーターなどのハードウェアをプログラミングできます。
\fi

\ifshowtranssecond %(校正 3/6 mune10)
この本は、ハードウェア設計者とソフトウェア・エンジニアの両方を対象としています。
VerilogやVHDLの知識を持つハードウェア設計者は、現代的な言語をASICやFPGA設計に活用することで、その生産性を向上させることができます。
オブジェクト指向と関数型プログラミングの知識を持つソフトウェア・エンジニアは、例えば、クラウドで稼働するFPGAアクセラレータのようなハードウェアのプログラミング（設計）にその知識を活用することができます。
\fi

\ifshoworiginal
The approach of this book is to present small to medium-sized typical hardware components to explore digital design with Chisel.
\fi

\ifshowtransfirst %(自動翻訳)
本書のアプローチは、Chiselとデジタル設計を探索する中型の典型的なハードウェアコンポーネントに小さい提示することです。
\fi

\ifshowtranssecond %(校正 3/6 mune10)
本書では、小さな一般的なハードウェアから中規模のハードウェアを例に、Chiselを使ったデジタル・デザインを紹介していきます。
\fi

% about me, backside

% about me, backside

%Martin Schoeberl is Associate Professor at the Technical University of Denmark, where he is teaching digital electronics and computer architecture. His research interest is on hard real-time systems, time-predictable computer architecture, and real-time Java. He has more than 100 publications in peer reviewed journals, conferences, and books.

%Martin has been four times at UC Berkeley on research stays, where he has picked up Chisel and was in close contact with the developers of Chisel. He lead the research project T-CREST where most of the components have been written in Chisel.

\ifshoworiginal
\section*{Foreword for the Second Edition}
\fi
\ifshowtransfirst %(自動翻訳)
\section*{Foreword for the Second Edition}
\fi
\ifshowtranssecond %(校正)
\section*{第2版のまえがき (L452)}
\fi

\ifshoworiginal
As Chisel allows agile hardware design, so does open access and on-demand printing
allow agile textbook publishing. Less than 6 months after the first edition of this book
I am able to provide an improved and extended second edition.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselは、柔軟なハードウェア設計を可能にしたようなので、オープンアクセスとオンデマンド印刷は、アジャイル教科書発行を許可しません。
6ヶ月未満この本の初版の後、私は改善と拡張第二版を提供することができています。
\fi

\ifshowtranssecond %(校正 3/6 mune10)
Chiselは、アジャイルなハードウェア設計を可能にしますし、オープンアクセスとオンデマンド印刷は、アジャイルな書籍の出版を可能にします。
本の初版のリリース後、半年未満で、改善と拡張した第二版をリリースすることができました。
\fi

\ifshoworiginal
Besides minor fixes, the main changes in the second edition are as follows.
The testing section has been extended. The sequential building blocks chapter contains
more example circuits. A new chapter on input processing explains input synchronization,
shows how to design a debouncing circuit, and how to filter a noisy input signal.
The example designs chapter has been extended to show different implementations of a FIFO.
The FIFO variations also show how to use type parameters and inheritance in digital design.
\fi

\ifshowtransfirst %(自動翻訳)
マイナーな修正のほか、第二版での主な変更点は次の通りです。
テストセクションでは、拡張されました。
シーケンシャルビルディングブロックの章では、より多くの例の回路を内蔵しています。
入力処理に関する新しい章では、入力同期、デバウンス回路を設計し、そしてどのようにノイズの多い入力信号をフィルタリングする方法を示しについて説明します。
デザイン例の章では、FIFOの異なる実装を表示するように拡張されました。
FIFOのバリエーションは、デジタルデザインの型パラメータと継承を使用する方法を示しています。
\fi

\ifshowtranssecond %(校正 3/6 mune10)
マイナーな修正のほか、第二版での主な変更点は次の通りです。
テストセクションを拡張しています。
シーケンシャル ビルディング ブロック(sequential building blocks)の章では、より多くの回路例を紹介しています。
入力処理（input processing）に関する新しい章が設けられ、入力の同期、デバウンス回路の設計、そしてノイズの多い入力信号をそのようにフィルタリングについて説明します。
デザインエグザンプルの章も拡張され、異なるFIFOの実装方法を説明します。
このFIFOのバリエーションでは、型パラメータと継承をデジタルデザインのなかでどのように使うかを解説しています。
\fi

\ifshoworiginal
\section*{Acknowledgements}
\fi
\ifshowtransfirst %(自動翻訳)
\section*{Acknowledgements}
\fi
\ifshowtranssecond %(校正)
\section*{謝辞 (L505)}
\fi

\ifshoworiginal
I want to thank everyone who has worked on Chisel for creating such
a cool hardware construction language. Chisel is so joyful to use and
therefore worth writing a book about.
I am thankful to the whole Chisel community, which is so welcoming and friendly
and never tired to answer questions on Chisel.
\fi

\ifshowtransfirst %(自動翻訳)
私は、このようなAのクールのハードウェア構成の言語を作成するためのChiselに取り組んできましたみんなに感謝したいと思います。
Chiselは、使用するので、楽しいとについての本を書くため、価値があります。
私はとても歓迎され、全体Chiselコミュニティへの感謝と友好とChisel上の質問に答えることが疲れて決してしています。
\fi

\ifshowtranssecond %(校正 3/6 mune10)
クールなハードウェア構築言語であるChiselの開発に携わったすべての人に感謝します。
Chiselは使用するのがとても楽しく、その本を書く価値があります。
とてもオープンでフレンドリーで、Chiselに関する質問に熱心に答えてくれる Chiselコミュニティ全体に感謝しています。
\fi

\ifshoworiginal
I would also like to thank my students in the last years of an advanced computer
architecture course where most of them picked up Chisel for the final project.
Thank you for moving out of your comfort zone and taking up the journey of
learning and using a bleeding-edge hardware description language.
Many of your questions have helped to shape this book.
\fi

\ifshowtransfirst %(自動翻訳)
私はそれらのほとんどは、最終的なプロジェクトのための掘削を拾った高度なコンピュータアーキテクチャコースの最後の年に私の学生に感謝することもしたいと思います。
あなたの快適ゾーンの外に移動すると学習の旅を取っ出血エッジハードウェア記述言語を使用していただきありがとうございます。
ご質問の多くは、この本を形作るために役立っています。
\fi

\ifshowtranssecond %(校正 3/6 mune10)
また、最後の数年間、先進コンピューターアーキテクチャコースを受講した学生たちに感謝したいと思います。
ほとんどの生徒が最終プロジェクトのためにChiselを取り上げてくれました。
殻から抜け出し、新しい勉強の旅に出て、最先端のハードウェア記述言語を使用していただき感謝します。
あなたたちの質問の多くは、この本を形作るのに大変役立ちました。
\fi

\ifshowtranssecond %(日本語版追記)
\section*{日本語訳について (L550)}

この日本語訳は Chisel勉強会で行っています。
翻訳で用いたオリジナルのバーションは  (2020年3月2日 b20a791 )です。
オリジナルの更新に合わせて翻訳も新しくしていく予定です。
日本語版のソースコードはこちら\url{https://github.com/chisel-jp/chisel-book} で公開しています。
誤訳や表現の誤りの訂正など、小さな修正も歓迎します。

Chiselに興味ある方は、勉強会に自由に参加できます。新型コロナの影響でF2Fの勉強会の開催はできておりませんが、Chisel勉強会のSlackへの登録URL \url{https://chisel-jp-slackin.herokuapp.com/}していただければ情報交換できると思います。

\fi %(日本語版追記)

\mainmatter

\ifshoworiginal
\chapter{Introduction}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Introduction}
\fi
\ifshowtranssecond %(校正)
\chapter{はじめに (L558 mune10 初回校正済)} %(校正  第1章 初回終了 =================================================================)
\fi

\label{sec:intro}

\ifshoworiginal
This book is an introduction to digital system design using a modern hardware
construction language, \myref{https://www.chisel-lang.org/}{Chisel}~\cite{chisel:dac2012}.
In this book, we focus on a higher abstraction level than usual in digital design books,
to enable you to build more complex, interacting digital systems in a shorter time.
\fi

\ifshowtransfirst %(自動翻訳)
この本は、近代的なハードウェア構成言語、\myref{https://www.chisel-lang.org/}{Chisel}〜\cite{chisel:dac2012}を使用してデジタルシステム設計への導入です。
本書では、我々は、より複雑な構築することができます短い時間でデジタルシステムを相互に作用するために、デジタル設計図書では通常より高い抽象レベルに焦点を当てます。
\fi

\ifshowtranssecond %(校正 3/6 mune10)
この本は、近代的なハードウェア構成言語である \myref{https://www.chisel-lang.org/}{Chisel}~\cite{chisel:dac2012} を使ったデジタルシステム設計を紹介します。
本書では、一般的なデジタル・デザインの書籍に比べ、より高い抽象レベルでの設計に注目し、より複雑で、相互作用のあるデジタルシステムを短期間で開発できるようになることを目指します。
\fi

\ifshoworiginal
This book and Chisel are targeting two groups of developers:
(1) hardware designers and (2) software programmers.
Hardware designers who are fluid in VHDL or Verilog and using other languages such as Python,
Java, or Tcl to generate hardware can move to a single hardware construction language
where hardware generation is part of the language.
Software programmers may become interested in hardware design,
e.g., as future chips from Intel will include programmable hardware to speed up programs.
It is perfectly fine to use Chisel as your first hardware description language.
\fi

\ifshowtransfirst %(自動翻訳)
（1）ハードウェア設計者および（2）ソフトウェア・プログラマ：本書およびChiselは、開発者の2つのグループを対象としています。
VHDLまたはVerilogで流体であり、ハードウェアを生成するためにそのようなのPython、Java（登録商標）、またはTclのような他の言語を使用して、ハードウェア設計者は、ハードウェア世代言語の一部である単一のハードウェア構成の言語に移動することができます。
ソフトウェアプログラマは、電子ハードウェア設計に興味になることがあります。
グラム。
、将来のインテルからのチップは、プログラムをスピードアップするためにプログラム可能なハードウェアが含まれます。
あなたの最初のハードウェア記述言語としてChiselを使用することは完全に罰金です。
\fi

\ifshowtranssecond %(校正 3/6 mune10)
本書およびChiselは、（1）ハードウェア設計者および（2）ソフトウェア・プログラマの2つの開発者のグループを対象としています。
VHDLやVerilog、Python、Java、またはTclのような他の言語も使いこなして開発をしているハードウェア設計者は、ハードウェアの生成が言語の機能の一部となっている、一つのハードウェア構築言語を使った開発に移行することができます。
ハードウェア設計にも興味（例えば、インテルが性能向上にFPGAをチップに取り込むなど）があるソフトウェアプログラマにとっては、最初に覚えるハードウェア記述言語としてChiselは最適です。
\fi

\ifshoworiginal
Chisel brings advances in software engineering, such as object-orientated
and functional languages, into digital design.
Chisel does not only allow to express hardware at the register-transfer level
but allows you to write hardware generators.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselは、デジタル設計には、そのようなオブジェクト指向と関数型言語としてのソフトウェア工学の進歩をもたらします。
Chiselは、レジスタ転送レベルでのハードウェアを表現することができないだけでなく、あなたは、ハードウェア・ジェネレータを書くことができます。
\fi

\ifshowtranssecond %(校正 3/9 mune10)
Chiselは、オブジェクト指向や関数型言語といったソフトウェア工学の進歩をデジタル設計の世界にもちこみます。
Chiselは、レジスタ転送レベル（RTL）でのハードウェア記述をサポートするだけではなく、ハードウェア・ジェネレータ(生成器)を記述できます。
\fi

\ifshoworiginal
Hardware is now commonly described with a hardware description language.
The time of drawing hardware components, even with CAD tools, is
over. Some high-level schematics can give an overview of the system but are
not intended to describe the system.
The two most common hardware description languages are Verilog and VHDL.
Both languages are old, contain many legacies, and have a moving line of what
constructs of the language are synthesizable to hardware.
Do not get me wrong: VHDL and Verilog are perfectly able to describe a hardware
block that can be synthesized into an
\myref{https://en.wikipedia.org/wiki/Application-specific_integrated_circuit}{ASIC}.
For hardware design in Chisel, Verilog serves as an intermediate language
for testing and synthesis.
\fi

\ifshowtransfirst %(自動翻訳)
ハードウェアは、現在一般的にハードウェア記述言語で記述されています。
でも、CADツールを使用して、ハードウェアコンポーネントを描画する時間は、以上です。
一部の高レベルの回路図は、システムの概要を与えることができますが、システムを記述するためのものではありません。
二つの最も一般的なハードウェア記述言語は、VerilogやVHDLです。
どちらの言語は、古い多くの遺産を含み、およびハードウェアに合成可能であるかの言語の構築の移動ラインを持っています。
間違った私を取得しないでください： VHDLおよびVerilogは完全\myref{https://en.wikipedia.org/wiki/Application-specific_integrated_circuit}{ASIC}に合成することができるハードウェアブロックを記述することができます。
Chisel内のハードウェア設計は、Verilogのテストおよび合成のための中間言語として機能します。
\fi

\ifshowtranssecond %(校正 3/9 mune10)
現在一般的にハードウェアの設計は、ハードウェア記述言語（HDL）を使って記述します。
CADツールなどを使用して、ハードウェアコンポーネントをお絵かきうる時代は終わりました。
一部の（抽象度の）高レベルの回路構成は作りますが、それはシステムの概要を示すためで、システムを記述するためのものではありません。
最も一般的なハードウェア記述言語は、VerilogやVHDLの2つです。
どちらの言語も、古く、様々な遺産を含んでいます。これらの言語を使って記述した回路は実際のハードウェアに合成可能です（ここ意訳、要チェック）。
誤解しないでください：VHDLやVerilogは \myref{https://en.wikipedia.org/wiki/Application-specific_integrated_circuit}{ASIC} に合成可能な ハードウェア ブロックを記述することができます。
Chiselを使ったハードウェア設計では、Verilogはテストおよび合成のための中間言語として機能しています。
\fi

\ifshoworiginal
This book is not a general introduction to hardware design and the fundamentals of it.
For an introduction of the basics in digital design, such as how to build a gate out of
CMOS transistors, refer to other digital design books.
However, this book intends to teach digital design at an abstraction level that is
current practice to describe ASICs or designs targeting
\myref{https://en.wikipedia.org/wiki/Field-programmable_gate_array}{FPGA}s.\footnote{As the author is more familiar with FPGAs
than ASICs as target technology, some design optimizations shown in this book are
targeting FPGA technology.}
As prerequisites for this book, we assume basic knowledge of
\myref{https://en.wikipedia.org/wiki/Boolean_algebra}{Boolean algebra} and the
\myref{https://en.wikipedia.org/wiki/Binary_number}{binary number system}.
Furthermore, some programming experience in any programming language
is assumed. No knowledge of Verilog or VHDL is needed.
Chisel can be your first programming language to describe digital hardware.
As the build process in the examples is based on \code{sbt} and \code{make},
basic knowledge of the command-line interface (CLI, also called terminal or
Unix shell) will be helpful.
\fi

\ifshowtransfirst %(自動翻訳)
この本は、ハードウェアの設計とそれの基礎一般的な紹介ではありません。
そのようなCMOSトランジスタのうち、ゲートを構築する方法として、デジタルデザインの基礎の概要については、他のデジタル設計図書を参照してください。
しかし、この本は\myref{https://en.wikipedia.org/wiki/Field-programmable_gate_array}{FPGA}sをターゲットのASICやデザインを記述するための現在の慣行である抽象レベルでデジタルデザインを教えることを意図しています。
著者は、対象技術としてのASICよりもFPGAを持つよりはよく知られているように、
\footnote{、本書に示されているいくつかの設計の最適化は、FPGAテクノロジをターゲットにしています。}
この本のための前提条件として、我々は\myref{https://en.wikipedia.org/wiki/Boolean_algebra}{Boolean algebra}と\myref{https://en.wikipedia.org/wiki/Binary_number}{binary number system}の基本的な知識を前提としています。
さらに、任意のプログラミング言語では、いくつかのプログラミング経験が想定されます。
VerilogまたはVHDLの知識は必要ありません。
Chiselは、デジタルハードウェアを記述するために、あなたの最初のプログラミング言語とすることができます。
実施例におけるビルドプロセスを\code{sbt}と\code{make}、（また、端末またはUnixシェルと呼ばれるCLI）コマンドラインインターフェイスの基本的な知識に基づいているとして役立つであろう。
\fi

\ifshowtranssecond %(校正 3/10 diningyo)
この本はハードウェア設計の一般的な紹介や基礎を扱うものではありません。CMOSトランジスタを使ったゲートの生成といったようなデジタル回路設計の基本の紹介については、他のデジタル設計の本を参照して下さい。
しかしこの本は\myref{https://en.wikipedia.org/wiki/Field-programmable_gate_array}{FPGA}をターゲットとした設計やASICを記述するための現在の手法といった抽象レベルのデジタル設計について教えようとしています。
\footnote{著者はターゲットとする技術面ではASICよりもFPGAに詳しいため、この本で紹介されるデザインの最適化はFPGAをターゲットにしています。}
この本のための予備知識として、\myref{https://en.wikipedia.org/wiki/Boolean_algebra}{ブール代数}や\myref{https://en.wikipedia.org/wiki/Binary_number}{２進法のシステム}の知識を想定しています。
更に何らかのプログラミング言語を使用した経験も想定しています。VerilogやVHDLの知識は必要ありません。
Chiselは最初のデジタルハードウェア設計になりえます。
例題中のビルド処理は\code{sbt}や\code{make}に基づいているので、コマンドラインを使ったインターフェイス（CLI、ターミナルやUnixシェルとも）の基本的な知識が役に立つでしょう。
\fi

\ifshoworiginal
Chisel itself is not a big language. The basic constructs fit on
\myref{https://github.com/freechipsproject/chisel-cheatsheet/releases/latest/download/chisel_cheatsheet.pdf}{one page}
and can be learned within a few days.
Therefore, this book is not a big book, as well.
Chisel is for sure smaller than VHDL and Verilog, which carry many legacies.
The power of Chisel comes from the embedding of Chisel within
\myref{https://www.scala-lang.org/}{Scala}, which itself in an expressive language.
Chisel inherits the feature from Scala being ``a language that grows on you''~\cite{Scala}.
However, Scala is not the topic of this book.
% We provide a short section on Scala for hardware designers, but
%A general introduction to Scala is better served by
The textbook by Odersky et al.~\cite{Scala} provides a general introduction
to Scala.
This book is a tutorial in digital design and the Chisel language; it is not
a Chisel language reference, nor is it a book on complete chip design.
\fi

\ifshowtransfirst %(自動翻訳)
Chisel自体は大きな言語ではありません。
基本的な構築物は\myref{https://github.com/freechipsproject/chisel-cheatsheet/releases/latest/download/chisel_cheatsheet.pdf}{one page}にフィットし、数日以内に習得することができます。
したがって、この本は大きな本ではない、としても。
Chiselは、多くの遺産を運ぶVHDLおよびVerilog、より確かに小さいためです。
Chiselのパワーが表現言語自体\myref{https://www.scala-lang.org/}{Scala}内Chiselの埋め込み、から来ています。
Chiselは、Scalaは `〜\cite{Scala}「」あなたに育つ`言語であることから機能を継承します。
しかし、Scalaはこの本の話題ではありません。
〜\cite{Scala}はScalaの一般的な紹介を提供します。
この本は、デジタル設計とChisel言語でチュートリアルです。それはChisel言語リファレンスではありません、またそれは、完全なチップ設計上の本です。
\fi

\ifshowtranssecond %(校正 3/15 mune10)
Chisel自体は大きな言語ではありません。
基本的な文法は\myref{https://github.com/freechipsproject/chisel-cheatsheet/releases/latest/download/chisel_cheatsheet.pdf}{早見表}に収まりますし、
数日で習得することができます。
したがって、この本もそんなに大きな本ではありません。
Chiselは、多くの資産を持つVHDLやVerilogよりは確かに小さいです。
ChiselのパワーはChiselが表現能力の優れた\myref{https://www.scala-lang.org/}{Scala}言語に組み込まれていることにあります。
ChiselはScalaの「あなたを育てる（TODO いまいち）」\cite{Scala}から機能を継承しています。
しかしながら、Scalaはこの本の主たるトピックではありません。
Scalaの一般的な紹介については、オダスカイのテキストブック\cite{Scala}を参照してください。
この本は、デジタル設計とChisel言語のチュートリアルです。
Chisel言語リファレンスではありませんし、完全なチップ設計に関する本でもありません。
\fi

\ifshoworiginal
All code examples shown in this book are extracted from complete programs
that have been compiled and tested. Therefore, the code shall not contain
any syntax errors. The code examples are available from the
\myref{https://github.com/schoeberl/chisel-book}{GitHub repository}
of this book.
Besides showing Chisel code, we have also tried to show useful designs and
principles of good hardware description style.
\fi

\ifshowtransfirst %(自動翻訳)
本書に示されているすべてのコード例をコンパイルおよびテストされている完全なプログラムから抽出されています。
したがって、コードが構文エラーを含んではなりません。
コード例は、本書の\myref{https://github.com/schoeberl/chisel-book}{GitHub repository}から入手可能です。
Chiselコードを示すだけでなく、我々はまた、便利なデザインと優れたハードウェア記述スタイルの原則を表示しようとしています。
\fi

\ifshowtranssecond %(校正 3/15 diningyo)
本書に掲載されているコード例はすべてコンパイルが可能でテスト済みの完全なプログラムから抽出されています。
そのためコードにはシンタックスエラーは含まれていません。
コード例は本書の\myref{https://github.com/schoeberl/chisel-book}{GitHubリポジトリ}に公開されています。
本書ではChiselのコードだけでなく良いハードウェアの記述スタイルの原則や便利なデザインについても紹介していきます。
\fi

\ifshoworiginal
This book is optimized for reading on a laptop or tablet (e.g., an iPad).
We include links to further reading in the running text, mostly to
\myref{https://en.wikipedia.org/}{Wikipedia} articles.
\fi

\ifshowtransfirst %(自動翻訳)
この本は、ラップトップやタブレット（電子に読み取るために最適化されています。
グラム。
、iPadの）。
私たちは、主に\myref{https://en.wikipedia.org/}{Wikipedia}記事に実行されているテキスト、更なる読書へのリンクが含まれています。
\fi

\ifshowtranssecond %(校正 3/25 diningyo)
この本はノートPCやタブレット（iPadなど）に向けて最適化しており、\myref{https://en.wikipedia.org/}{Wikipedia}の記事を中心に補足のためのリンクを掲載しています。
\fi

\ifshoworiginal
\section{Installing Chisel and FPGA Tools}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Installing Chisel and FPGA Tools}
\fi
\ifshowtranssecond %(校正)
\section{ChiselとFPGA開発ツールのインストール}
\fi

\ifshoworiginal
Chisel is a Scala library, and the easiest way to install Chisel and Scala is
with \code{sbt}, the Scala build tool. Scala itself depends on the installation
of \myref{https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html}{Java JDK 1.8}. As Oracle has changed the license for Java, it may be easier to
install OpenJDK from \myref{https://adoptopenjdk.net/}{AdoptOpenJDK}.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselは、Scalaのライブラリ、およびChiselをインストールする最も簡単な方法で、Scalaは\code{sbt}、Scalaのビルドツールです。
スカラ自体は\myref{https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html}{Java JDK 1.8}のインストールに依存します。
OracleがJavaのためのライセンスを変更したとして、\myref{https://adoptopenjdk.net/}{AdoptOpenJDK}からOpenJDKのをインストールする方が簡単かもしれません。
\fi

\ifshowtranssecond %(校正 3/25 diningyo)
ChiselはScalaのライブラリの１種であり、最も簡単なChiselとScalaのインストール方法はScalaのビルドツールである \code{sbt}を使うことです。
Scala自体は\myref{https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html}{Java JDK 1.8}に依存しています。
OracleがJavaに関するライセンスを変更したため、\myref{https://adoptopenjdk.net/}{AdoptOpenJDK}からOpenJDKをインストールするのが簡単でしょう。
\fi

\subsection{macOS}

\ifshoworiginal
Install the Java OpenJDK 8 from \myref{https://adoptopenjdk.net/}{AdoptOpenJDK}.
On Mac OS X, with the packet manager \myref{https://brew.sh/}{Homebrew},
\code{sbt} and git can be installed with:
\fi

\ifshowtransfirst %(自動翻訳)
\myref{https://adoptopenjdk.net/}{AdoptOpenJDK}からのJava OpenJDKの8をインストールします。
Mac OS Xでは、パケットマネージャ\myref{https://brew.sh/}{Homebrew}で、\code{sbt}とGitは一緒にインストールすることができます。
\fi

\ifshowtranssecond %(校正 3/25 diningyo)
\myref{https://adoptopenjdk.net/}{AdoptOpenJDK}からJava OpenJDK 8をインストールします。Mac OS Xでは、パケットマネージャ（TODO：パッケージマネージャか？？）の\myref{https://brew.sh/}{Homebrew}を使用することで、sbtとgitを次のようにインストールできます。
\fi

\begin{verbatim}
$ brew install sbt git
\end{verbatim}

\ifshoworiginal
Install \myref{http://gtkwave.sourceforge.net/}{GTKWave} and
\myref{https://www.jetbrains.com/idea/download/}{IntelliJ} (the community edition).
When importing a project, {\textbf select the JDK 1.8} you installed before (not Java 11!)
\fi

\ifshowtransfirst %(自動翻訳)
\myref{http://gtkwave.sourceforge.net/}{GTKWave}と\myref{https://www.jetbrains.com/idea/download/}{IntelliJ}（コミュニティ版）をインストールします。
プロジェクトをインポートする場合、{\ JDK 1を選択しtextbf。
8}あなたは、前にインストール（ないJavaの11！）
\fi

\ifshowtranssecond %(校正 3/25 diningyo)
\myref{http://gtkwave.sourceforge.net/}{GTKWave}\myref{https://www.jetbrains.com/idea/download/}{IntelliJ}（コミュニティ版）をインストールします 。
プロジェクトをインポートする場合、本節でインストールしたJDK 1.8を選択してください (Java 11ではありません!) 。
\fi

\subsection{Linux/Ubuntu}

\ifshoworiginal
Install Java and useful tools in Ubuntu with:
\fi

\ifshowtransfirst %(自動翻訳)
Ubuntuの中でJavaと便利なツールをインストールします。RRR000a5iH7p4Hを
\fi

\ifshowtranssecond %(校正 3/31 diningyo)
Ubuntuでは次のコマンドでJavaと役に立つツール類をインストールできます。
\fi

\begin{verbatim}
$ sudo apt install openjdk-8-jdk git make gtkwave
\end{verbatim}

\ifshoworiginal
For Ubuntu, which is based on Debian, programs are usually installed from a
Debian file (.deb). However, as of the time of this writing, \code{sbt} is not
available as a ready to install package. Therefore, the installation process
is a little bit more involved:
\fi

\ifshowtransfirst %(自動翻訳)
DebianベースのUbuntuされ、ために、プログラムは通常、Debianのファイル（からインストールされています。
）。
しかし、この記事の執筆時点のように、\code{sbt}は、パッケージをインストールする準備として使用することはできません。
そのため、インストールプロセスが少し複雑です：RRR000EMPAGClR
\fi

\ifshowtranssecond %(校正 3/31 diningyo)
UbuntuはDebianが元になっているため、プログラムはたいていDebianファイルからインストールできます。
しかしこの本の執筆時点では、\code{sbt}はインストール可能なパッケージが存在していませんでした。そのためインストール手順が少し複雑になります。
\fi

\begin{verbatim}
echo "deb https://dl.bintray.com/sbt/debian /" | \
  sudo tee -a /etc/apt/sources.list.d/sbt.list
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 \
  --recv 2EE0EA64E40A89B84B2DF73499E82A75642AC823
sudo apt-get update
sudo apt-get install sbt
\end{verbatim}

\subsection{Windows}

\ifshoworiginal
Install the Java OpenJDK from \myref{https://adoptopenjdk.net/}{AdoptOpenJDK}.
Chisel and Scala can also be installed and used under Windows.
Install \myref{http://gtkwave.sourceforge.net/}{GTKWave} and
\myref{https://www.jetbrains.com/idea/download/}{IntelliJ} (the community edition).
When importing a project, {\textbf select the JDK 1.8} you installed before (not Java 11!)
\code{sbt} can be installed with a Windows installer, see:
\myref{https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html}{Installing sbt on Windows}.
Install a \myref{https://git-scm.com/download/win}{git client}.
\fi

\ifshowtransfirst %(自動翻訳)
\myref{https://adoptopenjdk.net/}{AdoptOpenJDK}からのJavaのOpenJDKをインストールします。
ChiselとScalaはまた、インストールされ、Windowsの下で使用することができます。
\myref{http://gtkwave.sourceforge.net/}{GTKWave}と\myref{https://www.jetbrains.com/idea/download/}{IntelliJ}（コミュニティ版）をインストールします。
プロジェクトをインポートする場合、{\ JDK 1を選択しtextbf。
（！Javaの11ではない）\code{sbt}は、Windowsインストーラでインストールすることができます前に、8}がインストールされ、以下を参照してください。\myref{https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html}{Installing sbt on Windows}を。
\myref{https://git-scm.com/download/win}{git client}をインストールします。
\fi

\ifshowtranssecond %(校正 3/31 diningyo)
\myref{https://adoptopenjdk.net/}{AdoptOpenJDK}からJava OpenJDKをインストールします。
ChiselとScalaもWindowsにインストールして使用できます。
\myref{http://gtkwave.sourceforge.net/}{GTKWave}\myref{https://www.jetbrains.com/idea/download/}{IntelliJ}  (コミュニティ版) をインストールします。
プロジェクトをインポートする場合、Windowsインストーラで\code{sbt}をインストールする前にインストール済みの {\textbf select the JDK 1.8} を選択してください  (Java 11ではありません!) 。
関連項目:\myref{https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Windows.html}{Windowsでのsbtのインストール}。
\myref{https://git-scm.com/download/win}{gitクライアント}をインストールします。
\fi

\ifshoworiginal
\subsection{FPGA Tools}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{FPGA Tools}
\fi
\ifshowtranssecond %(校正)
\subsection{FPGA ツール}
\fi

\ifshoworiginal
To build hardware for an FPGA, you need a synthesize tool. The two major
FPGA vendors, Intel\footnote{former Altera} and Xilinx, provide free versions of
their tools that cover small to medium-sized FPGAs. Those medium-sized
FPGAs are large enough to build multicore RISC style processors.
Intel provides the \myref{https://www.altera.com/products/design-software/fpga-design/quartus-prime/download.html}{Quartus Prime Lite Edition} and Xilinx the
\myref{https://www.xilinx.com/products/design-tools/vivado/vivado-webpack.html}{Vivado Design Suite, WebPACK Edition}.
Both tools are available for Windows and Linux, but not for macOS.
\fi

\ifshowtransfirst %(自動翻訳)
FPGAのビルドハードウェアに、あなたはのsynthesizeツールを必要としています。
二つの主要なFPGAベンダーは、インテル
\footnote{旧アルテラ}
とザイリンクスは、中規模のFPGAへの小さなカバーし、そのツールの無料版を提供しています。これらの中規模のFPGAは、マルチコアRISCスタイルプロセッサを構築するために十分な大きさです。
インテルは\myref{https://www.altera.com/products/design-software/fpga-design/quartus-prime/download.html}{Quartus Prime Lite Edition}とザイリンクス\myref{https://www.xilinx.com/products/design-tools/vivado/vivado-webpack.html}{Vivado Design Suite, WebPACK Edition}を提供します。
どちらのツールもなく、MacOSのための、WindowsとLinuxのために利用可能です。
\fi

\ifshowtranssecond %(校正 4/1 diningyo)
FPGA向けにハードウェアをビルドするためには、論理合成ツールが必要です。
２つの有名なFPGAベンダであるIntel\footnote{旧Altera}とXilinxは小規模から中規模のFPGAをサポートしたフリーのツールを提供しています。
これらの中規模のFPGAはRISCプロセッサによるマルチコアをビルドするには十分です。
Intelは\myref{https://www.altera.com/products/design-software/fpga-design/quartus-prime/download.html}{Quartus Prime Liteエディション}をXilinxは\myref{https://www.xilinx.com/products/design-tools/vivado/vivado-webpack.html}{Vivado Design Suite, WebPACKエディション}をそれぞれ提供しています。
これらのツールはWindows/Linux版はありますが、macOS向けのものはありません。
\fi

\section{Hello World}

\ifshoworiginal
Each book on a programming language shall start with a minimal example,
called the \emph{Hello World} example. Following code is the first approach:
\fi

\ifshowtransfirst %(自動翻訳)
プログラミング言語上の各本は\emph{Hello World}例と呼ばれ、最小限の例で始まるものとします。
コードに続いて、最初のアプローチです。
\fi

\ifshowtranssecond %(校正 4/1 diningyo)
どのプログラミング言語も\emph{Hello World}と呼ばれる最小例題からスタートします。
次に示すコードがその最初のアプローチです。
\fi

\shortlist{src/main/scala/HelloScala.scala}

\ifshoworiginal
\noindent Compiling and executing this short program with \code{sbt}
\fi

\ifshowtransfirst %(自動翻訳)
\code{sbt}この短いプログラムのコンパイルと実行
\fi

\ifshowtranssecond %(校正 4/1 diningyo)
\noindent この短いプログラムを\code{sbt}を使ってコンパイルして実行します。
\fi

\begin{chisel}
$ sbt run
\end{chisel}

\ifshoworiginal
\noindent leads to the expected output of a Hello World program:
\fi

\ifshowtransfirst %(自動翻訳)
Hello Worldのプログラムの予想される出力につながります：
\fi

\ifshowtranssecond %(校正 4/12 mune10)
\noindent Hello Worldのプログラムの期待される出力は：
\fi

\begin{chisel}
[info] Running HelloScala
Hello Chisel World!
\end{chisel}

\ifshoworiginal
\noindent However, is this Chisel? Is this hardware generated to print a string?
No, this is plain Scala code and not a representative Hello World
program for a hardware design.
\fi

\ifshowtransfirst %(自動翻訳)
しかし、このChiselはありますか？このハードウェアは、文字列を出力するために生成されていますか？いいえ、これはプレーンなScalaのコードではなく、ハードウェア設計のための代表的なHello Worldのプログラムです。
\fi

\ifshowtranssecond %(校正 4/2 diningyo)
しかしこれはChiselなのでしょうか？このハードウェアは文字列を印刷するために生成されたものでしょうか？いいえ、これはただのScalaのコードであってハードウェア設計におけるHello Worldプログラムではありません。
\fi

\ifshoworiginal
\section{Chisel Hello World}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Chisel Hello World}
\fi
\ifshowtranssecond %(校正)
\section{Chisel で Hello World}
\fi

\ifshoworiginal
What is then the equivalent of a Hello World program for a hardware design?
The minimal useful and visible design? A blinking LED is the hardware (or even
embedded software) version of Hello World. If a LED blinks, we are ready to
solve bigger problems!
\fi

\ifshowtransfirst %(自動翻訳)
ハードウェア設計のためのHello Worldプログラムの同等その後、何ですか？最小限に有用と見えるデザイン？点滅するLEDは、ハードウェア（あるいは組込みソフトウェア）のHello Worldのバージョンです。
LEDが点滅している場合、私たちは大きな問題を解決する準備が整いました！
\fi

\ifshowtranssecond %(校正 4/2 diningyo)
それではハードウェア設計においてHello Worldプログラムと言えるものは何なのでしょうか？
簡単に見ることができて役に立つ最小のデザインとは？
それはLEDを点滅させることがハードウェア（もしくは組み込みソフトウェア）におけるHello Worldです。
LEDが点滅していれば、より大きな問題を解決するための準備ができたことになります。
\fi

\longlist{code/hello.txt}{A hardware Hello World in Chisel}{lst:chisel:hello}

\ifshoworiginal
%\index{Hello World} The index on this page does not work, it references to a intro
% page. Strange!
Listing~\ref{lst:chisel:hello} shows a blinking LED, described in Chisel.
It is not important that you understand the details of this code example.
We will cover those in the following chapters. Just note that the circuit is
usually clocked with a high frequency, e.g., 50 MHz, and we need a counter
to derive timing in the Hz range to achieve a visible blinking. In the above
example, we count from 0 up to 25000000-1 and then toggle the blinking signal
(\code{blkReg := \textasciitilde blkReg}) and restart the counter (\code{cntReg := 0.U}).
That hardware then blinks the LED at 1~Hz.
\fi

\ifshowtransfirst %(自動翻訳)
あなたがこのコード例の詳細を理解することが重要ではありません。
私たちは、次の章でそれらをカバーします。
ただ、回路は通常、高頻度、Eでクロックされていることに注意してください。
グラム。
、50 MHzで、我々は目に見える点滅を達成するために、Hzの範囲の導出タイミングカウンタを必要とします。
上記の例では、我々は0、最大25000000から1にして、点滅信号（\code{blkReg := \textasciitilde blkReg}）トグルカウントし、カウンタ（\code{cntReg := 0.U}）を再起動します。
そのハードウェアは、その後、1〜HzでLEDを点滅します。
\fi

\ifshowtranssecond %(校正 4/11 diningyo)
{lst:chisel:hello}はLチカの処理をChiselで実装したものです。
次の章でこのコードの詳細についてを解説するので、ここではコードの詳細について理解する必要はありません。
注意しておきたいのは回路は通常50MHzといった高速なクロックで動作するため、目に見える点滅を生成するためにHzレンジのタイミングのカウンタが必要になります。
上記の例では0から5000000-1までカウントし、点滅信号をトグルし（\code{blkReg := \textasciitilde blkReg}）、カウンタを再スタートします。
これによってハードウェアはLEDを1Hzで点滅させませす。
\fi

\ifshoworiginal
\section{An IDE for Chisel}
\fi
\ifshowtransfirst %(自動翻訳)
\section{An IDE for Chisel}
\fi
\ifshowtranssecond %(校正)
\section{Chisel 用のIDE}
\fi

\ifshoworiginal
This book makes no assumptions about your programming environment or editor you use.
Learning the basics should be easy with just using \code{sbt} at the command line
and an editor of your choice. In the tradition of other books, all commands that you
shall type in a shell/terminal/CLI are preceded by a \code{\$} character, which you
shall not type in. As an example, here is the Unix \code{ls} command, which lists files in
the current folder:
\fi

\ifshowtransfirst %(自動翻訳)
この本は、あなたのプログラミング環境や、使用するエディタを想定していません。
基本を学ぶことは、単にコマンドラインで\code{sbt}、お好みのエディタを使用して簡単にする必要があります。
他の本の伝統では、あなたがシェル/ターミナル/ CLIで入力するものとし、すべてのコマンドは、あなたが入力してはならない\code{\$}文字が先行しています。
例として、ここでは現在のフォルダ内のファイルを一覧表示しますUnixの\code{ls}コマンドは、次のとおりです。
\fi

\ifshowtranssecond %(校正 4/12 mune10)
本書では、あなたのプログラミング環境やエディタについては何も仮定していません。
基本的なことはコマンドライン上で \code{sbt} を使い、好きなエディタを使うだけで簡単に習得できます。
他の書籍の伝統に習えば、
すべてのコマンドは、シェル/ターミナル/CLIに入力しなければならないコマンドの前には\code{\$}がありますが、
これは入力しません。
例として、ここでは、現在のフォルダ内のファイルを一覧表示する Unix の \code{ls}コマンドを示します。
\fi

\begin{verbatim}
$ ls
\end{verbatim}

\ifshoworiginal
That said, an integrated development environment (IDE), where a compiler is running in
the background, can speed up coding. As Chisel is a Scala library, all IDEs
that support Scala are also good IDEs for Chisel.
It is possible in
\myref{https://www.jetbrains.com/help/idea/discover-intellij-idea-for-scala.html}{IntelliJ} and
 \myref{https://www.eclipse.org/}{Eclipse}
to generate a project from the sbt project configuration in \code{build.sbt}.
\fi

\ifshowtransfirst %(自動翻訳)
これは、コンパイラがバックグラウンドで実行されている統合開発環境（IDE）は、コーディングスピードアップすることができ、と述べました。
Chiselは、Scalaのライブラリであるとして、スカラをサポートするすべてのIDEもChiselのために良いのIDEです。
それは\code{build.sbt}中のsbtプロジェクトの設定からプロジェクトを生成する\myref{https://www.jetbrains.com/help/idea/discover-intellij-idea-for-scala.html}{IntelliJ}と\myref{https://www.eclipse.org/}{Eclipse}で可能です。
\fi

\ifshowtranssecond %(校正 4/12 mune10)
バックグラウンドでコンパイラが動いている統合開発環境（IDE）を利用することで、コーディングの高速化が可能になると言われています。
ChiselはScalaのライブラリなので、ScalaをサポートしているIDEはすべてChiselに適したIDEでもあります。
例えば、 \code{build.sbt} で構成された sbt プロジェクトから
\myref{https://www.jetbrains.com/help/idea/discover-intellij-idea-for-scala.html}{IntelliJ} や
\myref{https://www.eclipse.org/}{Eclipse} のプロジェクトを生成することができます。
\fi

\ifshoworiginal
In IntelliJ you can create a new project from existing sources with:
\emph{File - New - Project from Existing Sources...} and then select the \code{build.sbt}
file from the project.
\fi

\ifshowtransfirst %(自動翻訳)
IntelliJのでは、と既存のソースから新しいプロジェクトを作成することができます。
\emph{File - New - Project from Existing Sources...} し、プロジェクトから\code{build.sbt}ファイルを選択します。
\fi

\ifshowtranssecond %(校正 4/12 mune10)
IntelliJでは、
\emph{File - New - Project from Existing Sources...} から プロジェクトの中の \code{build.sbt} ファイルを選べば、
既存のソースから新しいプロジェクトを作成することができます。
\fi

\ifshoworiginal
In Eclipse you can create a project via
\begin{verbatim}
$ sbt eclipse
\end{verbatim}
and import that project into Eclipse.\footnote{This function needs the Eclipse plugin for sbt.}
\fi

\ifshowtransfirst %(自動翻訳)
ERROR-TBD
%Eclipseでは、あなたは
%RRR000xsfGkfcG
%経由でプロジェクトを作成することができますし、Eclipseにそのプロジェクトをインポートします。
%\footnote{この関数は、SBTのためのEclipseプラグインを必要とします｝
\fi

\ifshowtranssecond %(校正 4/12 mune10)
Eclipseでは、
\begin{verbatim}
$ sbt eclipse
\end{verbatim}
で、そのプロジェクトをEclipseにインポートします。\footnote{sbt用のEclipseプラグインが必要です。}
\fi

\ifshoworiginal
\myref{https://code.visualstudio.com/}{Visual Studio Code} is another option for a Chisel IDE.
The \myref{https://marketplace.visualstudio.com/items?itemName=scalameta.metals/}{Scala Metals}
extension provides Scala support.
On the left bar select \emph{Extensions} and search for \emph{Metals} and install \emph{Scala (Metals)}.
To import an \code{sbt} based project open the folder with \emph{File - Open}.
\fi

\ifshowtransfirst %(自動翻訳)
\myref{https://code.visualstudio.com/}{Visual Studio Code}はChiselIDEのための別のオプションです。
\myref{https://marketplace.visualstudio.com/items?itemName=scalameta.metals/}{Scala Metals}拡張子はScalaのサポートを提供します。
左側のバーで\emph{Extensions}を選択し、\emph{Metals}を検索し\emph{Scala (Metals)}をインストールします。
\code{sbt}ベースのプロジェクトをインポートするには\emph{File - Open}でフォルダを開きます。
\fi

%Open the project folder, e.g., t-crest/patmos/hardware, by selecting File/Open Folder. Make sure the sbt project uses at least Scala version 2.11.12
%On the left bar select "Metals" and then select "Import build" - This may take a while
%That's it. However, running and debugging the project still doesn't work.

\ifshowtranssecond %(校正 4/12 mune10)
\myref{https://code.visualstudio.com/}{Visual Studio Code}もChisel 用 IDEとして使えます。
\myref{https://marketplace.visualstudio.com/items?itemName=scalameta.metals/}{Scala Metals} 拡張が Scala のサポートを提供します。
左のバーで \emph{Extensions}を選択、
\emph{Metals} をサーチして、
\emph{Scala (Metals)}をインストールします。
\code{sbt} ベースのプロジェクトをインポートするには、
\emph{File - Open} でフォルダをオープンします。
\fi

\ifshoworiginal
\section{Source Access and eBook Features}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Source Access and eBook Features}
\fi
\ifshowtranssecond %(校正)
\section{本書のソースコードへのアクセスと電子書籍の機能}
\fi

\ifshoworiginal
This book is open source and hosted at GitHub: \myref{https://github.com/schoeberl/chisel-book}{chisel-book}.
All Chisel code examples, shown in this book, are included in the repository.
The code compiles with a recent version of Chisel, and many examples also include a test bench.
We collect larger Chisel examples in the accompanying repository \myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}. If you find an error or typo in the book, a GitHub pull request is the most convenient way to incorporate your improvement.
You can also provide feedback or comments for improvements by filing an issue on GitHub
or sending a plain, old school email.
\fi

\ifshowtransfirst %(自動翻訳)
この本は、オープンソースとはGitHubでホスティングされている：\myref{https://github.com/schoeberl/chisel-book}{chisel-book}。
本書に示されているすべてのChiselのコード例は、リポジトリに含まれています。
コードChiselの最近のバージョンでコンパイルし、多くの例では、テストベンチが含まれます。
私たちは、付属のリポジトリ\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}で大きなリグの例を収集します。
あなたは本の中で誤りやタイプミスを見つけた場合は、GitHubのプルリクエストは、あなたの改善を組み込むための最も便利な方法です。
あなたはまた、GitHubの上で問題を提出するか、プレーン、古い学校の電子メールを送信することにより、改善のためのフィードバックやコメントを提供することができます。
\fi

\ifshowtranssecond %(校正 4/12 mune10)
この本はオープンソースで、GitHub: \myref{https://github.com/schoeberl/chisel-book}{chisel-book} でホストされています。
\footnote{日本語版は \myref{https://github.com/chisel-jp/chisel-book}{chisel-book 日本語訳} }
この本で紹介されている Chisel のコード例はすべてリポジトリに含まれています。
コードは最新バージョンの Chisel でコンパイルされており、多くの例にはテストベンチも含まれています。
付属のリポジトリ \myref{https://github.com/schoeberl/chisel-examples}{chisel-examples} には、より大きな Chisel の例題を集めています。
本書の中に誤りやタイプミスを見つけた場合は、GitHub のプルリクエストで改善点を取り入れるのが最も便利な方法です。
また、GitHub に Issue を提出することで、改善のためのフィードバックやコメントを提供することもできます。
あと、昔ながらの平凡なメールも送れます。
\fi

\index{Chisel!Examples}

\ifshoworiginal
This book is freely available as a PDF eBook and in classical printed form.
The eBook version features links to further resources
and \myref{https://www.wikipedia.org/}{Wikipedia} entries.
We use Wikipedia entries for background information (e.g., binary number system)
that does not directly fit into this book.
We optimized the format of the eBook for reading on a tablet, such as an iPad.
\fi

\ifshowtransfirst %(自動翻訳)
この本は、PDF電子ブックなど、クラシック、印刷形式で自由に利用可能です。
電子ブック版は、さらにリソースと\myref{https://www.wikipedia.org/}{Wikipedia}エントリへのリンクを提供しています。
私たちは、電子（背景情報については、Wikipediaのエントリを使用します。
グラム。
直接この本に収まらない、二進法）。
当社は、iPadのようなタブレットで読むための電子書籍のフォーマットを最適化。
\fi

\ifshowtranssecond %(校正 4/12 mune10)
この本は、PDFの電子ブックと古典的な印刷形式で自由に利用できます。
電子ブック版には、さらなるリソースと \myref{https://www.wikipedia.org/}{Wikipedia}の記事へのリンクがあります。
本書に直接当てはまらない背景情報（例：2進数方式）については、Wikipediaの記事を利用しています。
iPadなどのタブレットで読めるように、電子書籍のフォーマットを最適化しています。
\fi

\ifshoworiginal
\section{Further Reading}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Further Reading}
\fi
\ifshowtranssecond %(校正)
\section{参考文献}
\fi

\ifshoworiginal
Here a list of further reading for digital design and Chisel:
\begin{itemize}
\item \myref{http://www.cambridge.org/es/academic/subjects/engineering/circuits-and-systems/digital-design-systems-approach}{Digital Design: A Systems Approach}, by William J. Dally and R. Curtis Harting,
is a modern textbook on digital design. It is available in two versions: using Verilog or VHDL as a hardware description language.
\end{itemize}
\fi

\ifshowtransfirst %(自動翻訳)
ここではデジタル設計とChiselのための更なる読書のリストは：デジタル設計上の近代的な教科書です。
ハードウェア記述言語としてVerilogまたはVHDLを使用して：それは2つのバージョンが利用可能です。
\fi

\ifshowtranssecond %(校正 4/13 mune10)
デジタル設計とChiselに関する参考文献をリストします
\begin{itemize}
\item \myref{http://www.cambridge.org/es/academic/subjects/engineering/circuits-and-systems/digital-design-systems-approach}{Digital Design: A Systems Approach}, by William J. Dally and R. Curtis Harting,
は、デジタルデザインに関する最新の教科書です。ハードウェア記述言語としてVerilogとVHDLの2つのバージョンがあります。
\end{itemize}
\fi

\ifshoworiginal
The official Chisel documentation and further documents are available online:
\fi

\ifshowtransfirst %(自動翻訳)
公式Chiselのドキュメントと、さらに文書は、オンラインで利用可能です。
\fi

\ifshowtranssecond %(校正 4/13 mune10)
Chiselの公式ドキュメントやその他の関連ドキュメントはオンラインで利用可能です。
\fi

\begin{itemize}

\item The \myref{https://www.chisel-lang.org/}{Chisel} 
% home page is the official starting point to　download and learn Chisel.
ホームページは、Chiselをダウンロードして学ぶための公式の出発点です。

\item The \myref{https://github.com/ucb-bar/chisel-tutorial}{Chisel Tutorial}
% provides a ready setup project containing small exercises with testers and solutions.
はテストとソリューションを含む小さな演習問題を含む準備されたプロジェクトを提供します。

\item The \myref{https://github.com/freechipsproject/chisel3/wiki}{Chisel Wiki}
%contains　a short users guide to Chisel and links to further information.
はChiselの簡単なユーザーガイドと詳細情報へのリンクが含まれています。

\item The \myref{https://github.com/freechipsproject/chisel-testers}{Chisel Testers} 
%are in their own repository that contains a Wiki documentation.
は、Wikiドキュメントを含む独自のリポジトリです。

\item The \myref{https://github.com/freechipsproject/chisel-bootcamp}{Generator Bootcamp} 
%is a Chisel course focusing on hardware generators, as a \myref{https://jupyter.org/}{Jupyter} notebook
は、\myref{https://jupyter.org/}{Jupyter} ノートブックとして、ハードウェア・ジェネレーターを中心としたChisel講座です。

\item A \myref{https://github.com/ccelio/chisel-style-guide}{Chisel Style Guide} by Christopher Celio.

\item The \myref{https://github.com/schoeberl/chisel-lab}{chisel-lab}
%contains Chisel exercises for the course ``Digital Electronics 2'' at the Technical University of Denmark.
には、デンマーク工科大学の「デジタル・エレクトロニクス2」コースのChisel練習問題が収録されています。

\end{itemize}

\ifshowtranssecond %(日本語版追記)
日本語の情報についてもリストします（日本語版追記）

\begin{itemize}
\item \myref{https://diningyo.booth.pm/items/1718207}{Chiselを始めたい人に読んでほしい本} だいにんぎょー はChiselとそのもととなるScalaの日本語で最初の解説書です。 \myref{https://www.amazon.co.jp/dp/4844378694/ref=cm_sw_em_r_mt_dp_.tvGFb8W1QH5Y}{Amazon}でも買えます。
\item \myref{https://diningyo.booth.pm/items/1888995}{Chiselクイックリファレンス} だいにんぎょー はchisel3.utilパッケージのリファレンス集です。
\item \myref{https://www.amazon.co.jp/dp/4802098057/ref=cm_sw_em_r_mt_dp_5AvGFb1ZHVJTP}{プログラマのためのFPGAによるRISC-Vマイコンの作り方} 堀江 徹也 (著) はChiselの紹介から始まり、SiFive社のフリーのRISC-V SoC実装である Freedomを例にFPGAの開発までカバーします。
\end{itemize}
\fi %(日本語版追記)


\ifshoworiginal
\section{Exercise}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Exercise}
\fi
\ifshowtranssecond %(校正)
\section{演習}
\fi

\ifshoworiginal
Each chapter ends with a hands-on exercise. For the introduction exercise, we will use an
FPGA board to get one \myref{https://en.wikipedia.org/wiki/Light-emitting_diode}{LED}
blinking.\footnote{If you at the moment have no FPGA board available, continue to read
as we will show you a simulation version at the end of the exercise.}
As a first step clone (or fork) the \myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}
repository from GitHub.
The Hello World example is in the folder \code{hello-world}, set up as
a minimal project. You can explore the Chisel code of the blinking LED
in \code{src/main/scala/Hello.scala}.
Compile the blinking LED with the following steps:
\fi

\ifshowtransfirst %(自動翻訳)
ハンズオン演習で、各章が終了します。
紹介の練習のために、私たちは1 \myref{https://en.wikipedia.org/wiki/Light-emitting_diode}{LED}点滅を取得するために、FPGAボードを使用します。
\footnote{現時点であなたがいないFPGAボードを用意している場合、我々はあなたの練習の最後にシミュレーションバージョンが表示されますと読み続けます。}
 GitHubのからの第一段階クローン（またはフォーク）\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}リポジトリとして。
Hello Worldの例では、最小限のプロジェクトとして設定したフォルダ\code{hello-world}、です。
あなたは\code{src/main/scala/Hello.scala}で点滅LEDのChiselコードを探索することができます。
次の手順で点滅するLEDをコンパイルします。
\fi

\ifshowtranssecond %(校正 4/13 diningyo)
各章はハンズオン演習で終わります。導入となる演習では、FPGAボードを使用してLEDを1つ点滅させます。\footnote{FPGAボードを使用できない場合は、演習の最後にあるシミュレーション結果を参照して下さい。}
最初のステップとして、\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}リポジトリをgithubからclone (またはfork)してください。
Hello World の例は \code{hello-world} フォルダにあり、最小のプロジェクトとしてセットアップされています。 \code{src/main/scala/Hello.scala} を見ることでLEDの点滅のChiselコードを調べることができます。の点滅。LEDの点滅コードをコンパイルするために、次の手順を実行します。
\fi

\begin{verbatim}
$ git clone https://github.com/schoeberl/chisel-examples.git
$ cd chisel-examples/hello-world/
$ sbt run
\end{verbatim}

\ifshoworiginal
After some initial downloading of Chisel components, this will produce the Verilog file \code{Hello.v}.
Explore this Verilog file. You will see that it contains two inputs \code{clock} and \code{reset}
and one output \code{io\_led}. When you compare this Verilog file with the Chisel module,
you will notice that the Chisel module does not contain \code{clock} or \code{reset}.
Those signals are implicitly generated, and in most designs, it is convenient not to need to
deal with these low-level details. Chisel provides register components, and those
are connected automatically to \code{clock} and \code{reset} (if needed).
\fi

\ifshowtransfirst %(自動翻訳)
Chiselの部品のいくつかの初期ダウンロードした後、これはVerilogファイル\code{Hello.v}を生成します。
このVerilogファイルを探検。
あなたはそれが二つの入力\code{clock}と\code{reset}と1つの出力\code{io\_led}が含まれていることがわかります。
あなたはChiselモジュールと、このVerilogファイルを比較するときは、Chiselモジュールが\code{clock}または\code{reset}が含まれていないことがわかります。
これらの信号は、暗黙的に生成され、ほとんどの設計では、それがないこれらの低レベルの詳細に対処する必要性に便利です。
Chiselは、レジスタコンポーネントを提供し、（必要な場合）、それらは\code{clock}と\code{reset}に自動的に接続されています。
\fi

\ifshowtranssecond %(校正 4/13 diningyo)
最初にChiselコンポーネントダウンロードが行われた後に、\code{Hello.v}という名前のVerilogファイルが生成されます。
このVerilogファイルを見ていきましょう。\code{clock}と\code{reset}という2つの入力と\code{io\_led}という出力が含まれていることがわかります。このVerilogファイルをChiselのモジュールを比較するとclockとresetが含まれていないことに気づくでしょう。
これらのシグナルは暗黙的に生成され、ほとんどの設計ではこれらの低レベルな信号を扱う必要がない方が便利です。Chiselにはレジスタもコンポーネントとして含まれており、これらには必要に応じて\code{clock}と\code{reset}が接続されます。
\fi

\ifshoworiginal
The next step is to set up an FPGA project file for the synthesize tool, assign the pins,
compile\footnote{The real process is more elaborated with following steps: synthesizing the logic,
performing place and route, performing timing analysis, and generating a bitfile.
However, for the purpose of this introduction example we simply call it ``compile''
your code.} the Verilog code, and configure the FPGA with the resulting bitfile.
We cannot provide the details of these steps. Please consult the manual of
your Intel Quartus or Xilinx Vivado tool.
However, the examples repository contains some ready to use Quartus
projects in folder \code{quartus} for several popular FPGA boards (e.g., DE2-115).
If the repository contains support for your board, start Quartus, open the project,
compile it by pressing the \emph{Play} button, and configure the FPGA board
with the \emph{Programmer} button and one of the LEDs should blink.
\fi

\ifshowtransfirst %(自動翻訳)
次のステップは、ピンを割り当てて容易に合成ツールのFPGAプロジェクトファイルを設定することで、コンパイル
\footnote{実際のプロセスは複数のステップ以下で詳述される：、論理合成の配置配線を行う、タイミング解析を行い、Aを生成しますビットファイル。しかし、この導入例の目的のために、我々は、単に ``「」あなたのコードをコンパイルし、それを呼び出します。}
 Verilogコードを、得られたビットファイルでFPGAを設定します。
私たちは、これらの手順の詳細を提供することはできません。
インテルのQuartusやザイリンクスVivadoツールのマニュアルを参照してください。
しかし、例のリポジトリには、いくつかの人気のFPGAボード（電子用フォルダ\code{quartus}でのQuartusのプロジェクトを使用して、いくつかの準備ができて含まれています。
グラム。
、S -115）。
リポジトリがあなたのボードのサポートが含まれている場合は、プロジェクトを開くと、Quartusを開始\emph{Play}ボタンを押すことによって、それをコンパイルし、\emph{Programmer}ボタンでFPGAボードを設定し、LEDの1つが点滅しなければなりません。
\fi

\ifshowtranssecond %(校正 4/13 diningyo)
次の手順として論理合成ツールのFPGAプロジェクトファイルを設定し、Verilogコードをコンパイルし、得られたビットファイルでFPGAを設定します。\footnote{実際のプロセスは、論理合成、配置配線、タイミング解析の実行、およびビットファイルの生成と、各ステップでさらに細かくなります。ただし、この導入例では、単にコードを 「コンパイル」 します。}
これらの手順の詳細についてはここでは述べませんので、IntelのQuartusやXilinxのVivadoのマニュアルを参照してください。
しかしながらexamplesリポジトリには、いくつかのポピュラーなIntelのFPGAボード（例:DE 2-115）ですぐに使えるQuartusプロジェクトが\code{quartus}というフォルダに含まれています。リポジトリに含まれているボードを持っている場合は、Quartusを立ち上げてプロジェクトを開き、\emph{Play}ボタンを押してコンパイルを行い、\emph{Programmer}ボタンを押してFPGAボードの設定を行えば、LEDが点滅します。
\fi

\ifshoworiginal
{\bf Gratulation! You managed to get your first design in Chisel running in an FPGA!}
\fi

\ifshowtransfirst %(自動翻訳)
{\ Gratulation BF！あなたは、FPGAで実行されている彫刻刀であなたの最初の設計を得ることができました！}
\fi

\ifshowtranssecond %(校正 4/14 mune10)
{\bf おめでとうございます! あなたはChiselの最初のデザインをFPGAで動作させることに成功しました!}
\fi

\ifshoworiginal
If the LED is not blinking, check the status of reset. On the DE2-115 configuration,
the reset input is connected to SW0.
\fi

\ifshowtransfirst %(自動翻訳)
LEDが点滅していない場合は、リセットの状態を確認してください。
DE2-115構成に、リセット入力がSW0に接続されています。
\fi

\ifshowtranssecond %(校正 4/14 mune10)
もしLED が点滅していない場合は、リセットの状態を確認してください。
DE2-115の設定では。リセットの入力は SW0 につながっています。
\fi

\ifshoworiginal
Now change the blinking frequency to a slower or a faster value and
rerun the build process. Blinking frequencies and also blinking patterns
communicate different ``emotions''. E.g., a slow blinking LED signals that
everything is ok, a fast blinking LED signals an alarm state.
Explore which frequencies express best those two different emotions.
\fi

\ifshowtransfirst %(自動翻訳)
今より遅くまたは速い値に点滅周波数を変更し、ビルドプロセスを再実行します。
点滅周波数とも点滅パターンは、「」異なる ``感情を伝えます。
え。
グラム。
、すべてがOKであることをゆっくりと点滅LED信号、LED信号にアラーム状態を点滅速いです。
最高のこれら二つの異なる感情を表現された周波数探検。
\fi

\ifshowtranssecond %(校正 4/14 mune10)
次に、点滅頻度を遅い値または速い値に変更して、ビルドプロセスを再実行します。
点滅周波数と点滅パターンは、異なる「状態(emotion)」を伝えます。
例えば、遅い点滅のLEDはすべてが正常であることを示し、速い点滅のLEDは異常状態を示します。
どの周波数がこれらの2つの異なる「状態(emotion)」を最もよく表現しているかを探ってみましょう。
\fi

\ifshoworiginal
As a more challenging extension to the exercise, generate the following blinking pattern:
the LED shall be on for 200~ms every second. For this pattern, you might
decouple the change of the LED blinking from the counter reset.
You will need a second constant where you change the state of the
\code{blkReg} register. What kind of emotion does this pattern produce?
Is it alarming or more like a sign-of-live signal?
\fi

\ifshowtransfirst %(自動翻訳)
運動にもっと挑戦拡張として、以下の点滅パターンを生成：LEDは200〜ミリ秒ごとのためにしなければなりません。
このパターンでは、あなたはカウンターリセットから点滅LEDの変更を分離することがあります。
あなたは\code{blkReg}レジスタの状態を変更する第2の定数が必要になります。
このパターンの農産物を感情のはどのような？それは憂慮すべき以上の符号のライブ信号のようなものですか？
\fi

\ifshowtranssecond %(校正 4/14 mune10)
演習のより挑戦的な拡張として、次の点滅パターンを生成します。
LED は毎秒 200~ms の間点灯しなければなりません。
この場合、カウンタのリセットとは切り離して、LEDの点滅を変化させます。
そのためには、\code{blkReg} レジスタの状態を変更させる第2の状態が必要です。
このパターンは、どのような「状態(emotion)」を生み出すのでしょうか？
以上を知らせるのか？ それとも活動していることを示すようなものなのか？
\fi

\ifshoworiginal
If you do not have an FPGA board (yet), you can still run the blinking LED example.
You will use  the Chisel simulation. To avoid a too long simulation time change the
clock frequency in the Chisel code from 50000000 to 50000. Execute following
instruction to simulate the blinking LED:
\fi

\ifshowtransfirst %(自動翻訳)
あなたは（まだ）FPGAボードを持っていない場合、あなたはまだ点滅LEDの例を実行することができます。
あなたはChiselのシミュレーションを使用します。
あまりにも長いシミュレーション時間が50000000から50000にChiselコードでクロック周波数を変更する避けるために。
点滅するLEDをシミュレートするには、次の命令を実行します。
\fi

\ifshowtranssecond %(校正 4/14 mune10)
（まだ）FPGAボードをお持ちでない場合でも、LEDの点滅の例を実行することができます。
Chiselシミュレーションを使用します。
シミュレーション時間が長くなりすぎないように、Chiselコードのクロック周波数を50000000から50000に変更してください。
以下のコマンドを実行してLEDの点滅をシミュレーションします。
\fi

\begin{verbatim}
$ sbt test
\end{verbatim}

\ifshoworiginal
This will execute the tester that runs for one million clock cycles.
The blinking frequency depends on the simulation speed, which depends on the
speed of your computer. Therefore, you might need to experiment a little bit
with the assumed clock frequency to see the simulated blinking LED.
\fi

\ifshowtransfirst %(自動翻訳)
これは百万クロック・サイクルに対して実行テスターを実行します。
点滅周波数は、コンピュータの速度に依存シミュレーション速度に依存します。
したがって、あなたは、シミュレート点滅LEDを見ることが想定クロック周波数で少し試してみる必要があります。
\fi

\ifshowtranssecond %(校正 4/14 mune10)
これにより、100万クロックサイクルで動作するテスターが実行されます。
点滅の頻度はシミュレーションの速度に依存しており、お使いのコンピュータの速度に依存します。
そのため、想定したクロック周波数でLEDの点滅のシミュレーションが出来るか、少し実験する必要があるかもしれません。
\fi

\ifshoworiginal
\chapter{Basic Components}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Basic Components}
\fi
\ifshowtranssecond %(校正)
\chapter{基本コンポーネント (L1603 diningyo 初回校正済) } %(校正  第2章  ========================================)  % 
\fi

\ifshoworiginal
In this section, we introduce the basic components for digital design:
combinational circuits and flip-flops.
These essential elements can be combined to build larger, more interesting circuits.
\fi

\ifshowtransfirst %(自動翻訳)
組合せ回路とフリップフロップ：このセクションでは、デジタル設計のための基本的なコンポーネントを紹介します。
これらの本質的な要素が大きく、より興味深いの回路を構築するために組み合わせることができます。
\fi

\ifshowtranssecond %(校正 4/14 mune10)
ここでは、デジタル設計のための基本的な部品を紹介します。
組み合わせ回路とフリップフロップです。
これらの重要な要素を組み合わせることで、より大きくて面白い回路を作ることができます。
\fi

\ifshoworiginal
Digital systems in general built use binary signals, which means a single bit or signal
can only have one of two possible values. These values are often called 0 and 1. However, we
also use following terms: low/high, false/true, and de-asserted/asserted.
These terms mean the same two possible values of a binary signal.
\fi

\ifshowtransfirst %(自動翻訳)
単一ビットまたは信号が2つだけの可能な値の一つを有することを意味し、一般的な特注使用バイナリ信号、デジタルシステム。
これらの値は、多くの場合、0と1と呼ばれています。
しかし、我々はまた、次の用語を使用：低/高、真/偽を、デアサート/アサート。
これらの用語は、バイナリ信号の同一の2つの可能な値を意味します。
\fi

\ifshowtranssecond %(校正 4/14 mune10)
一般的に構築されたデジタルシステムでは、1 つのビットもしくは信号が 2 つの可能な値のうち 1 つしか持てないことを意味するバイナリ信号を使用します。
これらの値はしばしば0と1と呼ばれます。
その他、次のような用語も使用します：low/high、false/true、そして de-asserted/asserted。
これらの用語は、バイナリ信号がとりうる 2つの値を意味しています。
\fi

\ifshoworiginal
\section{Signal Types and Constants}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Signal Types and Constants}
\fi
\ifshowtranssecond %(校正)
\section{信号タイプと定数}
\fi

\ifshoworiginal
Chisel provides three data types to describe signals, combinational logic, and registers:
\code{Bits}, \code{UInt}, and \code{SInt}. \code{UInt} and \code{SInt} extend \code{Bits},
and all three types represent a vector of bits. \code{UInt} gives this vector of
bits the meaning of an unsigned integer and \code{SInt} of a signed
integer.\footnote{The type \codefoot{Bits} in the current version of Chisel is missing operations and
therefore not very useful for user code.}
Chisel uses \myref{https://en.wikipedia.org/wiki/Two\%27s\_complement}{two's complement}
as signed integer representation.
Here is the definition for different types, an 8-bit \code{Bits}, an 8-bit unsigned integer, and a 10-bit
signed integer:
\fi

\index{Integer!unsigned}
\index{Integer!signed}

\ifshowtransfirst %(自動翻訳)
\code{Bits}、\code{UInt}、及び\code{SInt}：ノミは、3つのデータ信号を説明するための種類、組合せ論理回路、およびレジスタを提供します。
\code{UInt}と\code{SInt}は\code{Bits}を拡張し、そして全3種類のビットのベクトルを表します。
\code{UInt}は、このビットベクトルを符号付き整数の符号なし整数と\code{SInt}の意味を与えます。
\footnote{Chiselの現在のバージョンで型\codefoot{Bits}は操作を欠落し、ユーザーコードのため、非常に有用ではありません。}
Chiselは、符号付き整数として表現\myref{https://en.wikipedia.org/wiki/Two\%27s\_complement}{two's complement}を使用します。
ここで、異なるタイプの定義、8ビット\code{Bits}、8ビットの符号なし整数、10ビット符号付き整数です。
\fi

\ifshowtranssecond %(校正 4/17 diningyo)
Chiselでは信号や組み合わせ論理、レジスタを表現するために、\code{Bits}、\code{UInt}、\code{SInt}の③つのデータ型を提供しています。
\code{UInt}と\code{SInt}は\code{Bits}から派生したもので、これら３つの方はビットの集まりを表現します。
\code{UInt}は符号なし整数のビットの集合を、\code{SInt}は符号つきの整数を意味します。
\footnote{現在のChiselにおいて\codefoot{Bits}型は演算処理が存在しておらず、それゆえにうユーザーにとってはあまり有用ではありません。}
Chiselは符号付き整数を\myref{https://en.wikipedia.org/wiki/Two\%27s\_complement}{２の補数}で表現します。
次に示すのは8-bitの\code{Bits}型、8-bitの符号なし整数、10-bitの符号つき整数の定義です。
\fi

\shortlist{code/types.txt}

\ifshoworiginal
\noindent The width of a vector of bits is defined by a Chisel width type (\code{Width}).
The following expression casts the Scala integer \code{n} to a Chisel \code{width},
which is used for the definition of the \code{Bits} vector:
\fi

\ifshowtransfirst %(自動翻訳)
ビットベクトルの幅は、Chisel幅タイプ（\code{Width}）によって定義されます。
次の式は\code{Bits}ベクターの定義に使用されるChisel\code{width}にスカラ整数\code{n}をキャスト。
\fi

\ifshowtranssecond %(校正 4/17 diningyo)
\noindent ビット幅はChiselの型の１つである\code{Width}型によって定義されます。
次の表現はScalaの整数\code{n}をChiselの\code{Wtdth}型にキャストし、それを\code{Bits}型の定義に使用しています。
\fi

\shortlist{code/n_w.txt}

\index{Integer!width}

\ifshoworiginal
\noindent Constants can be defined by using a Scala integer and converting it to a Chisel type:
\fi

\ifshowtransfirst %(自動翻訳)
定数は、スカラ整数を使用し、Chisel型に変換することにより定義することができます。
\fi

\ifshowtranssecond %(校正 4/17 diningyo)
\noindent 定数はスカラの整数をChiselの型に変換することで定義できます。
\fi

\shortlist{code/constants.txt}
\index{Integer!constant}

\ifshoworiginal
\noindent Constants can also be defined with a width, by using the Chisel width type:
\fi

\ifshowtransfirst %(自動翻訳)
定数はまた、Chisel幅タイプを使用して、幅と定義することができます。
\fi

\ifshowtranssecond %(校正 4/17 diningyo)
\noindent 定数はChiselの幅を表す型を使って、指定のビット幅で定義することもできます。
\fi

\shortlist{code/const_width.txt}

\ifshoworiginal
\noindent If you find the notion of 3.U and 4.W a little bit funny, consider it as a variant of an integer
constant with a type. This notation is similar to 3L, representing a long integer constant in C, Java, and Scala.
\fi

\ifshowtransfirst %(自動翻訳)
あなたは3の概念を見つけた場合。
Uと4。
少しW面白い、型の整数定数の変種として、それを考慮してください。
この表記は、C、Java、およびScalaで長整数定数を表す、3Lと同様です。
\fi

\ifshowtranssecond %(校正 4/17 diningyo)
\noindent もし3.Uと4.Wという概念を見つけた場合、少しおかしく思えますが型つきの整数の変数と考えて下さい。
この概念はCやJava、Scalaでlong型を表現するために3Lと表記することと同様です。
\fi

\ifshoworiginal
{\bf Possible pitfall:} One possible error when defining constants with a dedicated width is missing the \code{.W}
specifier for a width. E.g., \code{1.U(32)} will \emph{not} define a 32-bit wide constant representing 1.
Instead, the expression \code{(32)} is interpreted as bit extraction from position 32, which results
in a single bit constant of 0. Probably not what the original intention of the programmer was.
\fi

\ifshowtransfirst %(自動翻訳)
{\ BF可能な落とし穴：}一つの可能​​なエラー専用幅の定義定数は幅に対して\code{.W}指定子を欠落しています。
え。
グラム。
、\code{1.U(32)}は\emph{not}は1を表す32ビット幅の定数を定義します。
その代わりに、発現\code{(32)} 0の単一ビット一定になる位置32からビット抽出、と解釈されます。
おそらくプログラマの本来の意図は何だったのではありません。
\fi

\ifshowtranssecond %(校正 4/21 diningyo), BF修正5/4 mune10
{\bf ハマりやすい落とし穴：}
定数の宣言時に起こりがちなエラーとして、ビット幅指定のための\code{.W}を忘れることがあげられます。
例えば\code{1.U(32}のような表現は32bitの１を表す定義では\emph{ありません}。
その代わりに\code{(32)}は３２bit目のビットの指定として解釈されるため、結果的に1bitの0になります。
これはおそらくプログラマが本来意図したものではないはずです。
\fi

\ifshoworiginal
Chisel benefits from Scala's type inference and in many places type information can be left out.
The same is also valid for bit widths. In many cases, Chisel will automatically infer the correct width.
Therefore, a Chisel description of hardware is more concise and better readable than VHDL or
Verilog.
\fi

\ifshowtransfirst %(自動翻訳)
Scalaの型推論からと多くの場所の型情報でChiselメリットが出ままにすることができます。
同じことがまた、ビット幅のために有効です。
多くの場合、Chiselは、自動的に正しい幅を推測します。
したがって、ハードウェアのChisel記述はVHDLまたはVerilogより簡潔でより良い読み取り可能です。
\fi

\ifshowtranssecond %(校正 4/21 diningyo)
Chisel ではScalaの型推論のおかげで、多くの場合において型情報を省略できます。
これはビット幅の場合においても同様です。多くの場合、Chiselは自動的に正しいビット幅を推測します。
それ故に、Chiselで記述されたハードウェアはVHDLやVerilogに比べて完結で読みやすいものになります。
\fi

\ifshoworiginal
For constants defined in other bases than decimal, the constant is defined in a string with
a preceding \code{h} for hexadecimal (base 16), \code{o} for octal (base 8), and \code{b}
for binary (base 2). The following example shows the definition of constant 255 in different
bases. In this example we omit the bit width and Chisel infers the minimum width to fit
the constants in, in this case 8 bits.
\fi

\ifshowtransfirst %(自動翻訳)
小数以外の塩基で定義された定数は、定数は16進数（ベース16）のための先行\code{h}と列に定義され、\code{o}バイナリ（ベース2）のためのオクタル（ベース8）、および\code{b}ため。
次の例では、異なる拠点における定数255の定義を示しています。
この例では、ビット幅を省略し、Chiselは、この場合8ビットの定数に合うように最小幅を推定します。
\fi

\ifshowtranssecond %(校正 4/21 diningyo)
10進数以外の定数を表現するには、定数に先行する形で文字列を追加します。
追加する文字列は、16進数の場合は\code{h}を、8進数の場合は\code{o}を、2進数の場合は\code{b}となります。
次の例では255という定数を異なる基数で表現したものです。
この例ではビット幅の指定は省略し、Chiselが宣言する定数に収まる最小のビット幅を推測しています。
このケースでのビット幅は8bitになります。
\fi

\shortlist{code/const_base.txt}

\ifshoworiginal
\noindent The above code shows how to use an underscore to group digits in the
string that represents a constant. The underscore is ignored.
\fi

\ifshowtransfirst %(自動翻訳)
コードが示す上記方法定数を表す文字列のグループ桁に下線を使用します。
アンダースコアは無視されます。
\fi

\ifshowtranssecond %(校正 4/21 diningyo)
\noindent 上記のコードは表現する定数をアンダースコアを使って桁をグループ化する方法も示しています。アンダースコアは定数値には影響しません。
\fi

\ifshoworiginal
To represent logic values, Chisel defines the type \code{Bool}.
\code{Bool} can represent a \emph{true} or \emph{false} value.
The following code shows the definition of type \code{Bool} and the definition of
\code{Bool} constants, by converting the Scala Boolean constants \code{true}
and \code{false} to Chisel \code{Bool} constants.
\fi

\ifshowtransfirst %(自動翻訳)
論理値を表すために、Chisel型の\code{Bool}を定義します。
\code{Bool}は\emph{true}又は\emph{false}値を表すことができます。
次のコードが示すタイプ\code{Bool}の定義とChisel\code{Bool}定数にスカラブール定数\code{true}と\code{false}を変換しRRR011Y3i6Zfra定数の定義。
\fi

\ifshowtranssecond %(校正 4/21 diningyo)
Chiselでは論理を表現する方法として\code{Bool}型を定義しています。
\code{Bool}は\emph{true}か\emph{false}を表現できます。
次に示すコードは\code{Bool}型の定義と、ScalaのBoolean型の定数からの変換を用いたChiselの\code{Bool}型の\code{true}と\code{false}の宣言です。
\fi

\shortlist{code/bool.txt}
\index{Bool}

\ifshoworiginal
\section{Combinational Circuits}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Combinational Circuits}
\fi
\ifshowtranssecond %(校正)
\section{組み合わせ回路}
\fi

\ifshoworiginal
Chisel uses \myref{https://en.wikipedia.org/wiki/Boolean_algebra}{Boolean algebra} operators,
as they are defined in C, Java, Scala, and several other programming languages,
to described combinational circuits: \code{\&} is the AND operator and \code{|} is
the OR operator.
Following line of code defines a circuit that combines signals \code{a} and \code{b} with \emph{and}
gates and combines the result with signal \code{c} with \emph{or} gates.
\fi

\ifshowtransfirst %(自動翻訳)
それらはC、Java（登録商標）、Scalaの、および他のいくつかのプログラミング言語で定義された通りであるChiselは、組合せ回路を説明するために、\myref{https://en.wikipedia.org/wiki/Boolean_algebra}{Boolean algebra}演算子を使用：\code{\&}はAND演算子であり、\code{|}は、OR演算子です。
コードの次の行は、コンバインが\emph{and}ゲートと\code{a}と\code{b}の信号と\emph{or}ゲートと信号\code{c}で結果を組み合わせること回路を規定します。
\fi

\ifshowtranssecond %(校正 4/23 diningyo)
Chiselは組み合わせ論理回路を記述するために、C言語やJava、Scala、またその他のプログラミング言語と同様に\myref{https://en.wikipedia.org/wiki/Boolean_algebra}{ブール代数}演算子が使用されます。
\code{\&}はAND（論理積）、\code{|}はOR（論理和）を表現します。
次の行に示すコードは\code{a}と\code{b}の信号を\emph{and}ゲートで結合し、その結果と\code{c}を\emph{or}ゲートに入力しています。
\fi

\shortlist{code/logic.txt}

\ifshoworiginal
\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/logic}
  \caption{Logic for the expression \code{(a \& b) | c}.
  The wires can be a single bit or multiple bits. The Chisel expression, and the schematics are the same.}
  \label{fig:logic}
\end{figure}
\fi

\ifshowtransfirst %(自動翻訳)
\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/logic}
  \caption{Logic for the expression \code{(a \& b) | c}.
  The wires can be a single bit or multiple bits. The Chisel expression, and the schematics are the same.}
  \label{fig:logic}
\end{figure}
\fi

\ifshowtranssecond %(校正 4/23 diningyo)
\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/logic}
  \caption{\code{(a \& b) | c}の論理.信号は単一、もしくは複数のビットになり得る。Chiselの表現と回路図は同じになる。}
  \label{fig:logic}
\end{figure}
\fi

\ifshoworiginal
Figure~\ref{fig:logic} shows the schematic of this combinatorial expression.
Note that this circuit may be for a vector of bits and not only single wires
that are combined with the AND and OR circuits.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:logic}はこの組み合わせの表現の概略図を示します。
この回路はビットとANDとOR回路と組み合わされて単一のワイヤのみならずベクトルためのものであってもよいことに留意されたいです。
\fi

\ifshowtranssecond %(校正 4/23 diningyo)
図〜\ref{fig:logic}はこの組み合わせの表現の回路図を示します。
この回路のAND、ORゲートの接続信号は単一のビットのみならず、複数のビットからなるものであっても良いことに留意してください。
\fi

\ifshoworiginal
In this example, we do not define the type nor the width of signal \code{logic}.
Both are inferred from the type and width of the expression.
The standard logic operations in Chisel are:
\fi

\ifshowtransfirst %(自動翻訳)
この例では、タイプや信号\code{logic}の幅を定義しません。
どちらも、式の型と幅から推測されています。
Chiselで標準論理演算は以下のとおりです。
\fi

\ifshowtranssecond %(校正 4/23 diningyo)
この例では\code{logic}信号のビット幅や型を定義しません。
どちらも式の型やビット幅から推測されています。
Chiselでの標準的な論理演算は次のようになります。
\fi

\index{logical operations}

\shortlist{code/bool_ops.txt}

\ifshoworiginal
\noindent The arithmetic operations use the standard operators:
\fi

\ifshowtransfirst %(自動翻訳)
算術演算は、標準的な演算子を使用します。
\fi

\ifshowtranssecond %(校正 4/30 diningyo)
\noindent 算術演算には次の標準演算子を使用します。
\fi

\index{arithmetic operations}

\shortlist{code/arith_ops.txt}

\ifshoworiginal
\noindent The resulting width of the operation is the maximum width of the operators for
addition and subtraction, the sum of the two widths for the multiplication, and usually
the width of the numerator for divide and modulo operations.\footnote{The exact
details are available in the \myref{https://github.com/freechipsproject/firrtl/blob/master/spec/spec.pdf}{FIRRTL specification}.}
\fi

\ifshowtransfirst %(自動翻訳)
ERROR-TBD
%操作の結果の幅は、加算と減算、乗算のための2つの幅の和、および除算と剰余演算のための分子の通常幅のための演算子の最大幅です。
%\footnote{正確な詳細は\myref{https://github.com/freechipsproject/firrtl/blob/master/spec/spec.pdf}{FIRRTL specification}で利用可能です。｝
\fi

\ifshowtranssecond %(校正 4/30 diningyo)
演算結果のビット幅は、加算と減算は２つのうち大きい方のビット幅、乗算では2つのビット幅の合計、および除算とモジュロ演算では分子のビット幅になります。
\footnote{詳細は\myref{https://github.com/freechipsproject/firrtl/blob/master/spec/spec.pdf}{FIRRTL仕様}に記載されています。}
\fi

\ifshoworiginal
A signal can also first be defined as a \code{Wire} of some type. Afterward, we can assign a
value to the wire with the \code{:=} update operator.
\fi

\ifshowtransfirst %(自動翻訳)
信号はまた、最初にいくつかのタイプの\code{Wire}として定義することができます。
その後、我々は\code{:=}更新オペレータをワイヤーに値を割り当てることができます。
\fi

\ifshowtranssecond %(校正 4/30 diningyo)
信号はあるChiselの型の\code{Wire}として定義することもできます。
その後、\code{:=}update演算子を使用して\code{Wire}に値を割り当てることができます。
\fi

\shortlist{code/wire.txt}

\ifshoworiginal
A single bit can be extracted as follows:
\fi

\ifshowtransfirst %(自動翻訳)
次のように単一ビットを抽出することができます。
\fi

\ifshowtranssecond %(校正 4/30 diningyo)
特定の1ビットは、次のように抽出できます。
\fi

\shortlist{code/single_bit.txt}
\index{Bit!extraction}

\ifshoworiginal
\noindent A subfield can be extracted from end to start position:
\fi

\ifshowtransfirst %(自動翻訳)
\noindent サブフィールドは開始位置する端部から抽出することができます。
\fi

\ifshowtranssecond %(校正 4/30 diningyo)
サブフィールドは終了位置から開始位置までを指定することで抽出できます。
\fi

\shortlist{code/sub_field.txt}

\ifshoworiginal
\noindent Bit fields are concatenated with \code{Cat}.
\fi

\ifshowtransfirst %(自動翻訳)
ビットフィールドは\code{Cat}で連結されています。
\fi

\ifshowtranssecond %(校正 4/30 diningyo)
ビットフィールドは\code{Cat}で連結できます。
\fi

\shortlist{code/concat.txt}
\index{Bit!concatenation}

\ifshoworiginal
Table~\ref{tab:operators} shows the full list of operators
(see also \myref{https://github.com/freechipsproject/chisel3/wiki/Builtin-Operators}{builtin operators}).
The Chisel operator precedence is determined by the evaluation order of the circuit,
which follows the \myref{https://docs.scala-lang.org/tour/operators.html}{Scala operator precedence}.
If in doubt, it is always a good praxis to use parentheses.\footnote{The operator precedence in
Chisel is a side effect of the hardware elaboration when the tree of hardware nodes
is created by executing the Scala operators. The Scala operator precedence is similar but
not identical to Java/C. Verilog has the same operator precedence as C, but VHDL
has a different one. Verilog has precedence ordering for logic operations, but in VHDL
those operators have the same precedence and are evaluated from left to right.}
\fi

\ifshowtransfirst %(自動翻訳)
表〜\ref{tab:operators}は（も\myref{https://github.com/freechipsproject/chisel3/wiki/Builtin-Operators}{builtin operators}を参照）の演算子の完全なリストを示しています。
Chiselの演算子の優先順位は\myref{https://docs.scala-lang.org/tour/operators.html}{Scala operator precedence}に従う回路の評価順序によって決定されます。
疑問がある場合は、それが常に使用括弧に良い実践です。
ハードウェアノードのツリーはスカラ演算子を実行することによって作成されたときに、
TODO-ERROR
%\footnote{Chiselにおける演算子の優先順位は、ハードウェア精緻化の副作用です。Scalaの演算子の優先順位は、同様のが、Java / Cと同一ではありません。VerilogのはCと同じ演算子の優先順位を持っていますが、VHDLは異なる一つを有します。Verilogのは、論理演算の優先順序を持っていますが、VHDLでこれらの演算子は同じ優先順位を持ち、左から右に評価されます。｝
\fi

\ifshowtranssecond %(校正 4/30 diningyo)
表〜\ref{tab:operators}に、演算子の完全なリストを示します (\myref{https://github.com/freechipsproject/chisel3/wiki/Builtin-Operators}{組み込み演算子}も参照) 。
Chiselオペレータの優先順位は、\myref{https://docs.scala-lang.org/tour/operators.html}{Scalaオペレータの優先順位}に従う回路の評価順序によって決定されます。
不安な場合は、括弧を使用することをお勧めします。
\footnote{Chiselでの演算子の優先順位は、Scala演算子を実行してハードウェアノードのツリーを作成したときのハードウェア生成の副作用です。
Scalaの演算子の優先順位はJava/Cと似ていますが、同じではありません。
Verilogの演算子の優先順位はCと同じですが、VHDLの演算子の優先順位は異なります。
Verilogには論理演算の優先順位がありますが、VHDLではこれらの演算子は同じ優先順位を持ち、左から右に評価されます。}
\fi

\ifshoworiginal
Table~\ref{tab:functions} shows various functions defined on and for Chisel data types.
\fi

\ifshowtransfirst %(自動翻訳)
表〜\ref{tab:functions}は上とChiselのデータ型に対して定義された様々な機能を示しています。
\fi

\ifshowtranssecond %(校正 4/30 diningyo)
表〜\ref{tab:functions}はChiselの型に対して定義されたさまざまな関数をまとめたものです。
\fi

\ifshoworiginal
\begin{table}
 \centering
 \label{tab:operators}
  \begin{tabular}{lll}
    \toprule
    Operator & Description & Data types \\
    \midrule
    \code{* / \%} & multiplication, division, modulus & UInt, SInt \\
    \code{+ -} & addition, subtraction & UInt, SInt \\
    \code{=== =/=} & equal, not equal & UInt, SInt, returns Bool \\
    \code{> >= < <=} & comparison & UInt, SInt, returns Bool \\
    \code{<< >>} & shift left, shift right (sign extend on SInt) & UInt, SInt \\
    \code{\~} & NOT & UInt, SInt, Bool \\
    \code{\& | \^} & AND, OR, XOR & UInt, SInt, Bool \\
    \code{!} & logical NOT & Bool \\
    \code{\&\& ||} & logical AND, OR & Bool \\
    \bottomrule
  \end{tabular}
  \caption{Chisel defined hardware operators.}
\end{table}
\fi

\ifshowtransfirst %(自動翻訳)
\begin{table}
 \centering
 \label{tab:operators}
  \begin{tabular}{lll}
    \toprule
    Operator & Description & Data types \\
    \midrule
    \code{* / \%} & multiplication, division, modulus & UInt, SInt \\
    \code{+ -} & addition, subtraction & UInt, SInt \\
    \code{=== =/=} & equal, not equal & UInt, SInt, returns Bool \\
    \code{> >= < <=} & comparison & UInt, SInt, returns Bool \\
    \code{<< >>} & shift left, shift right (sign extend on SInt) & UInt, SInt \\
    \code{\~} & NOT & UInt, SInt, Bool \\
    \code{\& | \^} & AND, OR, XOR & UInt, SInt, Bool \\
    \code{!} & logical NOT & Bool \\
    \code{\&\& ||} & logical AND, OR & Bool \\
    \bottomrule
  \end{tabular}
  \caption{Chisel defined hardware operators.}
\end{table}
\fi

\ifshowtranssecond %(校正 4/30 diningyo)
\begin{table}
 \centering
 \label{tab:operators}
  \begin{tabular}{lll}
    \toprule
    演算子 & 処理 & データの型 \\
    \midrule
    \code{* / \%} & 乗算、除算、モジュロ & UInt, SInt \\
    \code{+ -} & 加算、減算 & UInt, SInt \\
    \code{=== =/=} & 等しい、等しくない & UInt, SInt, returns Bool \\
    \code{> >= < <=} & 比較 & UInt, SInt, returns Bool \\
    \code{<< >>} & 左シフト、右シフト (SIntの場合は符号拡張が行われる) & UInt, SInt \\
    \code{\~} & ビット反転 & UInt, SInt, Bool \\
    \code{\& | \^} & ビット論理積、ビット論理和、ビット排他的論理和 & UInt, SInt, Bool \\
    \code{!} & 否定 & Bool \\
    \code{\&\& ||} & 論理積、論理和 & Bool \\
    \bottomrule
  \end{tabular}
  \caption{Chiselで定義されているハードウェアの演算子}
\end{table}
\fi

\index{Operators}

\ifshoworiginal
\begin{table}
 \centering
 \label{tab:functions}
  \begin{tabular}{lll}
    \toprule
    Function & Description & Data types \\
    \midrule
    \code{v.andR v.orR v.xorR} & AND, OR, XOR reduction & UInt, SInt, returns Bool \\
    \code{v(n)} & extraction of a single bit & UInt, SInt \\
    \code{v(end, start)} & bitfield extraction & UInt, SInt \\
    \code{Fill(n, v)} & bitstring replication, n times & UInt, SInt \\
    \code{Cat(a, b, ...)} & bitfield concatenation & UInt, SInt \\
    \bottomrule
  \end{tabular}
  \caption{Chisel defined hardware functions, invoked on \code{v}.}
\end{table}
\fi

\ifshowtransfirst %(自動翻訳)
\begin{table}
 \centering
 \label{tab:functions}
  \begin{tabular}{lll}
    \toprule
    Function & Description & Data types \\
    \midrule
    \code{v.andR v.orR v.xorR} & AND, OR, XOR reduction & UInt, SInt, returns Bool \\
    \code{v(n)} & extraction of a single bit & UInt, SInt \\
    \code{v(end, start)} & bitfield extraction & UInt, SInt \\
    \code{Fill(n, v)} & bitstring replication, n times & UInt, SInt \\
    \code{Cat(a, b, ...)} & bitfield concatenation & UInt, SInt \\
    \bottomrule
  \end{tabular}
  \caption{Chisel defined hardware functions, invoked on \code{v}.}
\end{table}
\fi

\ifshowtranssecond %(校正 4/30 diningyo)
\begin{table}
 \centering
 \label{tab:functions}
  \begin{tabular}{lll}
    \toprule
    メソッド & 処理 & データ型 \\
    \midrule
    \code{v.andR v.orR v.xorR} & リダクションAND, OR, XOR & UInt, SInt, returns Bool \\
    \code{v(n)} & 特定の1bitの選択 & UInt, SInt \\
    \code{v(end, start)} & 連続ビットの選択 & UInt, SInt \\
    \code{Fill(n, v)} & n回ビット列を繰り返し & UInt, SInt \\
    \code{Cat(a, b, ...)} & ビット列の連結 & UInt, SInt \\
    \bottomrule
  \end{tabular}
  \caption{\code{v}に適用できるハードウェアのメソッド}
\end{table}
\fi

\index{Bit!reduction}
\index{Bitfield!extraction}
\index{Bitfield!concatenation}

\ifshoworiginal
\subsection{Multiplexer}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Multiplexer}
\fi
\ifshowtranssecond %(校正)
\subsection{マルチプレクサ}
\fi

\index{Multiplexer}

\ifshoworiginal
A \myref{https://en.wikipedia.org/wiki/Multiplexer}{multiplexer} is a circuit that selects between alternatives.
In the most basic form, it selects between two alternatives. Figure~\ref{fig:mux} shows
such a 2:1 multiplexer, or mux for short. Depending on the value of the
select signal (\code{sel}) signal \code{y} will represent signal \code{a} or
signal \code{b}.
\fi

\ifshowtransfirst %(自動翻訳)
A \myref{https://en.wikipedia.org/wiki/Multiplexer}{multiplexer}はその選択肢の間で選択する回路です。
最も基本的な形では、それは二つの選択肢の間で選択します。
図〜\ref{fig:mux}ショー例えば2：1マルチプレクサ、または略しMUX。
選択信号の値に応じて（\code{sel}）信号\code{y}は信号\code{a}又は信号\code{b}を表します。
\fi

\ifshowtranssecond %(校正 4/30 diningyo)
\myref{https://en.wikipedia.org/wiki/Multiplexer}{マルチプレクサ}は、複数の選択肢からの選択を行う回路です。
最も基本的な形式では、2つの選択肢のどちらかを選択します。
図〜\ref{fig:mux}はそのような2:1マルチプレクサ、略してmuxを示しています。選択信号 (sel) の値に応じて信号yは信号aまたは信号bのいずれかの値になります。
\fi

\ifshoworiginal
\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/mux}
  \caption{A basic 2:1 multiplexer.}
  \label{fig:mux}
\end{figure}
\fi

\ifshowtransfirst %(自動翻訳)
\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/mux}
  \caption{A basic 2:1 multiplexer.}
  \label{fig:mux}
\end{figure}
\fi

\ifshowtranssecond %(校正  5/4 mune10}
\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/mux}
  \caption{基本的な 2:1 マルチプレクサ.}
  \label{fig:mux}
\end{figure}
\fi

\ifshoworiginal
A multiplexer can be built from logic.
However, as multiplexing  is such a standard operation, Chisel provides a multiplexer,
\fi

\ifshowtransfirst %(自動翻訳)
マルチプレクサは、論理から構築することができます。
しかし、標準的な操作である多重ように、Chiselは、マルチプレクサを提供し、
\fi

\ifshowtranssecond %(校正 5/1 diningyo)
マルチプレクサはロジックから構築できます。
しかし多重化は標準的な操作なので、Chiselはマルチプレクサを提供しています。
\fi

\shortlist{code/mux.txt}

\ifshoworiginal
\noindent where \code{a} is selected when the \code{sel} is \code{true.B}, otherwise \code{b}
is selected. The type of \code{sel} is a Chisel \code{Bool}; the inputs \code{a} and \code{b}
can be any Chisel base type or aggregate (bundles or vectors) as long as they are the same
type.
\fi

\ifshowtransfirst %(自動翻訳)
どこ\code{sel}がそうでなければ\code{b}が選択され、\code{true.B}とき\code{a}が選択されています。
\code{sel}のタイプはChisel\code{Bool}あります。入力は\code{a}と\code{b}は、それらが同じタイプである限り、任意のChiselの基本型または集約（バンドルまたはベクター）であってもよいです。
\fi

\ifshowtranssecond %(校正 5/1 diningyo)
\noindent このマルチプレクサは\code{sel}が\code{true.B}のときに\code{a}が選択され、そうでなければ\code{b}が選択されます。
\code{sel}はChiselの\code{Bool}型です;入力\code{a}および\code{b}は同じ型であれば、任意のChisel基本型または集約型 (\code{Vec}や\code{Bundle}) にすることができます。
\fi

\ifshoworiginal
With logical and arithmetical operations and a multiplexer, every combinational
circuit can be described. However, Chisel provides further components and control abstractions
for a more elegant description of a combinational circuit, which are described in
a later chapter.
\fi

\ifshowtransfirst %(自動翻訳)
論理的かつ算術演算およびマルチプレクサを使用すると、すべての組み合わせ回路を記述することができます。
しかしながら、Chiselは、後の章で説明されている組み合わせ回路のよりエレガントな説明のための別の成分と制御の抽象化を提供します。
\fi

\ifshowtranssecond %(校正 5/1 diningyo)
論理演算、算術演算、それとマルチプレクサを使えばあらゆる組合せ回路を記述できます。
しかしChiselでは、後の章で取り扱うように組み合わせ回路のより洗練された記述を目的とした、さらなるコンポーネントと制御の抽象化を提供しています。
\fi

\ifshoworiginal
The second basic component needed to describe a digital circuit is a state element,
also called register, which is described next.
\fi

\ifshowtransfirst %(自動翻訳)
デジタル回路を記述するために必要な第二の基本的な構成要素について説明する、レジスタと呼ばれる状態の要素、です。
\fi

\ifshowtranssecond %(校正 5/1 diningyo)
デジタル回路を記述するために必要な第2の基本要素は、レジスタとも呼ばれる状態要素です。次節ではこれについて説明します。
\fi

\ifshoworiginal
\section{Registers}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Registers}
\fi
\ifshowtranssecond %(校正)
\section{レジスター}
\fi

\ifshoworiginal
\index{Register}
Chisel provides a register, which is a collection of
\myref{https://en.wikipedia.org/wiki/Flip-flop\_(electronics)\#D\_flip-flop}{D flip-flops}.
The register is implicitly connected to a global clock and is updated on the rising edge.
When an initialization value is provided at the declaration of the register,
it uses a synchronous reset connected to a global reset signal.
A register can be any Chisel type that can be represented as a collection of bits.
Following code defines an 8-bit register, initialized with 0 at reset:
\fi

\ifshowtransfirst %(自動翻訳)
Chiselは\myref{https://en.wikipedia.org/wiki/Flip-flop\_(electronics)\#D\_flip-flop}{D flip-flops}の集まりであるレジスタを、提供します。
レジスタは、暗黙的にグローバルクロックに接続され、立ち上がりエッジで更新されます。
初期値はレジスタの宣言に設けられている場合には、グローバルリセット信号に接続された同期リセットを使用します。
レジスタは、ビットの集合として表すことができる任意のChisel型とすることができます。
次のコードは、リセット時に0で初期化された8ビット・レジスタを定義します：
\fi

\ifshowtranssecond %(校正 7/5 diningyo)
Chiselには\myref{https://en.wikipedia.org/wiki/Flip-flop\_(electronics)\#D\_flip-flop}{D flip-flops}を集めた要素であるレジスタが備わっています。
レジスタには暗黙のうちに黒バーバルクロックが接続され、そのクロックの立ち上がりエッジで更新されます。初期値はレジスタの宣言時に指定することが可能で、その値はグローバルリセットに接続された同期リセットで使用されます。
レジスタはビットの集合体として表現できる、任意のChiselの型として扱うことができます。
次のコードは、0で初期化された8ビットのレジスタを宣言するものです。
\fi

\shortlist{code/register.txt}

\ifshoworiginal
\noindent An input is connected to the register with the \code{:=} update operator and
the output of the register can be used just with the name in an expression:
\fi

\ifshowtransfirst %(自動翻訳)
入力は\code{:=}更新オペレータとレジスタに接続され、レジスタの出力は、式で名前だけで使用することができます。
\fi

\ifshowtranssecond %(校正 7/5 diningyo)
\noindent 入力はレジスタにアップデート演算子\code{:=}によって接続され、レジスタの出力はコード上の名前をそのまま使用できます。
\fi

\shortlist{code/reg_con.txt}

\ifshoworiginal
\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/register-reset-0}
  \caption{A D flip-flop based register with a synchronous reset to 0.}
  \label{fig:register-reset-0}
\end{figure}
\fi

\ifshowtranssecond %(校正 7/5 diningyo)
\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/register-reset-0}
  \caption{同期リセットで0初期化されるDフリップ・フロップベースのレジスタ}
  \label{fig:register-reset-0}
\end{figure}
\fi


\ifshoworiginal
\noindent A register can also be connected to its input at the definition:
\fi

\ifshowtransfirst %(自動翻訳)
レジスタはまた、定義での入力に接続することができます。
\fi

\ifshowtranssecond %(校正 7/5 diningyo)
レジスタの宣言時に、レジスタへの入力を接続することもできます。
\fi

\shortlist{code/reg_next.txt}

\ifshoworiginal
Figure~\ref{fig:register-reset-0} shows the circuit of our register definition with
a clock, a synchronous reset to \code{0.U}, input \code{d}, and output \code{q}.
The global signals \code{clock} and \code{reset} are implicitly connected to
each register defined.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:register-reset-0}は、私たちのレジスタクロックと定義、\code{0.U}、入力\code{d}に同期リセット、および出力\code{q}の回路を示しています。
グローバル信号\code{clock}と\code{reset}は、暗黙的に定義された各レジスタに接続されています。
\fi

\ifshowtranssecond %(校正 7/5 diningyo)
図〜\ref{fig:register-reset-0}は、先ほどのレジスタの定義を回路図で示したものです。
クロックと\code{0.U}で初期化するための同期リセット、入力\code{d}、出力\code{q}が含まれています。
グローバルな信号である\code{clock}と\code{reset}は、定義されたレジスタに、暗黙のうちに接続されます。
\fi


\ifshoworiginal
\noindent A register can also be connected to its input and a constant as
initial value at the definition:
\fi

\ifshowtransfirst %(自動翻訳)
レジスタは、その入力と定義の初期値として定数に接続することができます。
\fi

\ifshowtranssecond %(校正 7/5 diningyo)
\noindent レジスタ宣言時に、入力を接続する場合でも、初期値として定数を接続できます。
\fi

\shortlist{code/reg_both.txt}

\ifshoworiginal
\noindent To distinguish between signals representing combinational logic and registers,
a common practice is to postfix register names with \code{Reg}.
Another common practice, coming from Java and Scala, is to use
\myref{https://en.wikipedia.org/wiki/Camel_case}{camelCase} for
identifier consisting of several words. The convention is to start
functions and variables with a lower case letter and classes (types) with
an upper case letter.
\fi

\ifshowtransfirst %(自動翻訳)
組合せ論理とレジスタを表す信号を区別するために、一般的な方法は\code{Reg}と後置レジスタ名です。
JavaとScalaのから来るもう一つの一般的な方法は、いくつかの単語からなる識別子のため\myref{https://en.wikipedia.org/wiki/Camel_case}{camelCase}を使用することです。
規則は、大文字と小文字とクラス（タイプ）と関数と変数を開始することです。
\fi

\ifshowtranssecond %(校正 7/5 diningyo)
\noindent 組み合わせ論理とレジスタを区別するための一般的な方法として、レジスタ名の後ろに\code{Reg}を付ける方法があります。
他にJavaとScalaに由来した方法として、\myref{https://en.wikipedia.org/wiki/Camel_case}{キャメル・ケース} で複数の言葉から構成される識別子を付与する方法があります。
\fi

\ifshoworiginal
\subsection{Counting}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Counting}
\fi
\ifshowtranssecond %(校正)
\subsection{カウント}
\fi

\index{Counting}

\ifshoworiginal
Counting is a fundamental operation in digital systems. On might count events.
However, more often counting is used to define a time interval. Counting the
clock cycles and triggering an action when the time interval has expired.
\fi

\ifshowtransfirst %(自動翻訳)
カウントは、デジタルシステムの基本的な操作です。
オンは、イベントをカウントすることがあります。
しかし、より頻繁にカウントが時間間隔を定義するために使用されます。
クロックサイクルをカウントし、時間間隔が経過したときにアクションをトリガーします。
\fi

\ifshowtranssecond %(校正 7/5 diningyo)
カウント動作はデジタルシステムの基本的な操作です。イベントをカウントすることもありますが、より多く見られるのは
時間の間隔を定義するために使用されるケースです。クロックのサイクル数をカウントして、指定の時間間隔が経過した際に、動作のトリガとします。
\fi

\ifshoworiginal
A simple approach is counting up to a value. However, in computer science,
and digital design, counting starts at 0. Therefore, if we want to count till
10, we count from 0 to 9. The following code shows such a counter that counts
till 9 and wraps around to 0 when reaching 9.
\fi

\ifshowtransfirst %(自動翻訳)
シンプルなアプローチは、値をカウントアップされます。
しかし、コンピュータサイエンス、デジタルデザインで、カウントは0から始まります。
私たちは10までカウントするようにしたい場合はそのため、我々は、0から9までカウントします。
次のコードを示し9に到達したときに9までの数とすると、0にラップアラウンドするようにカウンタ。
\fi

\ifshowtranssecond %(校正 7/5 diningyo)
シンプルなアプローチでは、値をカウントアップしていきます。
しかし、コンピューター・サイエンスとデジタル設計では、カウントは0からスタートします。
そのため、10をカウントする場合は、0から9までのカウントを行います。
これを行ったのが次に示すコードで、9までカウントした後は０に戻ります。
\fi

\shortlist{code/counter.txt}

\ifshoworiginal
\section{Structure with Bundle and Vec}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Structure with Bundle and Vec}
\fi
\ifshowtranssecond %(校正)
\section{バンドルとVecを用いたストラクチャ}
\fi

\index{Structure}
\index{Array}
\index{Collection}
\index{Vector}
\index{Bundle}

\ifshoworiginal
Chisel provides two constructs to group related signals: (1) a \code{Bundle} to group
signals of different types and (2) a \code{Vec} to represent an indexable collection of signals
of the same type.
\code{Bundle}s and \code{Vec}s can be arbitrarily nested.
\fi

\ifshowtransfirst %(自動翻訳)
同じタイプの信号の割出し可能なコレクションを表現するために、（1）異なる種類の基信号に\code{Bundle}及び（2）\code{Vec}：ノミは、グループ関連信号に2つの構築物を提供します。
\code{Bundle}sと\code{Vec}sは任意に入れ子にすることができます。
\fi

\ifshowtranssecond %(校正 7/6 diningyo)
Chiselは関連した信号をまとめるための構造を2つ備えています。
1つは\code{Bundle}で、異なった型をグループ化して扱うもので、2つ目は\code{Vec}と呼ばれ、同じ型の信号をインデックス指定可能なコレクションとして表現するものです。
\code{Bundle}と\code{Vec}は必要ならネストするできます。
\fi

\ifshoworiginal
A Chisel bundle groups several signals. The entire bundle can be referenced
as a whole, or individual fields can be accessed by their name.
We can define a bundle (collection of signals) by defining a class that
extends \code{Bundle} and list the fields as \code{val}s within the constructor block.
\fi


\ifshowtransfirst %(自動翻訳)
AChiselバンドルグループのいくつかの信号を。
バンドル全体は、全体として参照することができ、または個々のフィールドは、その名前によってアクセスすることができます。
我々は\code{Bundle}、リストコンストラクタブロック内\code{val}sなどのフィールドを拡張するクラスを定義してバンドル（信号の集合）を定義することができます。
\fi

\ifshowtranssecond %(校正 7/6 diningyo)
Chiselのバンドルは複数の信号をグループ化します。
バンドル全体を、単一の名称で参照することも出来ますし、個々の信号名によって各フィールドにもアクセス可能です。
バンドル（信号のコレクション）を定義するためには、\code{Bundle}クラスを継承したクラスを定義し、クラスのコンストラクタ内に\code{val}でフィールドをリストアップします。
\fi

\shortlist{code/bundle.txt}

\ifshoworiginal
\noindent To use a bundle, we create it with \code{new} and wrap it into a \code{Wire}.
The fields are accessed with the dot notation:
\fi

\ifshowtransfirst %(自動翻訳)
バンドルを使用するには、我々は\code{new}でそれを作成し、\code{Wire}にそれを包みます。
フィールドは、ドット表記を使用してアクセスされます。
\fi

\ifshowtranssecond %(校正 7/6 diningyo)
\noindent バンドルを使用する場合は、そのバンドルのクラスを\code{new}でインスタンスし、\code{Wire}でラップします。
フィールドへのアクセスは"."（ドット）を使って行います。
\fi

\shortlist{code/bundle_use.txt}

\ifshoworiginal
Dot notation is common in object-oriented languages, where \code{x.y} means
\code{x} is a reference to an object and \code{y} is a field of that object.
As Chisel is object-oriented, we use dot notation to access fields in a bundle.
A bundle is similar to a \code{struct} in C, a \code{record} in VHDL, or a
\code{struct} in SystemVerilog.
A bundle can also be referenced as a whole:
\fi

\ifshowtransfirst %(自動翻訳)
\code{x.y}は\code{x}がオブジェクトへの参照であることを意味し、\code{y}がそのオブジェクトのフィールドであるドット表記は、オブジェクト指向言語では一般的です。
Chiselは、オブジェクト指向であるように、我々は、バンドル内のアクセスフィールドにドット表記を使用しています。
バンドルはCで\code{struct}、VHDLで\code{record}、またはSystemVerilogの中\code{struct}と同様です。
バンドルはまた、全体として参照することができます。
\fi

\ifshowtranssecond %(校正 7/6 diningyo)
"."（ドット）を用いた表記はオブジェクト指向言語では一般的なものです。
\code{x.y}という表記があった場合、\code{x}はオブジェクトへの参照を示し、\code{y}はそのオブジェクトのフィールドとなります。
Chiselはオブジェクト指向言語であるため、バンドル内のフィールドへのアクセスは"."（ドット）を使用して行います。
バンドルはC言語やSystem Verilogの\code{struct}、VHDLでは\code{record}に似ています。
バンドルはまた、全体としても参照することができます。
\fi

\shortlist{code/bundle_ref.txt}


\ifshoworiginal
A Chisel \code{Vec} represents a collection of signals of the same type (a vector).
Each element can be accessed by an index. A Chisel \code{Vec} is similar
to array data structures in other programming languages.\footnote{The name \codefoot{Array}
is already used in Scala.}
A \code{Vec} is created by calling the constructor with two parameters: the
number of elements and the type of the elements. A combinational \code{Vec}
needs to be wrapped into a \code{Wire}
\fi

\ifshowtransfirst %(自動翻訳)
AChisel\code{Vec}は、同じタイプ（ベクトル）の信号の集合を表します。
各要素は、インデックスによってアクセスすることができます。
AChisel\code{Vec}は、他のプログラミング言語の配列データ構造に類似しています。
\footnote{\codefoot{Array}はすでにScalaで使用される名前。要素の数及び要素の種類：A}
\code{Vec}は、2つのパラメータを持つコンストラクタを呼び出すことにより作成されます。
組み合わせ\code{Vec}は\code{Wire}にラップする必要があります
\fi

\ifshowtranssecond %(校正 7/6 diningyo)
Chiselの\code{Vec}は同じ型（ベクトル）の信号のコレクションを表現するものです。
各要素へはインデックスを用いて、アクセスできます。Chiselの\code{Vec}は他のプログラミング言語においての、配列のようなデータ構造と似ているものです。
\footnote{Scalaには\codefoot{Array}という名前のデータ型が存在しています。}
\code{Vec}は2つのパラメータを持ったコンストラクタを呼び出すことで、生成できます。
2つのパラメータとは、要素数と要素の型です。
組み合わせ論理の\code{Vec}を使うには、\code{Wire}でラップする必要があります。
\fi

\shortlist{code/vec.txt}

\ifshoworiginal
\noindent Individual elements are accessed with \code{(index)}.
\fi

\ifshowtransfirst %(自動翻訳)
個々の要素は\code{(index)}でアクセスされます。
\fi

\ifshowtranssecond %(校正 7/6 diningyo)
\noindent 個々の要素は\code{<Vecの変数>(インデックス)}でアクセスします。
\fi

\shortlist{code/vec_access.txt}

\ifshoworiginal
A vector wrapped into a \code{Wire} is a multiplexer.
We can also wrap a vector into a register to define an array of registers.
Following example defines a register file for a processor; 32 registers
each 32-bits wide, as for a classic 32-bit
\myref{https://en.wikipedia.org/wiki/Reduced_instruction_set_computer}{RISC}
processor, like the 32-bit version of \myref{https://en.wikipedia.org/wiki/RISC-V}{RISC-V}.
\fi

\ifshowtransfirst %(自動翻訳)
\code{Wire}に包まれたベクトルは、マルチプレクサです。
また、レジスタの配列を定義するためにレジスタにベクトルをラップすることができます。
例に従うと、プロセッサのレジスタファイルを定義します。 32個のレジスタ\myref{https://en.wikipedia.org/wiki/RISC-V}{RISC-V}の32ビット版などの古典的な32ビット\myref{https://en.wikipedia.org/wiki/Reduced_instruction_set_computer}{RISC}プロセッサの広い各32ビット、。
\fi

\ifshowtranssecond %(校正 7/15 diningyo)
\code{Wire}で包まれた\code{Vec}はマルチプレクサになります。
またレジスタを\code{Vec}で包むと、レジスタの配列となります。次の例ではプロセッサのための32bit x 32のレジスタファイルを定義しています。
この例は32-bit版の\myref{https://en.wikipedia.org/wiki/RISC-V}{RISC-V}のような、古典的な\myref{https://en.wikipedia.org/wiki/Reduced_instruction_set_computer}{RISC}プロセッサで用いられます。
\fi

\shortlist{code/reg_file.txt}

\ifshoworiginal
\noindent An element of that register file is accessed with an index and used as a normal register.
\fi

\ifshowtransfirst %(自動翻訳)
そのレジスタファイルの要素は、インデックスを使用してアクセスし、通常のレジスタとして使用されます。
\fi

\ifshowtranssecond %(校正 7/15 diningyo)
\noindent レジスタファイルの各要素へは、インデックスを用いてアクセスをおこない、それらは通常のレジスタと同様に使用できます。
\fi
\shortlist{code/reg_file_access.txt}

\ifshoworiginal
We can freely mix bundles and vectors. When creating a vector with a bundle
type, we need to pass a prototype for the vector fields. Using our
\code{Channel}, which we defined above, we can create a vector of channels with:
\fi

\ifshowtransfirst %(自動翻訳)
私たちは自由にバンドルおよびベクターを混在させることができます。
バンドルタイプのベクトルを作成するとき、我々はベクトル場のプロトタイプを渡す必要があります。
我々は上記で定義された私たちの\code{Channel}を使用して、我々は持つチャネルのベクトルを作成することができます。
\fi

\ifshowtranssecond %(校正 7/15 diningyo)
\code{Bundle}型と\code{Vec}型は自由に混在できます。
\code{Bundle}型を要素とする\code{Vec}型を作る場合、\code{Vec}のフィールドに\code{Bundle}型のプロトタイプを渡す必要があります。
先ほど、上で定義した\code{Channel}を使う場合、次のようにして\code{Channel}型の\code{Vec}を作成できます。
\fi

\shortlist{code/vec_bundle.txt}


\ifshoworiginal
\noindent A bundle may as well contain a vector:
\fi

\ifshowtransfirst %(自動翻訳)
バンドルは、同様のベクターが含まれる場合があります。
\fi

\ifshowtranssecond %(校正 7/15 diningyo)
\noindent 同様に、\code{Bundle}にも\code{Vec}を含むことができます。
\fi

\shortlist{code/bundle_vec.txt}

\ifshoworiginal
When we want a register of a bundle type that needs a reset value,
we first create a \code{Wire} of that bundle, set the individual fields
as needed, and then passing this bundle to a \code{RegInit}:
\fi

\ifshowtransfirst %(自動翻訳)
必要に応じて、その後、\code{RegInit}にこのバンドルを渡すと、我々はリセット値を必要とする、バンドルタイプのレジスタをしたい場合は、私たちが最初にそのバンドルの\code{Wire}を作成し、個々のフィールドを設定します。
\fi

\ifshowtranssecond %(校正 7/15 diningyo)
リセットが必要な\code{Bundle}型のレジスタが使う場合は、最初にその\code{Bundle}型の\code{Wire}を作成し、個々のフィールドに必要な値を設定した後、この\code{Wire}の変数を\code{RegInit}に渡します。
\fi

\shortlist{code/bundle_reg_init.txt}

\ifshoworiginal
With combinations of \code{Bundle}s and \code{Vec}s we can define our own data
structures, which are powerful abstractions.
\fi

\ifshowtransfirst %(自動翻訳)
\code{Bundle}sと\code{Vec}sの組み合わせで、私たちは強力な抽象化されている当社独自のデータ構造を定義することができます。
\fi

\ifshowtranssecond %(校正 7/15 diningyo)
\code{Bundle}型と\code{Vec}型の組み合わせを使うことで、強力に抽象化された、任意のデータ構造を定義できます。
\fi

\ifshoworiginal
\section{Chisel Generates Hardware}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Chisel Generates Hardware}
\fi
\ifshowtranssecond %(校正)
\section{Chisel によるハードウェア生成}
\fi

\ifshoworiginal
After seeing some initial Chisel code, it might look similar to classic programming
languages such as Java or C. However, Chisel (or any other hardware description
language) does define hardware components. While in a software program one
line of code after the other is executed, in hardware all lines of code
\emph{execute in parallel}.
\fi

\ifshowtransfirst %(自動翻訳)
いくつかの初期Chiselコードを見た後、それは、JavaやCのような古典的なプログラミング言語のようになります。
しかしながら、Chisel（または任意の他のハードウェア記述言語）は、ハードウェア・コンポーネントを定義しません。
他の後のコードのソフトウェアプログラム一列にハードウェアで、コード\emph{execute in parallel}のすべての行を実行している間。
\fi

\ifshowtranssecond %(校正 7/30 diningyo)
最初のChiselのコードを見た後に、JavaやC言語のような古典的なプログラミング言語に似ている、と思われたかもせいれません。
しかし、Chisel（もしくは他のハードウェア記述言語）はハードウェア／コンポーネントを定義胃しています。
ソフトウェアのプログラムでは1行のコードは他のコードの後に実行されますが、ハードウェアにおいてはすべてのコードが並列に実行されます。
\fi

\ifshoworiginal
It is essential to keep in mind that Chisel code does generate hardware.
Try to imagine, or draw on a sheet of paper, the individual blocks that
are generated by your Chisel circuit description.
Each creation of a component adds hardware; each assignment statement
generates gates and/or flip-flops.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselコードは、ハードウェアを生成しないことを心に留めておくことが不可欠です。
想像してみてください、または紙に描き、あなたのリグ回路記述によって生成された個々のブロック。
コンポーネントのそれぞれの作成は、ハードウェアを追加します。各代入文は、ゲートを生成および/またはフリップフロップ。
\fi

\ifshowtranssecond %(校正 7/30 diningyo)
Chiselのコードはハードウェアを生成するものである、ということを心に留めておく必要があります。頭で思い描いた、もしくは紙の上に書いた、個々のブロックが、Chiselの回路記述によって生成されます。
すべてのコンポーネントの生成や、すべての接続の記述はANDやOR、フリップロップ等のゲート素子を生成します。
\fi

\ifshoworiginal
More technically, when Chisel executes your code it runs as a Scala program, and
by executing the Chisel statements, it \emph{collects} the hardware components
and connects those nodes. This network of hardware nodes is the hardware,
which can spill out Verilog code for ASIC or FPGA synthesis or can be
tested with a Chisel tester.
The network of hardware nodes is what is executed in fully parallel.
\fi

\ifshowtransfirst %(自動翻訳)
もっと技術的にChiselがあなたのコードを実行するとき、それはScalaのプログラムとして実行され、Chisel文を実行することで、それはハードウェアコンポーネントを\emph{collects}し、それらのノードを接続します。
ハードウェアノードのこのネットワークは、ASICまたはFPGA合成のためのVerilogコードをこぼれができ、またはChiselテスタで試験することができるハードウェアです。
ハードウェアノードのネットワークは、完全に並列に実行されるものです。
\fi

\ifshowtranssecond %(校正 7/30 diningyo)
より技術的な面においては、ChiselのコードがScalaのプログラムとして処理されるとき、実行されたChiselのコードによって、ハードウェア・コンポーネントが\emph{集約}され、各々のノードに接続されます。このハードウェア・ノードのネットワークが、ASICやFPGAの合成用のVerilogコードやChiselのテスターによってテストされるハードウェアです。
このハードウェア・ノートのネットワークは完全に並列に実行されます。
\fi

\ifshoworiginal
For a software engineer imagine this immense parallelism that you can
create in hardware without needing to partition your application into threads
and getting the locking correct for the communication.
\fi

\ifshowtransfirst %(自動翻訳)
ソフトウェアエンジニアのためにあなたがスレッドにアプリケーションを分割する必要との通信のための正しいロックを取得せずに、ハードウェアで作成することができ、この巨大な並列性を想像してみてください。
\fi

\ifshowtranssecond %(校正 8/2 diningyo)
ソフトウェアエンジニアの方は、アプリケーション用のスレッドや通信のためのロックの取得が必要ない、莫大な並列性を想像してみてください。
\fi

\ifshoworiginal
\section{Exercise}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Exercise}
\fi
\ifshowtranssecond %(校正)
\section{演習}
\fi

\ifshoworiginal
In the introduction you implemented a blinking LED on an FPGA board
(from \myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}), which is a reasonable
hardware \emph{Hello World} example. It used only internal state, a single LED output, and no input.
Copy that project into a new folder and extend it by adding some inputs to the \code{io} \code{Bundle}
with \code{val sw = Input(UInt(2.W))}.
\fi

\ifshowtransfirst %(自動翻訳)
導入では、合理的なハードウェア\emph{Hello World}例である（\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}から）FPGAボード上の点滅LEDを実装しました。
それは、内部状態、単一のLED出力、及び無入力を使用します。
新しいフォルダにそのプロジェクトをコピーし、\code{val sw = Input(UInt(2.W))}で\code{io} \code{Bundle}にいく
つかの入力を追加することによって、それを拡張。
\fi

\ifshowtranssecond %(校正 8/2 diningyo)
導入の演習では、ハードウェア版\emph{Hello World}であるFPGAボードを使ったLチカを実装しました（(from \myref{https://github.com/schoeberl/chisel-examples}{chisel-examples})）。
この実装では、唯一の内部ステートと、1つのLED出力のみで、入力はありませんでした。
このプロジェクトを別のフォルダーにコピーして、変数\code{io}の\code{Bundle}に\code{val sw = Input(UInt(2.W))}を追加してください。
\fi

\shortlist{code/basic_exercise.txt}


\ifshoworiginal
\noindent For those switches, you also need to assign the pin names for the FPGA board.
You can find examples of pin assignments in the Quartus project files of the ALU project
(e.g., for the \myref{https://github.com/schoeberl/chisel-examples/blob/master/quartus/altde2-115/alu.qsf}{DE2-115 FPGA board}).
\fi

\ifshowtransfirst %(自動翻訳)
これらのスイッチの場合、あなたはまた、FPGAボードのピン名を割り当てる必要があります。
あなたは、ALUのプロジェクト（EののQuartusプロジェクトファイルにピン割り当ての例を見つけることができます。
グラム。
、）\myref{https://github.com/schoeberl/chisel-examples/blob/master/quartus/altde2-115/alu.qsf}{DE2-115 FPGA board}ため。
\fi

\ifshowtranssecond %(校正 9/3 diningyo)
これらのスイッチのために、FPGAボード上のピンの名前を割り振る必要があります。
これらのピンのアサインはALU用のQuartusのプロジェクトファイルの中で、見つけられます。
（例：\myref{https://github.com/schoeberl/chisel-examples/blob/master/quartus/altde2-115/alu.qsf}{DE2-115 FPGA board}）
\fi

\ifshoworiginal
When you have defined those inputs and the pin assignment, start with a simple test:
drop all blinking logic from the design and connect one switch to the LED output;
compile and configure the FPGA device. Can you switch the LED on an off with the switch?
If yes, you have now inputs available. If not, you need to debug your FPGA configuration.
The pin assignment can also be done with the GUI version of the tool.
\fi

\ifshowtransfirst %(自動翻訳)
あなたはこれらの入力ピンの割り当てを定義した場合には、簡単なテストを開始：LED出力する設計と接続する1つのスイッチからすべての点滅のロジックをドロップします。コンパイルしてFPGAデバイスを設定します。
あなたはスイッチでオフにLEDを切り替えることはできますか？そうならば、あなたは今利用できる入力があります。
そうでない場合、あなたはあなたのFPGAのコンフィギュレーションをデバッグする必要があります。
ピンアサインは、ツールのGUIバージョンで行うことができます。
\fi

\ifshowtranssecond %(校正 9/3 diningyo)
これらの入力とピン・アサインを定義すれば、簡単なテストを始められます。
そのテストとは、そのデザインから点滅する論理を削除し、１つのスイッチのをLEDの出力に接続し、コンパイルとFPGAへの設定を行うことです。
スイッチのON/OFFによってLEDを切り替えられましたか？答えが”はい”であれば、その入力は有効です。
もし”いいえ”なら、FPGAの設定をデバッグする必要があります。ピンの割り振りはツールのGUI画面で行うことが可能です。
\fi

\ifshoworiginal
Now use two switches and implement one of the basic combinational functions,
e.g., AND two switches and show the result on the LED. Change the function.
The next step involves three input switches to implement a multiplexer: one acts as
a select signal, and the other two are the two inputs for the 2:1 multiplexer.
\fi

\ifshowtransfirst %(自動翻訳)
今、二つのスイッチを使用すると、電子の基本的な組み合わせ関数のいずれかを実装します。
グラム。
、2つのスイッチ及びLEDに結果を示します。
機能を変更します。
一つは選択信号として機能し、他の2つは2つの入力である：1マルチプレクサ次のステップは、マルチプレクサを実装するためにスイッチ三つの入力を含みます。
\fi

\ifshowtranssecond %(校正 9/3 diningyo)
２つのスイッチとANDのような基本的な組み合わせ論理の結果をLEDに出力してみましょう。
その次のステップは３つの入力からなるマルチプレクサを考えましょう。
１つの入力が選択用の信号となり、残りの２つは信号の入力となる2入力／１出力のマルチプレクサです。
\fi

\ifshoworiginal
Now you have been able to implement simple combinational functions and test them
in real hardware in an FPGA. As a next step, we will take a first look at how the build
process works to generate an FPGA configuration. Furthermore, we will also
explore a simple testing framework from Chisel, which allows you to test circuits
without configuring an FPGA and toggle switches.
\fi

\ifshowtransfirst %(自動翻訳)
今、あなたは、単純な組み合わせの機能を実装し、FPGAにおける実際のハードウェアでそれらをテストすることができました。
次のステップとして、私たちは、ビルドプロセスは、FPGAのコンフィギュレーションを生成するために、どのように機能するかで最初に見てみましょう。
さらに、我々はまた、あなたがFPGAやトグルスイッチを設定せずにテスト回路を可能にChiselから、簡単なテストフレームワークを探索します。
\fi

\ifshowtranssecond %(校正 9/3 diningyo)
ここまででシンプルな組み合わせ論理を実装して、その機能をFPGA上の本物のハードウェアでテストしました。次のステップでは、FPGAのコンフィグレーションを生成するためのビルドプロセスが、どのようにして動作するのかを、少し見てみましょう。
\fi

\ifshoworiginal
\chapter{Build Process and Testing}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Build Process and Testing}
\fi
\ifshowtranssecond %(校正)
\chapter{ ビルドプロセスとテスト (L2997 mune10 初回校正済) } %(2020-0810 校正  第3章  =============================================)
\fi

\ifshoworiginal
To get started with more interesting Chisel code we first need to learn how to compile
Chisel programs, how to generate Verilog code for execution in an FPGA, and how
to write tests for debugging and to verify that our circuits are correct.
\fi

\ifshowtransfirst %(自動翻訳)
もっと面白いChiselコードFPGAで実行し、どのようにデバッグするためのテストを記述すると私たちの回路が正しいことを確認するためのVerilogコードを生成する方法を、Chiselプログラムをコンパイルする方法については、私たち最初の必要性を開始するには。
\fi

\ifshowtranssecond %(校正 5/4 mune10)
もっと面白い Chisel コード記述を始める前に、
まずChiselプログラムのコンパイル方法、
FPGAで実行するためのVerilogコードの生成方法、
回路が正しいことを検証するためのデバッグやテストの書き方を学ぶ必要があります。
\fi

\ifshoworiginal
Chisel is written in Scala, so any build process that supports Scala is possible
with a Chisel project. One popular build tool for Scala is \myref{https://www.scala-sbt.org/}{sbt},
which stands for the Scala interactive build tool.
Besides driving the build and test process, \code{sbt} also downloads the correct
version of Scala and the Chisel libraries.
\fi

\ifshowtransfirst %(自動翻訳)
Scalaのをサポートする任意のビルドプロセスがChiselプロジェクトで可能であるので、Chiselは、Scalaで書かれています。
Scalaのための1つの一般的なビルドツールは、Scalaの対話型のビルドツールの略\myref{https://www.scala-sbt.org/}{sbt}、です。
ビルドとテストプロセスを駆動するほか、\code{sbt}もスカラとChiselライブラリの正しいバージョンをダウンロードします。
\fi

\ifshowtranssecond %(校正 5/4 mune10)
ChiselはScalaで書かれているので、ScalaをサポートするビルドプロセスはChiselプロジェクトで利用可能です。
Scalaの人気のあるビルドツールの一つに、Scala interactive Build Toolの頭文字をとった \myref{https://www.scala-sbt.org/}{sbt} があります。
\code{sbt} は、ビルドやテストプロセスを実行するだけでなく、正しいバージョンのScalaとChiselライブラリをダウンロードします。
\fi

\ifshoworiginal
\section{Building your Project with sbt}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Building your Project with sbt}
\fi
\ifshowtranssecond %(校正)
\section{sbt でプロジェクトを構築する}
\fi

\index{sbt}

\ifshoworiginal
The Scala library that represents Chisel and the Chisel testers are automatically
downloaded during the build process from a Maven repository.
The libraries are referenced by \code{build.sbt}. It is possible to configure \code{build.sbt}
with \code{latest.release} to always use the most actual version of Chisel.
However, this means on each build the version is looked up from the Maven
repository. This lookup needs an Internet connection for the build to succeed.
Better use a dedicated version of Chisel and all other Scala libraries in your \code{build.sbt}.
Maybe sometimes it is also good to be able to write hardware code and test it without an Internet connection.
For example, it is cool to do hardware design on a plane.
\fi

\ifshowtransfirst %(自動翻訳)
ChiselとChiselテスターを表しScalaのライブラリが自動的にMavenのリポジトリからビルドプロセス中にダウンロードされています。
ライブラリは\code{build.sbt}によって参照されています。
常にChiselのほとんどの実際のバージョンを使用する\code{latest.release}で\code{build.sbt}を設定することが可能です。
しかし、各ビルドバージョンでこの手段は、Mavenのリポジトリから検索されます。
このルックアップはビルドが成功するためにインターネット接続が必要です。
より良いChiselの専用バージョンと\code{build.sbt}内の他のすべてのScalaのライブラリを使用します。
たぶん、時にはインターネットに接続せずに、ハードウェアのコードとテストを書くことができるようにすることも良いです。
例えば、それは、平面上のハードウェア設計を行うためにクールです。
\fi

\ifshowtranssecond %(校正 5/4 mune10)
Chiselを表すScalaライブラリとChiselのテスターは、ビルド処理中にMavenリポジトリから自動的にダウンロードされます。
各種ライブラリは \code{build.sbt} で指定します。
\code{build.sbt} で \code{latest.release} で設定することで、常に最新バージョンの Chisel を使用するようにすることができます。
しかし、これは各ビルドで必要なバージョンがMavenリポジトリから検索されることを意味します。
ビルドを成功させるためには、インターネット接続が検索のために必要になります。
Chiselやその他のScalaライブラリは、専用のバージョンを \code{build.sbt} で指定した方が良いでしょう。
であれば、インターネットに接続しなくてもハードウェアコードを書いてテストすることが出来ます。
例えば、飛行機の上でハードウェア設計をするのはクールですよね。
\fi

\ifshoworiginal
\subsection{Source Organization}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Source Organization}
\fi
\ifshowtranssecond %(校正)
\subsection{ソースコードの構成}
\fi

\index{Source organization}

\ifshoworiginal
\code{sbt} inherits the source convention from the \myref{https://maven.apache.org/}{Maven}
build automation tool. Maven also organizes repositories of open-source Java libraries.\footnote{That is
also the place where you downloaded the Chisel library on your first build:
\url{https://mvnrepository.com/artifact/edu.berkeley.cs/chisel3}.}
\fi

\ifshowtransfirst %(自動翻訳)
\code{sbt}は\myref{https://maven.apache.org/}{Maven}ビルド自動化ツールからソース規則を継承します。
Mavenはまた、オープンソースのJavaライブラリのリポジトリを整理します。
\footnote{また、あなたが最初のビルドにChiselライブラリをダウンロードした場所です。\url{https://mvnrepository.com/artifact/edu.berkeley.cs/chisel3}.}
\fi

\ifshowtranssecond %(校正 5/4 mune10)
\code{sbt} はビルド自動化ツール \myref{https://maven.apache.org/}{Maven} のソース規約を継承しています。
また、MavenはオープンソースのJavaライブラリのリポジトリを取りまとめます。
\footnote{最初のビルドでChiselライブラリをダウンロードした場所になります。\url{https://mvnrepository.com/artifact/edu.berkeley.cs/chisel3}.}
\fi

\ifshoworiginal
\begin{figure}
\dirtree{%
.1 project.
.2 src.
.3 main.
.4 scala.
.5 package.
.6 sub-package.
.3 test.
.4 scala.
.5 package.
.2 target.
.2 generated.
}
\caption{Source tree of a Chisel project (using \code{sbt})}
\label{fig:folders}
\end{figure}
\fi

\begin{figure}
\dirtree{%
.1 project.
.2 src.
.3 main.
.4 scala.
.5 package.
.6 sub-package.
.3 test.
.4 scala.
.5 package.
.2 target.
.2 generated.
}
\caption{Chisel プロジェクトのソースツリー (\code{sbt} 利用)}
\label{fig:folders}
\end{figure}


\ifshoworiginal
Figure~\ref{fig:folders} shows the organization of the source tree of a typical Chisel project.
The root of the project is the project home, which contains \code{build.sbt}.
It may also include a \code{Makefile} for the build process, a README, and a LICENSE file.
Folder \code{src} contains all source code. From there it is split between \code{main},
containing the hardware sources and \code{test} containing testers.
Chisel inherits from Scala, which inherits from Java the organization of source
in \myref{https://en.wikipedia.org/wiki/Java_package}{packages}.
Packages organize your Chisel code into namespaces. Packages can also contain
sub-packages.
The folder \code{target} contains the class files and other generated files.
I recommend to also use a folder for generated Verilog files, which is usually
call \code{generated}.
\fi



\ifshowtransfirst %(自動翻訳)

図〜\ref{fig:folders}は、典型的なChiselプロジェクトのソースツリーの構成を示します。
プロジェクトのルートは\code{build.sbt}を含むプロジェクトの家、です。
また、ビルドプロセスのための\code{Makefile}、README、およびLICENSEファイルを含むことができます。
フォルダ\code{src}は、すべてのソースコードが含まれています。
そこからは、ハードウェアの源と\code{test}含むテスターを含む、\code{main}の間で分割されます。
JavaからScalaのからChisel継承、継承\myref{https://en.wikipedia.org/wiki/Java_package}{packages}ソースの組織。
パッケージには、名前空間にあなたのリグコードを整理します。
パッケージには、サブパッケージを含めることができます。
フォルダ\code{target}は、クラスファイルや他の生成されたファイルが含まれています。
私はまた、通常\code{generated}を呼び出している生成されたVerilogファイル、のフォルダを使用することをお勧めします。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
図 ~\ref{fig:folders} は、典型的なChiselプロジェクトのソースツリーの構成を示します。
プロジェクトのルートはプロジェクトのホームであり、\code{build.sbt}が置かれます。
また、ビルドプロセスのための \code{Makefile} ファイルや、README、LICENSEファイルも配置します。
\code{src}フォルダ には、全てのソースコードが配置されています。
そこから、ハードウェアのソースが含む\code{main}と、テストコードを含む\code{test} に別れます。
ChiselはScalaを継承しており、ScalaはJavaからソースの\myref{https://en.wikipedia.org/wiki/Java_package}{packages}を継承しています。
Package はChiselのコードを名前空間に整理します。PackageにはSub-Packageを含めることもできます。
\code{target}フォルダには、クラスファイルやその他の生成ファイルが格納されています。
また、生成されたVerilogファイルを格納するフォルダは、通常は\code{generated}と呼ばれます.
\fi

\ifshoworiginal
To use the facility of namespaces in Chisel, you need to declare that a class/module
is defined in a package, in this example in \code{mypacket}:
\fi

\ifshowtransfirst %(自動翻訳)
Chiselで名前空間の機能を使用するには、\code{mypacket}で、この例では、クラス/モジュールが Package で定義されていることを宣言する必要があります,
\fi

\ifshowtranssecond %(校正 5/20 mune10)
Chiselの名前空間機能を使用するには、クラス/モジュールがパッケージで定義されていることを宣言する必要があります。この例では\code{mypacket}
\fi

\shortlist{code/packet.txt}

\ifshoworiginal
\noindent Note that in this example we see the import of the \code{chisel3} packet
to use Chisel classes.
\fi

\ifshowtransfirst %(自動翻訳)
この例では、我々は\code{chisel3}パケットのインポートがChiselクラスを使用するように見ていることに注意してください。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
\noindent この例では、Chisel クラスを使用するために \code{chisel3}パケットをインポートしていることに注意してください。
\fi

\ifshoworiginal
To use the module \code{Abc} in a different context (packet name space),
the components of packet \code{mypacket} need to be imported. The underscore
(\_) acts as wildcard, meaning that all classes of \code{mypacket} are imported.
\fi

\ifshowtransfirst %(自動翻訳)
別のコンテキスト（パケット名前空間）でモジュール\code{Abc}を使用するには、パケット\code{mypacket}の必要性のコンポーネントがインポートされます。
アンダースコア（\_）は\code{mypacket}のすべてのクラスがインポートされていることを意味、ワイルドカードとして機能します。
\fi

\ifshowtranssecond %(校正 7/24 mune10)
別のコンテキスト（パケット名前空間）で\code{Abc}モジュールを使用するには、
パケット\code{mypacket}コンポーネントがインポートされる必要があります。
アンダースコア（\_）はワイルドカードとして機能します。
つまり、\code{mypacket}のすべてのクラスがインポートされていることを意味します。
\fi

\shortlist{code/usepacket.txt}

\ifshoworiginal
\noindent It is also possible to not import all types from \code{mypacket},
but use the fully qualified name \code{mypack.Abc} to refer to the module
\code{Abc} in packet \code{mypack}.
\fi

\ifshowtransfirst %(自動翻訳)
それは\code{mypacket}からすべての種類をインポートしますが、パケット\code{mypack}でモジュール\code{Abc}を参照するために、完全修飾名\code{mypack.Abc}を使用しないことも可能です。
\fi

\ifshowtranssecond %(校正 7/24 mune10)
\noindent \code{mypacket}からすべてのタイプをインポートしないことも可能です。
その場合は、完全修飾名\code{mypack.Abc}を使用して、パケット\code{mypack}内の\code{Abc}モジュールを参照します。
\fi

\shortlist{code/usepacket2.txt}

\ifshoworiginal
\noindent It is also possible to import just a single class and create an instance of it:
\fi

\ifshowtransfirst %(自動翻訳)
ちょうど単一のクラスをインポートし、そのインスタンスを作成することも可能です。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
\noindent また、単一のクラスだけをインポートしてインスタンスを作成することも可能です。
\fi

\shortlist{code/usepacket3.txt}

\ifshoworiginal
\subsection{Running sbt}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Running sbt}
\fi
\ifshowtranssecond %(校正)
\subsection{sbt の実行}
\fi

\ifshoworiginal
A Chisel project can be compiled and executed with a simple \code{sbt} command:
\fi

\ifshowtransfirst %(自動翻訳)
Chiselプロジェクトがコンパイルされ、簡単な\code{sbt}コマンドで実行することができます。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
Chiselプロジェクトは、シンプルな\code{sbt}コマンドでコンパイルして実行することができます。
\fi

\begin{verbatim}
$ sbt run
\end{verbatim}

\ifshoworiginal
This command will compile all your Chisel code from the source tree and searches
for classes that contain an \code{object} that includes a \code{main} method, or simpler
that extends \code{App}. If there is more than one such object, all objects are listed and
one can be selected.
You can also directly specify the object that shall be executed as a parameter to \code{sbt}:
\fi

\ifshowtransfirst %(自動翻訳)
このコマンドは、\code{App}を拡張\code{main}方法、または単純に含ま\code{object}を含むクラスのソースツリーや検索からすべてのChiselコードをコンパイルします。
以上のようなオブジェクトが存在する場合、すべてのオブジェクトがリストされ、1つを選択することができます。
あなたはまた、直接\code{sbt}へのパラメータとして実行されなければならないオブジェクトを指定することができます。
\fi

\ifshowtranssecond %(校正 7/24 mune10)
このコマンドは、ソースツリー内のすべてのChiselコードをコンパイルするとともに、
\code{main}メソッドを含む\code{object}を検索したり、単純に\code{App}を拡張したりします。
もし複数のオブジェクトが存在する場合、すべてのオブジェクトがリストされ、その中から1つを選択することができます。
\code{sbt}へのパラメータとして、実行するオブジェクトを直接指定することもできます。
\fi

\begin{verbatim}
$ sbt "runMain mypacket.MyObject"
\end{verbatim}

\ifshoworiginal
Per default \code{sbt} searches only the \code{main} part of the source tree and not
the \code{test} part.\footnote{This is a convention form Java/Scala that the test folder contains
unit tests and not objects with a \codefoot{main}.} However, Chisel testers, as described here,
contain a \code{main}, but shall be placed in the \code{test} part of the source tree.
To execute a \code{main} in the tester tree use following \code{sbt} command:
\fi

\ifshowtransfirst %(自動翻訳)
デフォルト\code{sbt}検索のみソースツリーの\code{main}部分とない部分\code{test}あたり。
\footnote{これは、テストフォルダが単体テストを含有しない\codefoot{main}とオブジェクトことが慣例形態のJava /スカラです。}
ただし、Chiselテスタは、として\code{main}を含む、ここで説明するが、ソースツリーの\code{test}部に配置されなければなりません。
\code{sbt}コマンド以下のテスターツリーの使用中\code{main}を実行するには：
\fi

\ifshowtranssecond %(校正 7/24 mune10)
デフォルト\code{sbt}の検索対象は、ソースツリーの\code{main}部分のみで、\code{test}は含みません。
\footnote{これは、JavaやScalaではテストフォルダが単体テストしか含まず、\codefoot{main}をもつオブジェクトを含まない慣例からきています。}
しかしながら、Chiselのテスタは、ここで説明するように、\code{main}を含みながらも、ソースツリーの\code{test}部に配置されます。
したがって、テスターツリー内の\code{main}を実行するには下記の\code{sbt}コマンドを用います。
\fi

\begin{verbatim}
$ sbt "test:runMain mypacket.MyTester"
\end{verbatim}

\ifshoworiginal
Now that we know the basic structure of a Chisel project and how to compile and run it
with \code{sbt}, we can continue with a simple testing framework.
\fi

\ifshowtransfirst %(自動翻訳)
今、私たちはChiselプロジェクトの基本的な構造を知っているとどのようにコンパイルし\code{sbt}でそれを実行することを、我々は簡単なテストフレームワークを続けることができます。
\fi

\ifshowtranssecond %(校正 7/24 mune10)
以上で、私たちはChiselプロジェクトの基本的な構造と、\code{sbt}を使ってコンパイルと実行する方法について理解しました。
引き続き、簡単なテストフレームワークについて見てみましょう。
\fi

\ifshoworiginal
\subsection{Tool Flow}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Tool Flow}
\fi
\ifshowtranssecond %(校正)
\subsection{ツールの実行フロー (L3373)}
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/flow}
  %\caption{Tool flow of the Chisel ecosystem.}
  \caption{Chiselエコシステムのツールフロー}
  \label{fig:flow}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:flow} shows the tool flow of Chisel. The digital circuit is described in a Chisel class
shown as \code{Hello.scala}. The Scala compiler compiles this class, together with the Chisel and Scala
libraries, and generates the Java class \code{Hello.class} that can be executed by a standard
\myref{https://en.wikipedia.org/wiki/Java_virtual_machine}{Java virtual machine (JVM)}.
Executing this class with a Chisel driver generates the so-called flexible intermediate representation for
RTL (FIRRTL), an intermediate representation of digital circuits. In our example the file is \code{Hello.fir}.
The FIRRTL compiler performs transformations on the circuit.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:flow}は、Chiselのツール・フローを示しています。
デジタル回路は\code{Hello.scala}として示されるChiselのクラスに記載されています。
Scalaのコンパイラは、一緒にChiselとScalaのライブラリと、このクラスをコンパイルし、標準\myref{https://en.wikipedia.org/wiki/Java_virtual_machine}{Java virtual machine (JVM)}で実行できるJavaクラス\code{Hello.class}を生成します。
Chiselドライバに、このクラスを実行すると、RTL（FIRRTL）、デジタル回路の中間表現する、いわゆるフレキシブル中間表現を生成します。
この例ではファイルが\code{Hello.fir}です。
回路上のFIRRTLコンパイラを行う変換。
\fi

\ifshowtranssecond %(校正 7/24 mune10)
図 ~\ref{fig:flow} は、Chiselのツール・フローを示しています。
デジタル回路は\code{Hello.scala}として示されるChiselのクラスで記述されています。
Scalaのコンパイラは、ChiselとScalaのライブラリと一緒にこのクラスをコンパイルし、
標準の\myref{https://en.wikipedia.org/wiki/Java_virtual_machine}{Java virtual machine (JVM)}で実行できるJavaクラス\code{Hello.class}を生成します。
Chiselドライバでこのクラスを実行すると、
FIRRTL (flexible intermediate representation for RTL、デジタル回路の中間表現）を生成します。
この例では、\code{Hello.fir} ファイルになります。
FIRRTLコンパイラがこれを回路(Verilog RTL)に変換します。
\fi

\ifshoworiginal
Treadle is a FIRRTL interpreter to simulate the circuit. Together with the Chisel tester it can be
used to debug and test Chisel circuits. With assertions we can provide test results.
Treadle can also generate waveform files (\code{Hello.vcd}) that can be viewed with
a waveform viewer (e.g., the free viewer GTKWave or Modelsim).
\fi

\ifshowtransfirst %(自動翻訳)
ペダルは、回路をシミュレートするFIRRTLインタプリタです。
一緒に、それはデバッグとテストリグ回路に使用することができテスターChiselと。
アサーションで、私たちは、テスト結果を提供することができます。
ペダルはまた、波形ビューア（Eで表示することができ、波形ファイル（\code{Hello.vcd}）を生成することができます。
グラム。
、無料のビューアGTKWaveまたはModelSimの）。
\fi

\ifshowtranssecond %(校正 7/24 mune10)
FIRRTLインタプリタが回路をシミュレートするエンジンです。
Chiselテスターと一緒にChiselの回路のデバッグとテストが出来ます。
アサーションを用いることでテスト結果を確認できます。
このエンジンは波形ファイル（\code{Hello.vcd}）を生成することができます。
生成された波形は波形ビューアで表示かのうです（無料のビューアであるGTKWaveまたはModelSimなど）
\footnote{訳注：図~\ref{fig:flow} は若干不正確です。VCDの生成はこのFIRRTLのエンジンではなく、生成されたVerilogを元にVerilatorが行います。}
\fi

\ifshoworiginal
One FIRRTL transformation, the Verilog emitter, generates Verilog code for synthesis (\code{Hello.v}).
A circuit synthesize tool (e.g., Intel Quartus, Xilinx Vivado, or an ASIC tool) synthesizes the circuit.
In an FPGA design flow, the tool generates the FPGA bitstream that is used to configure the FPGA,
e.g., \code{Hello.bit}.
\fi

\ifshowtransfirst %(自動翻訳)
一のFIRRTL変換、Verilogのエミッタは、合成（\code{Hello.v}）のためのVerilogコードを生成します。
回路のsynthesizeツール（E。
グラム。
インテルのQuartus、ザイリンクスVivado、またはASICツール）回路を合成します。
FPGA設計フローでは、ツールは、FPGA、Eを構成するために使用されるFPGAビットストリームを生成します。
グラム。
、\code{Hello.bit}。
\fi

\ifshowtranssecond %(校正 7/24 mune10)
FIRRTLでの変換の一つは、Verilog Emitter JVMによる、論理合成用のためのVerilogコード（\code{Hello.v}）の生成です。
論理回路の合成ツール(インテルのQuartus、ザイリンクスVivado、またはASICツール)で回路を合成します。
FPGA設計フローでは、これらのツールはFPGA構成用のビットストリーム \code{Hello.bit} を生成します。
\fi

\ifshoworiginal
\section{Testing with Chisel}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Testing with Chisel}
\fi
\ifshowtranssecond %(校正)
\section{Chisel をつかったテスト (L3469)}
\fi

\index{Testing}

\ifshoworiginal
Tests of hardware designs are usually called \myref{https://www.xilinx.com/support/documentation/sw_manuals/xilinx10/isehelp/ise_c_simulation_test_bench.htm}{test benches}.
The test bench instantiates the design under test (DUT), drives input ports, observes output ports,
and compares them with expected values.
\fi

\ifshowtransfirst %(自動翻訳)
ハードウェア設計のテストは通常​​、\myref{https://www.xilinx.com/support/documentation/sw_manuals/xilinx10/isehelp/ise_c_simulation_test_bench.htm}{test benches}と呼ばれています。
テストベンチは、テスト（DUT）の下で設計をインスタンスドライブ入力ポート、出力ポートを観察し、そして期待値と比較します。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
ハードウェア設計のテストは \myref{https://www.xilinx.com/support/documentation/sw_manuals/xilinx10/isehelp/ise_c_simulation_test_bench.htm}{test benches、テストベンチ}と呼ばれます。
テストベンチは、テスト対象となる design under test（DUT）と呼ばれる部分をインスタンス化して、入力ポートに値をセットして、出力ポートに出てくる値と期待値とを比較します。
\fi

\subsection{PeekPokeTester}

\ifshoworiginal
Chisel provides test benches in the form of a \code{PeekPokeTester}.
One strength of Chisel is that it can use the full power of Scala to write those
test benches. One can, for example, code the expected functionality of the hardware
in a software simulator and compare the simulation of the hardware with the
software simulation. This method is very efficient when testing an implementation
of a processor~\cite{lipsi:arcs2018}.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselは\code{PeekPokeTester}の形でテストベンチを提供します。
Chiselの一つ強みは、これらのテストベンチを書くためのScalaのフルパワーを使用することができるということです。
一つは、例えば、コードソフトウェアシミュレータにおけるハードウェアの予想機能とは、ソフトウェアシミュレーションとハードウェアのシミュレーションを比較することができます。
プロセッサ〜\cite{lipsi:arcs2018}の実装をテストするときに、この方法は非常に効率的です。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
Chiselでは\code{PeekPokeTester}の形でテストベンチを提供しています。
Chiselの強みに一つは、Scala言語のパワーをフルに活用してテストベンチを記述できることです。
例えば、ハードウェアの振る舞いをシュミレートするソフトウェアを用いて、ハードウェアのシュミレーション（訳注：テスト実行のこと）と動作を比較する事ができます。
この方法で、プロセッサの実装のテストを効率的に実施できます~\cite{lipsi:arcs2018}。
\fi

\ifshoworiginal
To use the \code{PeekPokeTester}, following packages need to be imported:
\fi

\code{PeekPokeTester}を使用するには、以下のパッケージをインポートする必要があります。

\shortlist{code/test_import.txt}

\ifshoworiginal
\noindent Testing a circuit contains (at least) three components: (1) the device under test (often
called DUT), (2) the testing logic, also called test bench, and (3) the tester objects
that contains the \code{main} function to start the testing.
\fi

\ifshowtransfirst %(自動翻訳)
（1）開始に\code{main}関数を含む被試験デバイス（多くの場合、DUTと呼ばれる）、（2）テスト論理とも呼ばれるテストベンチ、および（3）テスタオブジェクト：テスト回路は、（少なくとも）3つのコンポーネントが含まれていますテスト。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\noindent 回路のテストには、最低次の３つのコンポーネントが含まれます：
(1) テスト対象、device under test（よくDUTと略される）
(2) テストベンチと呼ばれるテスト回路
(3) テストを駆動する\code{main} 関数を含むテスターオブジェクト（訳注：これはChisel特有）
\fi

\ifshoworiginal
The following code shows our simple design under test. It contains two input
ports and one output port, all with a 2-bit width. The circuit does a bit-wise AND
to it returns on the output:
\fi

\ifshowtransfirst %(自動翻訳)
次のコードは、テスト中の私たちのシンプルな設計を示しています。
これは、すべての2ビット幅で、2つの入力ポートと1つの出力ポートを含んでいます。
回路は、ビット単位行い、それに出力を返します。
\fi

\ifshowtranssecond %(校正  6/20  mune10)
次のコードは、テスト対象となるシンプルなデザインを示しています。
このコードには2つの入力ポートと 1 つの出力ポートがあり、すべて 2 ビット幅です。
この回路は、ビット単位のANDを使って、出力を返します。
\fi

\shortlist{code/test_dut.txt}

\ifshoworiginal
\noindent The test bench for this DUT extends \code{PeekPokeTester} and has
the DUT as a parameter for the constructor:
\fi

\ifshowtransfirst %(自動翻訳)
このDUTのためのテストベンチは\code{PeekPokeTester}を拡張し、コンストラクタのパラメータとしてDUTを有します。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\noindent このDUTのためのテストベンチは\code{PeekPokeTester}を拡張（Extend）し、コンストラクタに渡すパラメーターをDUTに持ちます。
\fi

\shortlist{code/test_bench_simple.txt}


\ifshoworiginal
\noindent A \code{PeekPokeTester} can set input values with \code{poke()} and
read back output values with \code{peek()}. The tester advances the simulation by one
step (= one clock cycle) with \code{step(1)}.
We can print the values of the outputs with \code{println()}.
\fi

\ifshowtransfirst %(自動翻訳)
A \code{PeekPokeTester}は\code{poke()}と入力値を設定し、\code{peek()}と出力値をリードバックすることができます。
テスタは\code{step(1)}と一歩（= 1クロックサイクル）でシミュレーションを進めます。
私たちは、\code{println()}と出力の値を印刷することができます。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\noindent \code{PeekPokeTester}は\code{poke()}で入力値を設定し、\code{peek()}で出力値を読み出すことが出来ます。
テスターは\code{step(1)}でシュミレーションを１ステップ（= 1クロックサイクル）進めます。
また、\code{println()}をつかって、出力の値を表示させることができます。
\fi

\ifshoworiginal
The test is created and run with the following tester main:
\fi

\ifshowtransfirst %(自動翻訳)
テストは、メイン以下のテスターを使用して作成して実行されます。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
以下のテスターメイン(main)でテストを作成して実行します。
\fi

\shortlist{code/test_main_simple.txt}

\ifshoworiginal
\noindent When you run the test, you will see the results printed to the terminal
(besides other information):
\fi

\ifshowtransfirst %(自動翻訳)
あなたがテストを実行するときは、（他の情報に加えて）端末に印刷された結果が表示されます。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
\noindent テストを実行すると、結果が（他の情報と共に）端末に出力されます。
\fi

\begin{verbatim}
[info] [0.004] SEED 1544207645120
[info] [0.008] Result is: 0
[info] [0.009] Result is: 2
test DeviceUnderTest Success: 0 tests passed in 7 cycles
taking 0.021820 seconds
[info] [0.010] RAN 2 CYCLES PASSED
\end{verbatim}

\ifshoworiginal
\noindent We see that 0 AND 1 results in 0; 3 AND 2 results in 2.
Besides manually inspecting printouts, which is an excellent starting point, we can also
express our expectations in the test bench itself with \code{expect()},
having the output port and the expected value as parameters.
The following example shows testing with \code{expect()}:
\fi

\ifshowtransfirst %(自動翻訳)
我々は0で、0と1の結果を参照してください。 2の3と2の結果。
加えて手動で優れた出発点である印刷物を、検査、我々はまた、パラメータとして、出力ポートと期待値を有する、\code{expect()}とテストベンチ自体に我々の期待を表現することができます。
\code{expect()}でテスト次の例が示します：
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\noindent 0 AND 1の結果は 0、3　AND 2の結果は2 となります。
プリントアウトの目視確認は、最初としては良いのですが、出力ポートの値の期待値をパラメータとして与えることで、\code{expect()}を使い、テストベンチ自体で期待値をチェックさせることが出来ます。
次の例で\code{expect()}を使ったテストを示します。
\fi

\shortlist{code/test_bench.txt}

\ifshoworiginal
\noindent Executing this test does not print out any values from the hardware,
but that all tests passed as all expect values are correct.
\fi

\ifshowtransfirst %(自動翻訳)
このテストを実行すると、ハードウェアからの任意の値をプリントアウトしますが、すべてとして渡されたすべてのテストは、値が正しいことを期待していません。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
\noindent このテストを実行しても、ハードウェアから値が表示されることはありませんが、すべての期待値が正しく、結果としてすべてのテストが合格したことになります。
\fi

\begin{verbatim}
[info] [0.001] SEED 1544208437832
test DeviceUnderTest Success: 2 tests passed in 7 cycles
taking 0.018000 seconds
[info] [0.009] RAN 2 CYCLES PASSED
\end{verbatim}

\ifshoworiginal
\noindent A failed test, when either the DUT or the test bench contains an error,
produces an error message describing the difference between the expected and actual
value. In the following, we changed the test bench to expect a 4, which is an error:
\fi

\ifshowtransfirst %(自動翻訳)
DUTまたはテストベンチのいずれかがエラーを含む失敗したテストは、期待と実際の値との差を説明するエラーメッセージを生成します。
以下では、エラーである4を、期待するテストベンチを変更しました：
\fi

\ifshowtranssecond %(校正 5/20 mune10)
\noindent DUT またはテストベンチのいずれかにエラーが含まれている場合、テストに失敗すると、期待値と実際の値の差を記述したエラーメッセージが表示されます。
以下では、テストベンチでエラーとなるように、期待値の４を変更しました。
\fi

\begin{verbatim}
[info] [0.002] SEED 1544208642263
[info] [0.011] EXPECT AT 2   io_out got 0 expected 4 FAIL
test DeviceUnderTest Success: 1 tests passed in 7 cycles
taking 0.022101 seconds
[info] [0.012] RAN 2 CYCLES FAILED FIRST AT CYCLE 2
\end{verbatim}

\ifshoworiginal
In this section, we described the basic testing facility with Chisel for simple tests.
However, in Chisel, the full power of Scala is available to write testers.
\todo{Have a link to the not yet written section for: We will show these possibilities later.}
\fi

\ifshowtransfirst %(自動翻訳)
このセクションでは、我々は簡単なテストのためにChiselとの基本的なテスト機能を説明しました。
しかし、Chiselでは、スカラ座のフルパワーは、ライトテスターに​​提供されています。
\fi
\ifshowtranssecond %(校正 5/20 mune10)
ここでは、Chiselを使った簡単なテストのための基本的なテスト機能について説明しました。
しかし、Chiselでは、フルパワーのScalaでテストを記述することができます。
\todo{Have a link to the not yet written section for: We will show these possibilities later.}
\fi

\ifshoworiginal
\subsection{Using ScalaTest}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Using ScalaTest}
\fi
\ifshowtranssecond %(校正)
\subsection{ScalaTest の利用}
\fi

\index{ScalaTest}

\ifshoworiginal
\myref{http://www.scalatest.org/}{ScalaTest} is a testing tool for Scala (and Java),
which we can use to run Chisel testers.
To use it, include the library in your \code{build.sbt} with the following line:
\fi

\ifshowtransfirst %(自動翻訳)
\myref{http://www.scalatest.org/}{ScalaTest}たちはChiselテスターを実行するために使用することができますスカラ座（とJava）のためのテストツールです。
これを使用するには、次の行を使用して\code{build.sbt}でライブラリが含まれています。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\myref{http://www.scalatest.org/}{ScalaTest}はScala（とJava）のテストツールですが、Chiselテスターの実行にも使えます。
使い方は、\code{build.sbt}の中で下記のようにしてライブラリを追加します。
\fi

\begin{chisel}
libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.5" % "test"
\end{chisel}

\ifshoworiginal
\noindent Tests are usually found in \code{src/test/scala} and can be run with:
\fi

\ifshowtransfirst %(自動翻訳)
テストは通常​​\code{src/test/scala}中に見出され、で実行することができます：
\fi
\ifshowtranssecond %(校正 5/20 mune10)
\noindent テストは通常​\code{src/test/scala} 　の中に置かれており、以下で実行することができます：
\fi

\begin{verbatim}
$ sbt test
\end{verbatim}

\ifshoworiginal
\noindent A minimal test (a testing hello world) to test a Scala Integer
addition:
\fi

\ifshowtransfirst %(自動翻訳)
スカラ整数の加算をテストするための最小限のテスト（テストハローワールド）：
\fi

\ifshowtranssecond %(校正 5/20 mune10)
\noindent Scalaの整数足し算をテストするためのミニマムテスト（テスト用のハローワールド）。
\fi

\shortlist{code/scalatest_hello_world.txt}

\ifshoworiginal
\noindent Although Chisel testing is more heavyweight than unit testing of Scala programs,
we can wrap a Chisel test into a ScalaTest class. For the \code{Tester} shown
before this is:
\fi

\ifshowtransfirst %(自動翻訳)
リグテストはScalaのプログラムのユニットテストよりもヘビー級ではあるが、我々はScalaTestクラスにChiselテストをラップすることができます。
前に示した\code{Tester}については、これは次のとおりです。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\noindent Chiselのテストは、Scalaプログラムのユニットテストよりも重くなりますが。
ChiselテストをScalaTestクラスでラップすることができます。
前に示した\code{Tester}は、次のようになります：
\fi

\shortlist{code/scalatest_simple.txt}

\ifshoworiginal
The main benefit of this exercise is to be able to run all tests with a simple
\code{sbt test} (instead of a running \code{main}). You can run just a single
test with \code{sbt}, as follows:
\fi

\ifshowtransfirst %(自動翻訳)
この演習の主な利点は、（代わりに実行されている\code{main}の）簡単な\code{sbt test}ですべてのテストを実行できるようにすることです。
次のようにあなたは、\code{sbt}で1つだけのテストを実行できます。
\fi

\ifshowtranssecond %(校正 7/24 mune10)
この演習の主な利点は、（代わりに実行されている\code{main}の）簡単な\code{sbt test}ですべてのテストを実行できるようにすることです。
次のようにあなたは、\code{sbt}で1つだけのテストを実行できます。
\fi

\begin{verbatim}
$ sbt "testOnly SimpleSpec"
\end{verbatim}

\ifshoworiginal
\subsection{Waveforms}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Waveforms}
\fi
\ifshowtranssecond %(校正)
\subsection{波形表示}
\fi

\ifshoworiginal
Testers, as described above, work well for small designs and for
\myref{https://en.wikipedia.org/wiki/Unit_testing}{unit testing}, as it is common in
software development. A collection of unit tests can also serve for
\myref{https://en.wikipedia.org/wiki/Regression_testing}{regression testing}.
\fi

\ifshowtransfirst %(自動翻訳)
テスター、それはソフトウェア開発における一般的であるように、小さなデザインのためと\myref{https://en.wikipedia.org/wiki/Unit_testing}{unit testing}のために働く、上記のように。
ユニットテストのコレクションも\myref{https://en.wikipedia.org/wiki/Regression_testing}{regression testing}のために役立つことができます
\fi

\ifshowtranssecond %(校正 8/10 mune10)
以上で紹介したテスターは、ソフトウェアの開発と同様に、小さなデザインや、\myref{https://en.wikipedia.org/wiki/Unit_testing}{unit testing、ユニットテスト}に対してうまく働きます。
一連のユニットテストは\myref{https://en.wikipedia.org/wiki/Regression_testing}{regression testing、回帰テスト}にも役立ちます。
\fi

\ifshoworiginal
However, for debugging more complex designs, one would like to investigate
several signals at once. A classic approach to debug digital designs is displaying
the signals in a waveform. In a waveform the signals are displayed over time.
\fi

\ifshowtransfirst %(自動翻訳)
しかし、より複雑な設計をデバッグするために、人は一度に複数の信号を調査したいと思います。
デバッグデジタル設計の古典的なアプローチは、波形の信号を表示しています。
波形信号は、時間の経過とともに表示されます。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
しかし、より複雑なデザインをデバッグする場合、複数の信号を一度に調査したい場合があります。
デジタル・デザインをデバッグするための古典的なアプローチは、信号を波形で表示することです。波形では、信号は時間の経過とともに表示されます。
\fi

\ifshoworiginal
Chisel testers can generate a waveform that includes all registers and all IO signals.
In the following examples we show waveform testers for the \code{DeviceUnderTest}
from the former example (the 2-bit AND function). For the following example we
import following classes:
\fi

\ifshowtransfirst %(自動翻訳)
Chiselテスターは、すべてのレジスタと、すべてのIO信号を含む波形を生成することができます。
以下の例では、前者の例から\code{DeviceUnderTest}ための波形テスター（2ビットのAND関数）を示します。
次の例のために我々は次のクラスをインポートします。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
Chisel テスタは、すべてのレジスタとすべてのIO信号を含む波形を生成することができます。
以下の例では、前の例（２ビットのＡＮＤ関数）の\code{DeviceUnderTest}の波形テスタを示します。
この例では、以下のクラスをインポートしています。
\fi

\shortlist{code/test_import_wave.txt}

\ifshoworiginal
\noindent We start with a simple tester that pokes values to the inputs and advances
the clock with \code{step}. We do not read any output or compare it with \code{expect}.
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、入力にポーク値という単純なテスターで始まり、\code{step}で時計を進めます。
私たちは、任意の出力を読んだり\code{expect}と比較しないでください。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
\noindent まず、入力に値を入れて、\code{step}でクロックを進めるだけの簡単なテスタから始めます。
出力を読み込んだり、比較したりしません。
\fi

\shortlist{code/test_bench_wave.txt}

\ifshoworiginal
\noindent Instead we call \code{Driver.execute} with parameters to generate waveform
files (.vcd files).
\fi

\ifshowtransfirst %(自動翻訳)
代わりに、私たちは（波形ファイルを生成するためのパラメータで\code{Driver.execute}を呼び出します。
VCDファイル）。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
\noindent その代わりに、パラメータを指定して、波形ファイル(.vcdファイル)を生成するために、\code{Driver.execute}を呼び出します。
\fi

\shortlist{code/scalatest_wave.txt}

\ifshoworiginal
You can view the waveform with the free viewer GTKWave or with ModelSim.
Start GTKWave and select \emph{File -- Open New Window} and navigate to the
folder where the Chisel tester put the \code{.vcd} file. Per default the generated files
are in \code{test\_run\_dir} then the name of the tester appended with a number.
Within this folder you should be able to find \code{DeviceUnderTest.vcd}.
You can select the signals from the left side and drag them into the main window.
If you want to save a configuration of signals you can do so with \emph{File -- Write Save File}
and load it later with \emph{File -- Read Save File}.
\fi

\ifshowtransfirst %(自動翻訳)
あなたは、無料のビューアGTKWaveまたはModelSimで波形を表示することができます。
スタートGTKWaveとChiselテスターが\code{.vcd}ファイルを置くフォルダに\emph{File -- Open New Window}とナビゲートを選択します。
デフォルトでは生成されたファイルは、\code{test\_run\_dir}に番号を付加し、テスターの名前です。
このフォルダ内では、\code{DeviceUnderTest.vcd}を見つけることができるはずです。
あなたは左サイドからの信号を選択し、メインウィンドウにドラッグすることができます。
あなたは信号の設定を保存したい場合は、\emph{File -- Write Save File}とそうと\emph{File -- Read Save File}と、後でそれを読み込むことができます。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
波形の表示には、フリーのGTKWaveや（商用の）ModelSimが使えます。
GTKWaveを起動し、\emph{File -- Open New Window}を選択して、Chiselテスターが生成した\code{.vcd}ファイルを含むフォルダーを探します。
標準では、生成されたファイルは、\code{test\_run\_dir}にテスターの名前に番号を付加した形で保存されています。
そのフォルダに、\code{DeviceUnderTest.vcd}ファイルがあるはずです。
左側から信号名を選び、メインウインドウにペーストします。
設定を保存したい場合は\emph{File -- Write Save File}で保存します、読む出す際は\emph{File -- Read Save File}で読み出します。
\fi

\ifshoworiginal
Explicitly enumerating all possible input values does not scale. Therefore, we will use
some Scala code to drive the DUT. Following tester enumerates all possible values for
the 2 2-bit input signals.
\fi

\ifshowtransfirst %(自動翻訳)
明示的にスケールしないすべての可能な入力値を列挙。
したがって、我々は、DUTを駆動するために、いくつかのScalaのコードを使用します。
以下テスタは2 2ビット入力信号のためのすべての可能な値を列挙する。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
すべての可能な入力値を明示的に列挙することはスケールしません。
そのため、DUTを駆動するためにいくつかのScalaコードを使用します。
以下のテスターは、2つの2ビットの入力信号に対して可能なすべての値を列挙します。
\fi

\shortlist{code/test_bench_wave_cnt.txt}

\ifshoworiginal
\noindent We add a ScalaTest spec for this new tester
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、この新しいテスターのためのScalaTest仕様を追加します
\fi

\ifshowtranssecond %(校正 6/20 mune10)
\noindent この新しいテスターのために ScalaTest の仕様を追加します。
\fi

\shortlist{code/scalatest_wave_cnt.txt}

\ifshoworiginal
\noindent and execute it with
\fi

\ifshowtransfirst %(自動翻訳)
とでそれを実行します
\fi
\ifshowtranssecond %(校正 5/20 mune10)
\noindent 以下で実行します。
\fi

\begin{verbatim}
sbt "testOnly WaveformCounterSpec"
\end{verbatim}

\ifshoworiginal
\subsection{printf Debugging}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{printf Debugging}
\fi
\ifshowtranssecond %(校正)
\subsection{printf デバッグ}
\fi

\ifshoworiginal
Another form of debugging is the so-called ``printf debugging''. This form comes from
simply putting \code{printf} statements in C code to print variables of interest during
the execution of the program. This printf debugging is also available during testing
of Chisel circuits. The printing happens at the rising edge of the clock.
A \code{printf} statement can be inserted just anywhere in the module definition,
as shown in the printf debugging version of the DUT.
\fi


\ifshowtransfirst %(自動翻訳)
デバッグの別の形態は、いわゆる `` printfのデバッグ「」です。
この形式は、単にプログラムの実行中に関心の変数を印刷するCコードで\code{printf}文を入れてから来ています。
このprintfのデバッグはChisel回路のテスト中にも使用可能です。
印刷は、クロックの立ち上がりエッジで発生します。
DUTのバージョンをデバッグのprintfに示すように\code{printf}文は、どこでもモジュール定義の中に挿入することができます。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
別のデバッグの方法は、いわゆる``printf debugging''です。
この方法は、単にプログラムの実行中に気になる変数を表示するように、Cのコードに \code{printf}文を仕込みます。
同じことが、Chiselの回路のテストでも出来ます。
出力はクロックの立ち上がりに実行されます。
\code{printf}文は、モジュール定義の中のどこにでも仕込むことができます。
printf デバッグ版のDUTは以下のようになります。
\fi

\shortlist{code/test_dut_printf.txt}

\ifshoworiginal
\noindent When testing this module with the counter based tester, which iterates over all possible
values, we get following output, verifying that the AND function is correct:
\fi

\ifshowtransfirst %(自動翻訳)
すべての可能な値に対して反復カウンタベースのテスター、とこのモジュールをテストするとき、私たちは、AND関数が正しいことを確認し、次のような出力が得られます。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
\noindent すべての可能な値を繰り返し処理するカウンタベースのテスターを使ってこのモジュールをテストすると、以下のような出力が得られます。AND関数が正しいことが確認できます。
\fi

\begin{verbatim}
Circuit state created
[info] [0.001] SEED 1579707298694
dut: 0 0 0
dut: 0 1 0
dut: 0 2 0
dut: 0 3 0
dut: 1 0 0
dut: 1 1 1
dut: 1 2 0
dut: 1 3 1
dut: 2 0 0
dut: 2 1 0
dut: 2 2 2
dut: 2 3 2
dut: 3 0 0
dut: 3 1 1
dut: 3 2 2
dut: 3 3 3
test DeviceUnderTestPrintf Success: 0 tests passed in 21 cycles
  taking 0.036380 seconds
[info] [0.024] RAN 16 CYCLES PASSED
\end{verbatim}

\ifshoworiginal
Chisel printf supports
\myref{https://github.com/freechipsproject/chisel3/wiki/Printing-in-Chisel}{C and Scala style formatting}.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselのprintfは\myref{https://github.com/freechipsproject/chisel3/wiki/Printing-in-Chisel}{C and Scala style formatting}をサポートしています。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
Chiselのprintfは\myref{https://github.com/freechipsproject/chisel3/wiki/Printing-in-Chisel}{C and Scala style formatting}をサポートしています。
\fi

\ifshoworiginal
\section{Exercises}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Exercises}
\fi
\ifshowtranssecond %(校正)
\section{演習}
\fi

\ifshoworiginal
For this exercise, we will revisit the blinking LED from
\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}
and explore Chisel testing. \todo{Also use the ALU example.}
\fi

\ifshowtransfirst %(自動翻訳)
この演習では、我々は
\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}
から点滅LEDを再訪し、リグのテストを検討します。
%\また、ALUの例を使用し、{TODO。｝
\fi

\ifshowtranssecond %(校正 8/10 mune10)
この演習では、\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}のLEDGER点滅回路を使い、Chiselのテストを試します。
%\また、ALUの例を使用し、{TODO。｝
\fi

\ifshoworiginal
\subsection{A Minimal Project}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{A Minimal Project}
\fi
\ifshowtranssecond %(校正)
\subsection{最小のプロジェクト}
\fi

\ifshoworiginal
First, let us find out what a minimal Chisel project is. Explore the files in the
\myref{https://github.com/schoeberl/chisel-examples/tree/master/hello-world}{Hello World}
example.
The \code{Hello.scala} is the single hardware source file.
It contains the hardware description of the blinking LED (\code{class Hello})
and an \code{App} that generates the Verilog code.
\fi

\ifshowtransfirst %(自動翻訳)
まず、私たちは最小限のChiselプロジェクトが何であるかを見つけるてみましょう。
\myref{https://github.com/schoeberl/chisel-examples/tree/master/hello-world}{Hello World}の例でファイルを探ります。
\code{Hello.scala}は、単一のハードウェアのソースファイルです。
これは、点滅LED（\code{class Hello}）およびVerilogコードを生成\code{App}のハードウェア記述を含みます。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
まず、最小限のChiselプロジェクトについて見てみます。
\myref{https://github.com/schoeberl/chisel-examples/tree/master/hello-world}{Hello World}のファイルを見てみましょう。
\code{Hello.scala}は、唯一のハードウェアのソースファイルです。
これには点滅LEDのハードウェア記述（\code{class Hello}）と、Verilogコードを生成の\code{App}が含まれます。
\fi

\ifshoworiginal
Each file starts with the import of Chisel and related packages:
\fi

\ifshowtransfirst %(自動翻訳)
各ファイルはChiselと関連パッケージのインポートを開始します。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
各ファイルは、Chiselと関連パッケージのインポートから始まります。
\fi

\shortlist{code/import.txt}

\ifshoworiginal
\noindent Then follows the hardware description, as shown in Listing~\ref{lst:chisel:hello}.
To generate the Verilog description, we need an application. A Scala object that \code{extends App}
is an application that implicitly generates the main function where the application starts.
The only action of this application is to create a new \code{HelloWorld} object and pass it
to the Chisel driver \code{execute} function. The first argument is an array of Strings,
where build options can be set (e.g., the output folder). The following code will
generate the Verilog file \code{Hello.v}.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:chisel:hello}に示すように、ハードウェア記述に従っています。
Verilogの記述を生成するために、我々はアプリケーションが必要です。
\code{extends App}が暗黙的アプリケーションが起動main関数を生成するアプリケーションであることをA Scalaのオブジェクト。
このアプリケーションの唯一のアクションは、新しい\code{HelloWorld}オブジェクトを作成し、それがChiselドライバ\code{execute}関数に渡すことです。
最初の引数は、ビルドオプションが（Eを設定することができます文字列の配列です。
グラム。
、出力フォルダ）。
次のコードは、Verilogファイル\code{Hello.v}を生成します。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\noindent リストの ~\ref{lst:chisel:hello}にあるハードウェア記述から始めます。
Verilogコードを生成するためにはアプリケーションが必要です。
\code{extends App} が アプリケーションが起動時に暗黙的に main 関数を生成する Scalaのオブジェクトです。
このアプリケーションの唯一のしごとは、新しい \code{HelloWorld} オブジェクトを作成して、Chiselドライバの\code{execute}関数に渡すことです。
最初の引数は、文字列の配列でビルドオプションがセットされます（例、出力フォルダ）。
以下のコードはVerilogファイル \code{Hello.v} を生成します。
\fi

\shortlist{code/generate.txt}

\ifshoworiginal
\noindent Run the generation of the example manually with
\fi

\ifshowtransfirst %(自動翻訳)
手動での例の生成を実行します
\fi

\ifshowtranssecond %(校正 5/20 mune10)
\noindent 下記の実行で、手動でサンプル生成をします。
\fi

\begin{chisel}
$ sbt "runMain Hello"
\end{chisel}

\ifshoworiginal
and explore the generated \code{Hello.v} with an editor. The generated Verilog code may not be
very readable, but we can find out some details. The file starts with a module \code{Hello},
which is the same name as our Chisel module. We can identify our LED port as
\code{output io\_led}. Pin names are the Chisel names with a prepended \code{io\_}.
Besides our LED pin, the module also contains \code{clock} and \code{reset} input signals.
Those two signals are added automatically by Chisel.
\fi

\ifshowtransfirst %(自動翻訳)
そしてエディタで生成された\code{Hello.v}を探ります。
生成されたVerilogコードは非常に読みやすいではないかもしれないが、我々はいくつかの詳細を見つけることができます。
ファイルには、私たちのChiselモジュールと同じ名前であるモジュール\code{Hello}、で始まります。
私たちは、\code{output io\_led}として、当社のLEDポートを識別することができます。
ピン名は、先頭に付加\code{io\_}とChisel名です。
我々のLEDピンに加えて、モジュールは、\code{clock}と\code{reset}入力信号を含みます。
これら二つの信号は、Chiselによって自動的に追加されます。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
次に、生成された\code{Hello.v}ファイルをエディタで見てみましょう。
生成されたVerilogコードはあまり読みやすいではありません。
ファイルはChiselモジュールと同じ名前の \code{Hello} モジュールで始まります。
LEDポートは\code{output io\_led}として割り当てられています。
ピンの名前はChiselでの名前にプレフィックスとして \code{io\_} が付きます。
モジュールには、LEDピンの他に、\code{clock}と\code{reset} の入力信号が含まれます。
これら二つの信号は、Chiselによって自動的に追加されます。
\fi

\ifshoworiginal
Furthermore, we can identify the definition of our two registers \code{cntReg} and \code{blkReg}.
We may also find the reset and update of those registers at the end of the module definition.
Note, that Chisel generates a synchronous reset.
\fi

\ifshowtransfirst %(自動翻訳)
さらに、我々は我々の2つのレジスタ\code{cntReg}と\code{blkReg}の定義を識別することができます。
また、モジュール定義の最後でこれらのレジスタのリセットや更新を見つけることができます。
Chiselは、同期リセットを生成し、注意してください。
\fi

\ifshowtranssecond %(校正 7/24 mune10)
さらに、２つのレジスタ\code{cntReg} と \code{blkReg}、の定義を確認することができます。
また、モジュールの定義の最後に、これらのレジスタのリセットとアップデートを見つけることができるかもしれません。
Chiselは、同期リセットを生成することに注意してください。
\fi

\ifshoworiginal
For \code{sbt} to be able to fetch the correct Scala compiler and the Chisel library,
we need a \code{build.sbt}:
\fi

\ifshowtransfirst %(自動翻訳)
\code{sbt}が正しいScalaのコンパイラおよびChiselライブラリを取得できるようにするために、我々は\code{build.sbt}が必要になります。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\code{sbt}が正しいScalaのコンパイラやChiselライブラリを取得するためには、\code{build.sbt} ファイルが必要です。
\fi

\begin{chisel}
scalaVersion := "2.11.7"

resolvers ++= Seq(
  Resolver.sonatypeRepo("snapshots"),
  Resolver.sonatypeRepo("releases")
)

libraryDependencies += "edu.berkeley.cs" %% "chisel3" % "3.2.2"
libraryDependencies += "edu.berkeley.cs" %% "chisel-iotesters" % "1.3.2"

\end{chisel}

\ifshoworiginal
\noindent Note that in this example, we have a concrete Chisel version number to avoid checking on
each run for a new version (which will fail if we are not connected to the Internet,
e.g., when doing hardware design during a flight).
Change the \code{build.sbt} configuration to use the latest Chisel version by changing the
library dependency to
\fi

\ifshowtransfirst %(自動翻訳)
この例では、我々は我々がインターネットに接続されていない場合に失敗します。新バージョン（、Eの各実行にチェックを回避するための具体的なChiselバージョン番号を持っていることに注意してください。
グラム。
、）飛行中のハードウェア設計を行うとき。
にライブラリの依存関係を変更することで、最新のChiselバージョンを使用する\code{build.sbt}の設定を変更します
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\noindent この例で注意してもらいたいのは、具体的なChiselバージョン番号を指定していて、新バージョンのチェック（インターネットに接続されていない場合に失敗、例えば、飛行機で旅行中にハードウェア設計をしている時など）はしない事です。
\code{build.sbt}のライブラリの依存関係の設定を変更すれば、最新のChiselバージョンを使用できます。
\fi

\begin{chisel}
libraryDependencies += "edu.berkeley.cs" %% "chisel3" % "latest.release"
\end{chisel}

\ifshoworiginal
\noindent and rerun the build with \code{sbt}. Is there a newer version of Chisel
available and will it be automatically downloaded?
\fi

\ifshowtransfirst %(自動翻訳)
そして\code{sbt}でビルドを再実行してください。
Chiselの新しいバージョンが利用可能があり、それが自動的にダウンロードされますか？
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\noindent  その後、\code{sbt}でビルドを再実行してください。
もし新しいバージョンのChiselがあれば、自動的にダウンロードされますか？
\fi


\ifshoworiginal
For convenience, the project also contains a \code{Makefile}.
It just contains the \code{sbt} command, so we do not need to remember it and
can generate the Verilog code with:
\fi

\ifshowtransfirst %(自動翻訳)
便宜上、プロジェクトはまた、\code{Makefile}が含まれています。
我々はそれを覚えておく必要はありませんとでVerilogコードを生成することができますので、それはちょうど、\code{sbt}コマンドが含まれています。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
便宜上、プロジェクトには \code{Makefile} も含まれています。
中に \code{sbt}コマンドが含まれており、コマンド名を覚えてなくても Verilog コードを生成することができます
\fi

\begin{chisel}
make
\end{chisel}

\ifshoworiginal
%The project also contains a
%\myref{https://github.com/schoeberl/chisel-examples/blob/master/hello-world/verilog/hello_top.v}{Verilog top level},
%which wires the reset signal to 0.
%This works for our example in an FPGA, as registers usually power up 0.
Besides a \code{README} file, the example project also contains project
files for different FPGA board. E.g., in
\myref{https://github.com/schoeberl/chisel-examples/tree/master/hello-world/quartus/altde2-115}{quartus/altde2-115}
you can find the two project files to define a Quartus project for the DE2-115 board.
The main definitions (source files, device, pin assignments) can be found in a plain text file
\myref{https://github.com/schoeberl/chisel-examples/blob/master/hello-world/quartus/altde2-115/hello.qsf}{hello.qsf}.
Explore the file and find out which pins are connected to which signals.
If you need to adapt the project to a different board, there is where the changes are applied.
If you have Quartus installed, open that project, compile with the green \emph{Play} button,
and then configure the FPGA.
\fi

\ifshowtransfirst %(自動翻訳)
え。
グラム。
、\myref{https://github.com/schoeberl/chisel-examples/tree/master/hello-world/quartus/altde2-115}{quartus/altde2-115}にあなたはDE2-115ボード用のQuartusプロジェクトを定義するために2つのプロジェクトファイルを見つけることができます。
メインの定義（ソースファイル、デバイス、ピンアサイン）は、プレーンテキストファイル\myref{https://github.com/schoeberl/chisel-examples/blob/master/hello-world/quartus/altde2-115/hello.qsf}{hello.qsf}で見つけることができます。
ファイルを探索し、その信号に接続されているピンを見つけます。
あなたが別のボードにプロジェクトを適応させる必要がある場合は変更が適用されている場合、そこにあります。
あなたは、Quartusがインストールされている場合は、そのプロジェクトを開き、緑色の\emph{Play}ボタンでコンパイルして、FPGAを設定します。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\code{README}と一緒に、例題プロジェクトにはいくつかのFPGA向けのプロジェクトファイルが含まれています。
例えば、\myref{https://github.com/schoeberl/chisel-examples/tree/master/hello-world/quartus/altde2-115}{quartus/altde2-115} の中には、
DE2-115ボード用のQuartusプロジェクトファイルが2つ含まれています。
メインの設定は（ソースファイル、デバイス、ピンアサイン）はテキストファイル、\myref{https://github.com/schoeberl/chisel-examples/blob/master/hello-world/quartus/altde2-115/hello.qsf}{hello.qsf}で定義されています。
ファイル見ると、どの信号がどのピンに割り当てられてるかがわかります。
もし、別のボードにプロジェクトを変更させる必要がある場合は、その部分を修正します。
すでにQuartusがインストールされている場合は、そのプロジェクトファイルを開き、緑色の\emph{Play}ボタンでコンパイル、FPGAを構成します。
\fi

\ifshoworiginal
Note that the \emph{Hello World} is a minimal Chisel project.
More realistic projects have their source files organized in packages and contain testers.
The next exercise will explore such a project.
\fi

\ifshowtransfirst %(自動翻訳)
\emph{Hello World}が最小Chiselプロジェクトであることに注意してください。
より現実的なプロジェクトがパッケージに整理そのソースファイルを持っているとテスターが含まれています。
次の演習では、このようなプロジェクトを検討します。
\fi

\ifshowtranssecond %(校正 8/10 mune10)
\emph{Hello World}が最低限なChiselのプロジェクトであることに注意してください。
より現実的なプロジェクトではソースファイルはパッケージに整理され、テスターが含まれます。
次の演習では、このようなプロジェクトについて練習します。
\fi

\ifshoworiginal
\subsection{A Testing Exercise}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{A Testing Exercise}
\fi
\ifshowtranssecond %(校正)
\subsection{テストの演習}
\fi

\ifshoworiginal
In the last chapter's exercise, you have extended the blinking LED example with some input
to build an AND gate and a multiplexer and run this hardware in an FPGA.
We will now use this example and test the functionality with a Chisel tester
to automate testing and also to be independent of an FPGA.
Use your designs from the previous chapter and add a Chisel tester to test the functionality.
Try to enumerate all possible inputs and test the output with \code{except()}.
\fi

\ifshowtransfirst %(自動翻訳)
最後の章の演習では、ANDゲートとマルチプレクサを構築し、FPGAでこのハードウェアを実行するために、いくつかの入力とLEDの点滅の例を高めています。
私たちは今、FPGAに依存しないようにも、この例を使用してテストを自動化するためのChiselテスターで機能をテストしてます。
前章からあなたのデザインを使用し、機能をテストするためにChiselテスターを追加します。
すべての可能な入力を列挙し、\code{except()}で出力をテストしてみてください。
\fi

\ifshowtranssecond %(校正 7/24 mune10)
最後の章の演習では、ANDゲートとマルチプレクサを構築し、FPGAでこのハードウェアを実行するために、いくつかの入力とLEDの点滅の例を高めています。
私たちは今、FPGAに依存しないようにも、この例を使用してテストを自動化するためのChiselテスターで機能をテストしてます。
前章からあなたのデザインを使用し、機能をテストするためにChiselテスターを追加します。
すべての可能な入力を列挙し、\code{except()}で出力をテストしてみてください。
\fi

\ifshoworiginal
Testing within Chisel can speed up the debugging of your design.
However, it is always a good idea to synthesize your design for an FPGA and run tests
with the FPGA. There you can perform a reality check on the size of your design (usually
in LUTs and flip-flops) and your performance of your design in maximum clocking frequency.
As a reference point, a textbook style pipelined RISC processor may consume about 3000
4-bit LUTs and may run around 100~MHz in a low-cost FPGA (Intel Cyclone or
Xilinx Spartan).
\fi

\ifshowtransfirst %(自動翻訳)
Chisel内のテストは、あなたのデザインのデバッグをスピードアップすることができます。
しかし、FPGAのためのデザインを合成し、FPGAでのテストを実行することは常に良い考えです。
そこには、（通常のLUTにし、フリップフロップ）デザインの大きさの真偽の確認を行うことができ、最大クロック周波数でデザインのパフォーマンス。
基準点として、教科書スタイルはRISCプロセッサ3000 4ビットのLUTについて消費することができ、低コストFPGA（インテルサイクロンまたはザイリンクスのSpartan）に約100〜メガヘルツを実行することができるパイプライン。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
Chisel内でテストを行うことで、デザインのデバッグを高速化することができます。
ただし、FPGA用にデザインを合成し、FPGAでテストを実行することは常に良いアイデアです。　 
そこでは、デザインのサイズ（通常はLUTとフリップフロップ）と最大クロック周波数でのデザインのパフォーマンスを、実動作で確認できます。
例えば、 教科書的なパイプラインを構成を持つ RISC プロセッサの場合、約3000個の 4ビットLUT を使います。
低コストなFPGA(Intel Cyclone またはXilinx Spartan)上で100MHz程度で動作します。
\fi

\ifshoworiginal
\chapter{Components}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Components}
\fi
\ifshowtranssecond %(校正)
\chapter{コンポーネント (L4455 mune10 初回校正済)}%(校正  第4章  ===============================================================)
\fi

\index{Component}
\index{Module}
\index{Ports}

\index{コンポーネント}
\index{モジュール}
\index{ポート}

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/components}
  \caption{A design consisting of a hierarchy of components.}
  \label{fig:components}
\end{figure}

\ifshoworiginal
A larger digital design is structured into a set of components, often in
a hierarchical way. Each component has an interface with input and output
wires, usually called ports. These are similar to input and output pins on an integrated circuit (IC).
Components are connected by wiring up the inputs and outputs.
Components may contain subcomponents to build the hierarchy.
The outermost component, which is connected to physical pins
on a chip, is called the top-level component.
\fi

\ifshowtransfirst %(自動翻訳)
大きなデジタル設計は、多くの場合、階層的な方法で、コンポーネントのセットに構成されています。
各成分は、通常、ポートと呼ばれる入出力線とのインターフェースを有しています。
これらは、集積回路（IC）の入力ピンと出力ピンと同様です。
構成要素は、入力と出力を配線で接続されています。
コンポーネントは、階層構造を構築するためにサブコンポーネントが含まれていてもよいです。
チップ上の物理的なピンに接続されている最も外側のコンポーネントは、トップレベル・コンポーネントと呼ばれます。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
大規模なデジタル設計は、多くの場合、階層的な方法でコンポーネントのセットに構造化されています。
各コンポーネントには、通常ポートと呼ばれる入力および出力ワイヤを備えたインターフェイスがあります。
これらは、集積回路 (IC) の入出力ピンに似ています。
コンポーネントは、入力と出力を配線することで接続されます。
コンポーネントは、階層を構築するためにサブコンポーネントを含むことがあります。
チップ上の物理ピンに接続されている一番外側のコンポーネントをトップレベルコンポーネントと呼びます。
\fi

\ifshoworiginal
Figure~\ref{fig:components} shows an example design. Component C has
three input ports and two output ports. The component itself is assembled out
of two subcomponents: B and C, which are connected to the inputs and
outputs of C. One output of A is connected to an input of B.
Component D is at the same hierarchy level as component C and connected
to it.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:components}は、デザイン例を示します。
成分Cは、3つの入力ポートと2つの出力ポートを有します。
B及びC、Cの入力と出力に接続されている：成分自体は、2つのサブコンポーネントのうち組み立てられます
Aの一つの出力はBの入力に接続されています。
成分Dは成分Cと同じ階層レベルであり、それに接続されています。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
図~\ref{fig:components} に設計例を示します。
コンポーネントCは3つの入力ポートと2つの出力ポートを持っています。
コンポーネント自体は、2つのサブコンポーネントから組み立てられています。
BとCは、Cの入力と出力に接続されています。
Aの1つの出力はBの入力に接続されています。
コンポーネントDは、コンポーネントCと同じ階層レベルにあり、Cに接続されています。
\fi

\ifshoworiginal
In this chapter, we will explain how components are described in Chisel and
provide several examples of standard components.
Those standard components serve two purposes: (1) they provide examples
of Chisel code and (2) they provide a library of components ready to be reused
in your design.
\fi

\ifshowtransfirst %(自動翻訳)
この章では、コンポーネントがChiselに記載されており、標準的な構成要素のいくつかの例を提供する方法を説明します。
（1）彼らはChiselコードの例を提供し、（2）彼らはあなたのデザインで再利用する準備ができてコンポーネントのライブラリを提供します。これらの標準コンポーネントは2つの目的を果たします。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
この章では、Chiselでコンポーネントがどのように記述されているかを説明し、標準コンポーネントのいくつかの例を示します。
これらの標準コンポーネントには2つの目的があります。(1) Chiselコードの例を提供すること、(2) 設計で再利用できるコンポーネントのライブラリを提供することです。
\fi

\ifshoworiginal
\section{Components in Chisel are Modules}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Components in Chisel are Modules}
\fi
\ifshowtranssecond %(校正)
\section{Chisel のコンポーネントはモジュール}
\fi

\index{IO interface}

\ifshoworiginal
Hardware components are called modules in Chisel. Each module extends
the class \code{Module} and contains a field \code{io} for the interface.
The interface is defined by a \code{Bundle} that is wrapped into a call to \code{IO()}.
The \code{Bundle} contains fields to represent input and output ports of
the module. The direction is given by wrapping a field into either a call to \code{Input()}
or \code{Output()}. The direction is from the view of the component itself.
\fi

\ifshowtransfirst %(自動翻訳)
ハードウェアコンポーネントは、Chiselで、モジュールと呼ばれています。
各モジュールは、クラス\code{Module}を拡張し、インタフェースのためのフィールド\code{io}が含まれています。
インタフェースは\code{IO()}への呼び出しに包まれ\code{Bundle}によって定義されます。
\code{Bundle}は、モジュールの入力および出力ポートを表すためのフィールドを含んでいます。
方向は\code{Input()}又は\code{Output()}への呼び出しのいずれかにフィールドを巻き付けることによって与えられます。
方向は、コンポーネント自体の観点からのものです。
\fi

\ifshowtranssecond %(校正 9/6 mune10)
ハードウェアコンポーネントは、Chiselで、モジュール(module)と呼ばれています。
各モジュールは、\code{Module}クラスを継承(Extend)ドします。
また、\code{io}フィールドがインタフェースのために含まれます。
\code{IO()}への呼び出しをラップした\code{Bundle}によってインタフェースは定義されます。
\code{Bundle}には、モジュールの入力および出力ポートを表すためのフィールドが含まれます。
信号の方向はフィールドをラップする\code{Input()}又は\code{Output()}で設定します。
信号も方向は、コンポーネントから見たものになります。
\fi

\ifshoworiginal
The following code shows the definition of the two example components A and B from
Figure~\ref{fig:components}:
\fi

\ifshowtransfirst %(自動翻訳)
次のコード示し〜\ref{fig:components}から2つの例示的構成要素A及びBの定義：
\fi

\ifshowtranssecond %(校正 9/6 mune10)
以下のコードでは、図~\ref{fig:components}からコンポーネントAとBの2つの例での定義を示します：
\fi

\shortlist{code/components_ab.txt}

\ifshoworiginal
\noindent Component A has two inputs, named \code{a} and \code{b}, and two
outputs, named \code{x} and \code{y}. For the ports of component B
we chose the names \code{in1}, \code{in2}, and \code{out}.
All ports use an unsigned integer (\code{UInt}) with a bit width of 8.
As this example code is about connecting components and building a
hierarchy, we do not show any implementation within the components.
The implementation of the component is written at the place where
the comments states ``function of X''.
As we have no function associated with those example components,
we used generic port names. For a real design use descriptive
port names, such as \code{data}, \code{valid}, or \code{ready}.
\fi

\ifshowtransfirst %(自動翻訳)
成分Aは\code{x}と\code{y}命名\code{a}と\code{b}という名前の2つの入力、および2つの出力を、持っています。
成分Bのポートの場合、我々は、名前\code{in1}、\code{in2}、及び\code{out}を選びました。
すべてのポートは、8ビット幅の符号なし整数（\code{UInt}）を使用します。
このサンプルコードは、コンポーネントを接続し、階層の構築についてであるように、我々は、コンポーネント内の任意の実装を示していません。
コンポーネントの実装は、コメントが「`Xの`機能」を述べているところで書かれています。
我々は、これらのコンポーネント例に関連した機能を持っていないように、我々は、一般的なポート名を使用していました。
実際の設計では、このような\code{data}、\code{valid}、または\code{ready}などの説明ポート名を使用します。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
\noindent コンポーネントAは、\code{a}と\code{b}という2つの入力と、\code{x}と\code{y}の2つの出力を持ちます。
コンポーネントBのポートには、\code{in1} \code{in2}, と \code{out} という名前を用います。
すべてのポートは、8のビット幅を持つ符号なし整数（\code{UInt}）を使用します。
この例のコードはコンポーネントを接続して階層を構築するものなので、コンポーネント内での実装は示していません。
コンポーネントの実装は、コメントに``function of X'' と書かれているところに書かれます。
これらの例のコンポーネントには関連する関数がないため、一般的なポート名を使用していまが、
実際のデザインでは、\code{data} \code{valid}, や \code{ready} のような意味のあるポート名を使用します。
\fi

\ifshoworiginal
Component C has three input and two output ports. It is built out of
components A and B. We show how A and B are connected to the ports
of C and also the connection between an output port of A and an
input port of B:
\fi

\ifshowtransfirst %(自動翻訳)
成分Cは、三つの入力と2つの出力ポートを有します。
これは、コンポーネントAとBのうちに構築されました
我々は、AとBはCのポートともAの出力ポートとの間の接続とBの入力ポートに接続されている方法を示します。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
コンポーネントCは3つの入力ポートと2つの出力ポートを持っています。
コンポーネントAとBを元に構成されています。
ここでは、AとBがCのポートにどのように接続されているか、また、Aの出力ポートとBの入力ポートの間の接続を示します。
\fi

\shortlist{code/components_c.txt}

\ifshoworiginal
Components are created with \code{new}, e.g., \code{new CompA()}, and need to be wrapped
into a call to \code{Module()}. The reference to that module is stored in a local variable,
in this example \code{val compA = Module(new CompA())}.
\fi

\ifshowtransfirst %(自動翻訳)
コンポーネントは\code{new}、Eを使用して作成されます。
グラム。
、\code{new CompA()}、および\code{Module()}への呼び出しにラップする必要があります。
そのモジュールへの参照は、この例\code{val compA = Module(new CompA())}では、ローカル変数に格納されています。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
コンポーネントは、\code{new}で生成され、例えば、\code{new CompA()}、\code{Module()}への呼び出しにラップされる必要があります。
そのモジュールへの参照は、ローカル変数に格納されます。この例では、\code{val compA = Module(new CompA())}です。
\fi

\ifshoworiginal
With this reference, we can access the IO ports by dereferencing the \code{io} field of the module
and the individual fields of the IO \code{Bundle}.
\fi

\ifshowtransfirst %(自動翻訳)
これを参照すると、我々はモジュールとIO \code{Bundle}の個々のフィールドの\code{io}フィールドを逆参照することによりIOポートにアクセスすることができます。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
この参照により、モジュールの\code{io}フィールドを間接参照 (dereferencing) することで、IOポートと IO \code{Bundle}の個々のフィールドにアクセスすることができます。
\fi

\ifshoworiginal
The simplest component in our design has just an input port, named \code{in}, and
an output port named \code{out}.
\fi

\ifshowtransfirst %(自動翻訳)
私たちのデザインの最も単純な構成要素は、ちょうど\code{in}という名前の入力ポート、および\code{out}という名前の出力ポートを持っています。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
このデザインの中で最も単純なコンポーネントは、入力ポート（\code{in}）と出力ポート（\code{out}）を持っています。
\fi

\shortlist{code/components_d.txt}

\ifshoworiginal
The final missing piece of our example design is the top-level component, which itself
is assembled out of components C and D:
\fi

\ifshowtransfirst %(自動翻訳)
我々のデザイン例の最終的な欠落部分は、それ自体が成分C、Dのうち組み付けられるトップレベルのコンポーネントです。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
この例のデザインの最後の欠けている部分は、トップレベルのコンポーネントです。コンポーネントCとDから組み立てます。
\fi

\shortlist{code/components_top.txt}

\ifshoworiginal
Good component design is similar to the good design of functions or methods in
software design. One of the main questions is how much functionality shall we put into
a component and how large should a component be. The two extremes are tiny
components, such an adder, and huge components, such as a full microprocessor,
\fi

\ifshowtransfirst %(自動翻訳)
グッドコンポーネントの設計、ソフトウェア設計の関数やメソッドの良いデザインに似ています。
主な質問の一つは、我々がコンポーネントに入れなければならず、コンポーネントがどのように大規模である必要がありますどのくらいの機能です。
両極端は、小さな部品、例えば加算器、及びそのような完全なマイクロプロセッサなどの巨大構成要素です、
\fi

\ifshowtranssecond %(校正 6/20 mune10)
優れたコンポーネント設計は、ソフトウェア設計における機能や手法の優れた設計に似ています。
主な問題の一つは、コンポーネントにどれだけの機能を持たせるか、コンポーネントはどれだけ大きくすべきかということです。
両極端なのは、加算器のような小さなコンポーネントと、フルマイクロプロセッサのような巨大なコンポーネントです。
\fi


\ifshoworiginal
Beginners in hardware design often start with tiny components.
The problem is that digital design books use tiny components to show the principles.
But the sizes of the examples (in those books, and also in this book) are small
to fit into a page and to not distract by too many details.
\fi

\ifshowtransfirst %(自動翻訳)
ハードウェア設計の初心者は、多くの場合、小さなコンポーネントで始まります。
問題は、デジタル設計図書は、原則を示すために、小さな部品を使用することです。
しかし、例（それらの本であり、またこの本の中で）のサイズがあまりにも多くの詳細によってページに及びませんそらすに収まるように小さいです。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
ハードウェアデザインの初心者は、小さな部品から始めることが多いです。
問題は、デジタルデザインの本では、原理を示すために小さな部品を使っていることです。
例題のサイズは、（そうした本でも、本書でも）ページに収まるように小さくしてあります。
また、気が散らないように、詳細な設計を省いています。
\fi

\ifshoworiginal
The interface to a component is a little bit verbose (with types, names, directions,
IO construction). As a rule of thumb, I would propose that the core of the component,
the function, should be at least as long as the interface of the component.
\fi

\ifshowtransfirst %(自動翻訳)
コンポーネントへのインタフェースは（タイプ、名前、方向、IO構造を有する）少し冗長です。
経験則として、私は、コンポーネント、関数のコアは、コンポーネントのインターフェースと少なくとも同じ長さでなければならないことを提案します。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
コンポーネントのインターフェイスは、少し冗長です（型、名前、方向性、IOの構築などがあります）。
経験則として、私が提案するのは、コンポーネントのコアである関数は、少なくともコンポーネントのインターフェイスと同じくらいの長さであるべきだということです。
\fi

\ifshoworiginal
For tiny components, such as a counter, Chisel provides a more lightweight
way to describe them as functions that return hardware.
\fi

\ifshowtransfirst %(自動翻訳)
カウンタなどの小さな部品については、Chiselは、そのリターン・ハードウェアの機能としてそれらを記述するために、より軽量な方法を提供します。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
カウンターのような小さなコンポーネントに対して、Chiselでは、ハードウェアを返す関数として、それらをより軽量に表現する方法を提供しています。
\fi

\ifshoworiginal
\section{An Arithmetic Logic Unit}
\fi
\ifshowtransfirst %(自動翻訳)
\section{An Arithmetic Logic Unit}
\fi
\ifshowtranssecond %(校正)
\section{算術論理ユニット}
\fi

\ifshoworiginal
One of the central components for circuits that compute, e.g., a microprocessor, is an
\myref{https://en.wikipedia.org/wiki/Arithmetic_logic_unit}{arithmetic-logic unit},
or ALU for short. Figure~\ref{fig:alu} shows the symbol of an ALU.
\fi

\ifshowtransfirst %(自動翻訳)
そのコンピューティング、電子回路のための中心的要素のひとつ。
グラム。
、マイクロプロセッサは、略し\myref{https://en.wikipedia.org/wiki/Arithmetic_logic_unit}{arithmetic-logic unit}、またはALUです。
図〜\ref{fig:alu}は、ALUのシンボルを示しています。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
マイクロプロセッサなどの演算回路の中心的な構成要素の一つに算術論理演算ユニット \myref{https://en.wikipedia.org/wiki/Arithmetic_logic_unit}{arithmetic-logic unit}（ALU）があります。
図 ~\ref{fig:alu} にALUのシンボルを示します。
\fi

\index{ALU}

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/alu}
  \caption{An arithmetic logic unit, or ALU for short.}
  \label{fig:alu}
\end{figure}

\ifshoworiginal
The ALU has two data inputs, labeled \code{A} and \code{B} in the figure, one function input \code{fn},
and an output, labeled {Y}. The ALU operates on \code{A} and \code{B} and provides the result
at the output. The input \code{fn} selects the operation on \code{A} and \code{B}.
The operations are usually some arithmetic, such as addition and subtraction, and some logical
functions such as and, or, xor. That's why it is called ALU.
\fi

\ifshowtransfirst %(自動翻訳)
ALUは、2つのデータ入力を有し、\code{A}と\code{B}図、一つの機能入力\code{fn}、および標識された出力、{Y}で標識されました。
ALUは\code{A}と\code{B}上で動作し、出力で結果を提供します。
入力\code{fn}は\code{A}と\code{B}の操作を選択します。
操作は、通常、加減算などのいくつかの算術、およびのようないくつかの論理関数AND、OR、XORです。
それはALUと呼ばれている理由です。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
ALU は、図中の\code{A}と\code{B}の 2 つのデータ入力と、1 つの関数入力\code{fn}と \code{Y}の出力を持ちます。
ALU は、\code{A}と\code{B}を演算し、結果を出力します。入力\code{fn}は、\code{A}と\code{B}の演算の種類を選択します。
演算は通常、足し算や引き算などの演算や、and, or, xorなどの論理関数です。
そのため ALU (算術論理演算ユニット)と呼ばれます。
\fi

\ifshoworiginal
The function input \code{fn} selects the operation. The ALU is usually a combinational
circuit without any state elements. An ALU might also have additional outputs to signal properties
of the result, such as zero or the sign.
\fi

\ifshowtransfirst %(自動翻訳)
関数入力\code{fn}動作を選択します。
ALUは、通常、任意の状態要素なしで組み合わせ回路です。
AN ALUはまた、ゼロまたは記号などの結果の性質を、シグナリングする追加的な出力を有するかもしれません。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
関数入力\code{fn}は、演算を選択します。ALUは通常、状態要素(ラッチ)を持たない組合せ回路です。
また、ALUは、ゼロや符号のような、追加の出力を、演算結果のプロパティとして持つ場合もあります。
\fi

\ifshoworiginal
The following code shows an ALU with 16-bit inputs and outputs that supports: addition, subtraction, or, and and
operation, selected by a 2-bit \code{fn} signal.
\fi

\ifshowtransfirst %(自動翻訳)
次のコードを示してサポートすることを、16ビットの入力と出力とのALU：加算、減算、又は、および、動作は、2ビット\code{fn}信号により選択。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
次のコードは、16 ビットの入出力を持つ ALU で、足し算、引き算、OR、AND、をサポートしています。
演算の種類は、2ビットの\code{fn}信号で選択します。
\fi

\shortlist{code/components_alu.txt}

\ifshoworiginal
\noindent In this example, we use a new Chisel construct, the \code{switch/is} construct to describe
the table that selects the output of our ALU.
To use this utility function, we need to import another Chisel package:
\fi

\ifshowtransfirst %(自動翻訳)
この例では、我々は我々のALUの出力を選択し、テーブルを記述するために、新たなChisel構造物、\code{switch/is}構文を使用します。
このユーティリティの機能を使用するには、我々は別のChiselパッケージをインポートする必要があります。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
\noindent この例では、新しいChiselのコンストラクトである\code{switch/is}を使用して、ALUの出力を選択するテーブルを記述しています。
このユーティリティ関数を使用するには、以下のように別のChiselパッケージをインポートする必要があります。
\fi

\shortlist{code/components_util.txt}

\ifshoworiginal
\section{Bulk Connections}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Bulk Connections}
\fi
\ifshowtranssecond %(校正)
\section{バルク接続}
\fi

\index{Bulk connection}

\ifshoworiginal
For connecting components with multiple IO ports, Chisel provides the
bulk connection operator \code{<>}. This operator connects parts of bundles
in both directions. Chisel uses the names of the leaf fields for the connection.
If a name is missing, it is not connected.
\fi

\ifshowtransfirst %(自動翻訳)
複数のIOポートとコンポーネントを接続するために、Chiselは、バルク接続オペレータ\code{<>}を提供します。
このオペレータは、両方向の束の部分を接続しています。
Chiselは、接続のための葉のフィールドの名前を使用しています。
名前が欠落している場合は、それが接続されていません。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
複数のIOポートでコンポーネントを接続するために、Chiselはバルク接続演算子\code{<>}を提供します。
この演算子は、バンドルの一部を双方向に接続します。
Chiselはリーフフィールドの名前を使って接続します。
名前がない場合は接続されません。
\fi

\ifshoworiginal
As an example, let us assume we build a pipelined processor. The fetch
stage has a following interface:
\fi

\ifshowtransfirst %(自動翻訳)
例として、私たちは、パイプラインプロセッサを構築すると仮定しましょう。
フェッチステージは、次のインタフェースがあります。
\fi

\ifshowtranssecond %(校正 5/20 mune10)
例として、パイプライン型のプロセッサを構築したとします。
フェッチステージは以下のようなインターフェースを持っています。
\fi

\shortlist{code/bundle_fetch.txt}

\ifshoworiginal
\noindent The next stage is the decode stage.
\fi

\ifshowtransfirst %(自動翻訳)
次のステージは、デコードステージです。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
\noindent 次のステージは、デコードステージです。
\fi

\shortlist{code/bundle_decode.txt}

\ifshoworiginal
\noindent The final stage of our simple processor is the execute stage.
\fi

\ifshowtransfirst %(自動翻訳)
私たちのシンプルなプロセッサの最終段階は、実行段階です。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
シンプルなプロセッサの最終段階は、実行ステージです。
\fi

\shortlist{code/bundle_execute.txt}

\ifshoworiginal
To connect all three stages we need just two \code{<>} operators.
We can also connect the port of a submodule with the parent module.
\fi

\ifshowtransfirst %(自動翻訳)
すべての3つのステージを接続するには、我々はわずか2 \code{<>}演算子を必要とします。
我々はまた、親モジュールとサブモジュールのポートを接続することができます。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
3つのステージをすべて接続するために必要なのは、たった2つの\code{<>} 演算子だけです。
そして、サブモジュールのポートを親モジュールに接続することにも使えます。
\fi

\shortlist{code/bundle_connect.txt}

\ifshoworiginal
\section{Lightweight Components with Functions}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Lightweight Components with Functions}
\fi
\ifshowtranssecond %(校正)
\section{関数(Function)による軽量コンポーネント}
\fi

\label{sec:functions}
\index{Function components}

\ifshoworiginal
Modules are the general way to structure your hardware description.
However, there is some boilerplate code when declaring a module and when instantiating and
connecting it.
A lightweight way to structure your hardware is to use functions.
Scala functions can take Chisel (and Scala) parameters and return generated hardware.
As a simple example, we generate an adder:
\fi

\ifshowtransfirst %(自動翻訳)
モジュールは、お使いのハードウェア記述を構築するための一般的な方法です。
しかし、モジュールを宣言し、インスタンス化するとき、それを接続するいくつかの定型的なコードがあります。
お使いのハードウェアを構築するための軽量な方法は、関数を使用することです。
Scalaの関数は、Chisel（およびスカラ）のパラメータを取り、生成されたハードウェアを返すことができます。
簡単な例として、我々は、加算器を生成します。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
モジュールは、ハードウェアの記述を構造化するための一般的な方法です。
しかし、モジュールを宣言するときや、インスタンス化して接続するときには、いくつかの定型的なコードがあります。
関数を使用することでハードウェアを軽量に構造化する事ができます。
Scala の関数は Chisel (および Scala) のパラメータを受け取り、生成されたハードウェアを返すことができます。
簡単な例として、以下の例では加算器を生成します。
\fi

\shortlist{code/components_fn_def.txt}

\ifshoworiginal
\noindent We can then create two adders by simply calling the function \code{adder}.
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、単に機能\code{adder}を呼び出すことによって、2個の加算器を作ることができます。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
\noindent 関数 \code{adder}を呼び出すだけで、2つの加算器を作成することができます。
\fi

\shortlist{code/components_fn_use.txt}

\ifshoworiginal
\noindent Note that this is a \emph{hardware generator}. You are not executing any add operation
during elaboration, but create two adders (hardware instances). The adder is an artificial example
to keep it simple. Chisel has already an adder generation function, like \code{+(that: UInt)}.
\fi

\ifshowtransfirst %(自動翻訳)
これは\emph{hardware generator}であることに注意してください。
あなたは推敲中に任意の追加操作を実行しますが、2個の加算器（ハードウェアのインスタンス）を作成されていません。
加算器は、それをシンプルに保つために人工的な例です。
Chiselは\code{+(that: UInt)}のように、すでに加算生成機能を持っています。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
\noindent これは、\emph{ハードウエア・ジェネレーター} であることに注意してください。
エラボレーション過程ででは、加算演算を実行するかわりに、2つの加算器(ハードウェアインスタンス)を作成します。
この例ではわざと加算器を生成しましたが、
Chiselには既に、\code{+(that: UInt)}のような加算器生成機能があります。
\fi

\ifshoworiginal
Functions, as lightweight hardware generators, can also contain state (including a register).
Following example returns a one clock cycle delay element (a register).
If a function has just a single statement, we can write it in one line and omit the curly
braces ({}).
\fi

\ifshowtransfirst %(自動翻訳)
関数は、軽量のハードウェア発生器として、また（レジスタを含む）の状態を含めることができます。
次の例では、1つのクロックサイクルの遅延素子（レジスタ）を返します。
関数は1つだけの文を持っている場合、我々は1行でそれを書いて、（{}）中括弧を省略することができます。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
さらに、関数には、軽量なハードウェア生成器として、ステート（レジスタを含む）を含むこともできます。
以下の例では、1クロックサイクルの遅延要素（レジスタ）を生成しています。
関数が1つの文だけの場合は、1行で記述して中括弧({})を省略することができます。
\fi

\shortlist{code/components_fn_delay.txt}

\ifshoworiginal
\noindent By calling the function with the function itself as parameter, this generated a two
clock cycle delay.
\fi

\ifshowtransfirst %(自動翻訳)
パラメータとして関数自身で関数を呼び出すことで、これは2つのクロックサイクルの遅延を生成しました。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
\noindent 関数自体をパラメータとして関数を呼び出すことで、2クロックサイクルの遅延が発生しました。
\fi

\shortlist{code/components_fn_2delay.txt}

\ifshoworiginal
\noindent Again, this is a too short example to be useful, as \code{RegNext()}
already is that function creating the register for the delay.
\fi

\code{RegNext()}既に遅延するためのレジスタを作成するという機能であるとして再度、このことは、有用であることが短すぎる例です。

\ifshoworiginal
Functions can be declared as part of a \code{Module}. However, functions that shall be
used in different modules are better placed into a Scala object that collects utility
functions.
\fi

\ifshowtransfirst %(自動翻訳)
機能は\code{Module}の一部として宣言することができます。
しかし、別のモジュールで使用されなければならない機能は、より良好な効用関数を収集Scalaのオブジェクトに配置されています。
\fi

\ifshowtranssecond %(校正 10/10 mune10)
関数は、\code{Module} の一部として宣言することができます。
ただし、異なるモジュールで使用する関数は、ユーティリティ関数を集めたScalaオブジェクトの中に入れた方が良いでしょう。
\fi

\ifshoworiginal
\chapter{Combinational Building Blocks}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Combinational Building Blocks}
\fi
\ifshowtranssecond %(校正)
\chapter{ 組合せ回路ブロック (L5130 mune10/diningyo 初回校正済)}%(  2020-1008 校正  第5章  ====================================)
\fi

\ifshoworiginal
In this chapter, we explore various combinational circuits, basic building blocks that we can
use to construct more complex systems.
In principle, all combinational circuits can be described with Boolean equations.
However, more often, a description in the form of a table is more efficient.
We let the synthesize tool extract and minimize the Boolean equations.
Two basic circuits, best described in a table form, are a decoder and an encoder.
\fi

\ifshowtransfirst %(自動翻訳)
この章では、我々は、より複雑なシステムを構築するために使用することができ、様々な組合せ回路、基本的なビルディングブロックを探ります。
原則として、すべての組合せ回路は、ブール方程式で記述することができます。
しかし、多くの場合、テーブルの形式で記述は、より効率的です。
私たちは、のsynthesizeツールエキスを聞かせてブール式を最小化します。
最良表形式で説明する2つの基本的な回路は、デコーダおよびエンコーダです。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
この章では、より複雑なシステムを構築するための基本的な構成要素である様々な組合せ回路を探求します。
原則として、すべての組合せ回路はブール方程式で記述することができます。
しかし、多くの場合、表の形で記述する方が効率的です。
我々は、合成ツールにブール方程式を抽出して最小化することを任せています。
表形式で記述するのに最適な基本回路は、デコーダとエンコーダの2つです。
\fi

\ifshoworiginal
\section{Combinational Circuits}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Combinational Circuits}
\fi
\ifshowtranssecond %(校正)
\section{組合せ回路}
\fi

\index{Combinational circuit}

\ifshoworiginal
Before describing some standard combinational building blocks, we will explore
how combinational circuits can be expressed in Chisel.
The simplest form is a Boolean expression, which can be assigned a name:
\fi

\ifshowtransfirst %(自動翻訳)
いくつかの標準的な組み合わせのビルディングブロックを説明する前に、我々は、Chiselで表現することができる方法を組合せ回路探ります。
最も単純な形式は、名前を割り当てることができブール式、次のとおりです。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
いくつかの標準的な組み合わせのビルディングブロックを説明する前に、組み合わせ回路がChiselでどのように表現できるかを探ってみましょう。
最も単純な形式はブール式で、名前を割り当てることができます。
\fi

\shortlist{code/comb_bool.txt}

\ifshoworiginal
\noindent The Boolean expression is given a name (\code{e}) by assigning it
to a Scala value. The expression can be reused in other expressions:
\fi

\ifshowtransfirst %(自動翻訳)
ブール式は、スカラ値に割り当てることによって名前（\code{e}）が与えられます。
式は他の式で再利用することができます。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
\noindent ブール型の式は、Scalaの値に代入することで名前(\code{e})が与えられます。
この式は他の式で再利用することができます。
\fi

\shortlist{code/comb_use.txt}

\ifshoworiginal
Such an expression is considered fixed. A reassignment to \code{e}
with \code{=} would result in a Scala compiler error: \code{reassignment to val}.
A try with the Chisel operator \code{:=}, as shown below,
\fi

\ifshowtransfirst %(自動翻訳)
このような表現は固定と考えられています。
\code{=}と\code{e}への再割り当ては、Scalaのコンパイラエラーにつながる：\code{reassignment to val}を。
Chiselオペレータ\code{:=}と試して、以下に示すように、
\fi
\ifshowtranssecond %(校正 9/24 diningyo)
このような表現は固定と考えられています。\code{val}を使った\code{e}への、\code{=}による再代入はScalaではエラーになります。Chiselの演算子である\code{:=}を使って、次に示すコードを試してみてください。
\fi

\shortlist{code/comb_error.txt}

\ifshoworiginal
\noindent results in a runtime exception: \code{Cannot reassign to read-only}.
\fi


\ifshowtransfirst %(自動翻訳)
\code{Cannot reassign to read-only}：実行時例外で結果。
\fi

\ifshowtranssecond %(校正 9/24 diningyo)
これは実行時に"読み込み専用の変数への再代入は出来ない"という理由で、例外が発生します。
\fi

\ifshoworiginal
Chisel also supports describing combinational circuits with conditional updates.
Such a circuit is declared as a \code{Wire}. Then you uses conditional operations,
such as \code{when}, to describe the logic of the circuit.
The following code declares a \code{Wire} \code{w} of type \code{UInt} and assigns a default
value of \code{0}. The \code{when} block takes a Chisel \code{Bool} and reassigns
\code{3} to \code{w} if \code{cond} is \code{true.B}.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselはまた、条件付きのアップデートで組合せ回路を記述するサポートしています。
このような回路は\code{Wire}として宣言されています。
その後、回路のロジックを記述するために、このよう\code{when}として、条件付き演算を使用しています。
次のコードは、タイプ\code{UInt}の\code{Wire} \code{w}を宣言し、\code{0}のデフォルト値を割り当てます。
\code{when}ブロックはChisel\code{Bool}を取り、\code{cond}が\code{true.B}ある場合RRR011QlVhoioQにRRR011XngVYsPtを再割り当てします。
\fi

\ifshowtranssecond %(校正 9/24 diningyo)
Chiselでは特定の条件下で、組み合わせ回路を更新する記述もサポートされています。
このような回路は\code{Wire}として宣言されています。この回路の論理を記述するためには、\code{when}のような条件分岐の構文を使います。
次のコードでは、\code{w}という\code{UInt}型の\code{Wire}を宣言し、デフォルト値を\code{0}に設定しています。\code{when}ブロックはChiselの\code{Bool}型を引数にとり、\code{conde}が\code{true.B}のときに、\code{w}は\code{3}になります。
\fi

\shortlist{code/comb_wire.txt}

\ifshoworiginal
\noindent The logic of the circuit is a multiplexer, where the two inputs are the constants
\code{0} and \code{3} and the condition \code{cond} the select signal.
Keep in mind that we describe hardware circuits and not a software program with conditional
execution.
\fi

\ifshowtransfirst %(自動翻訳)
回路のロジックは、2つの入力は定数\code{0}と\code{3}選択信号\code{cond}状態であるマルチプレクサです。
私たちは、ハードウェア回路ではなく、条件付き実行とソフトウェアプログラムを記述することに注意してください。
\fi

\ifshowtranssecond %(校正 9/24 diningyo)
\noindent この回路の論理は、2つの定数\code{0}と\code{3}を入力とし、\code{cond}を選択信号とするマルチプレクサです。
私達は条件付き実行を行うソフトウェア・プログラムではなく、ハードウェア回路を記述していることを心に留めておいてください。
\fi

\ifshoworiginal
The Chisel condition construct \code{when} also has a form of \emph{else}, it is called
\code{otherwise}. With assigning a value under any condition we can omit the default
value assignment:
\fi

\ifshowtransfirst %(自動翻訳)
Chisel条件コンストラクト\code{when}も\emph{else}の形を持っている、それが\code{otherwise}と呼ばれています。
任意の条件で値を代入して、我々は、デフォルト値の割り当てを省略することができます。
\fi

\ifshowtranssecond %(校正 9/27 diningyo)
Chiselの条件構文\code{when}にも\code{else}に相当する\code{otherwise}と呼ばれるものがあります。特定の条件下で値を設定することで、デフォルト値の設定を無効にできます。
\fi

\shortlist{code/comb_otherwise.txt}

\index{when}
\index{if/elseif/else}
\index{otherwise}
\index{elsewhen}

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/mux-chain}
  \caption{A chain of multiplexers.}
  \label{fig:mux-chain}
\end{figure}

\ifshoworiginal
Chisel also supports a chain of conditionals (a if/elseif/else chain) with \code{.elsewhen}:
\fi

\ifshowtransfirst %(自動翻訳)
Chiselも\code{.elsewhen}と条件文（IF / ELSEIF /他のチェーン）のチェーンをサポートしています。
\fi

\ifshowtranssecond %(校正 9/27 diningyo)
Chiselは連続した条件分岐（if/elseif/else）である\code{.elsewhen}をサポートしています。
\fi

\shortlist{code/comb_elsewhen.txt}

\ifshoworiginal
\noindent This chain of \code{when}, \code{.elsewhen}, and \code{.otherwise}
construct a chain of multiplexers. Figure~\ref{fig:mux-chain} shows this chain of multiplexers.
That chain introduce a priority, i.e., when \code{cond} is true, the other conditions
are not evaluated.
\fi

\ifshowtransfirst %(自動翻訳)
\code{when}、\code{.elsewhen}、および\code{.otherwise}のこのチェーンは、マルチプレクサのチェーンを構築します。
図〜\ref{fig:mux-chain}は、マルチプレクサのこの連鎖を示しています。
そのチェーンは、私の優先順位を紹介します。
え。
\code{cond}がtrueの場合、他の条件は評価されません。
\fi

\ifshowtranssecond %(校正 9/27 diningyo)
\noindent この\code{when}、\code{.elsewhen}、\code{.otherwise}のチェーンは、マルチプレクサのチェーンになります。
図〜\ref{fig:mux-chain}は、このマルチプレクサを示しています。このチェーンは優先順位を持っていて、例えば\code{cond}が真になった時、その他の条件は評価されません。
\fi

\ifshoworiginal
Note the `.' in \code{.elsewhen} that is needed to chain methods in Scala.
Those \code{.elsewhen} branches can be arbitrary long.
However, if the chain of conditions depends on a single signal, it is better
to use the \code{switch} statement, which is introduced in the following
subsection with a decoder circuit.
\fi

\ifshowtransfirst %(自動翻訳)
`に注意してください。
「\code{.elsewhen}にスカラ座での連鎖方式に必要とされています。
これら\code{.elsewhen}枝は、任意の長さにすることができます。
条件の鎖が単一の信号に依存している場合しかし、デコーダ回路では、次のサブセクションで導入される\code{switch}文を使用した方がよいです。
\fi

\ifshowtranssecond %(校正 9/30 diningyo)
 Scalaで連続してメソッドを呼び出す際には、\code{.elsewhen}の`.'が必要となる点に注意してください。
 この\code{.elsewhen}の分岐は、必要な分だけ長く出来ます。
 しかしながら、条件分岐の条件が単一の信号に依存する場合には、\code{switch}文を使うほうが良いでしょう。
 これについて次節のデコーダーで紹介します。
\fi

\ifshoworiginal
For more complex combinational circuits it might be practical to assign
a default value to a \code{Wire}. A default assignment can be combined with the wire
declaration with \code{WireDefault}.
\fi

\ifshowtransfirst %(自動翻訳)
より複雑な組合せ回路の場合には、\code{Wire}にデフォルト値を割り当てることが実用的かもしれません。
デフォルト割り当ては\code{WireDefault}有するワイヤ宣言と組み合わせることができます。
\fi

\ifshowtranssecond %(校正 9/30 diningyo)
より複雑な組合せ回路の場合には、\code{Wire}にデフォルト値を割り当てることが実用的かもしれません。
宣言時にデフォルト値を設定するため場合には、\code{WireDefault}を使うことができます。
\fi

\shortlist{code/comb_wiredefault.txt}

\ifshoworiginal
One might question why using \code{when}, \code{.elsewhen}, and \code{otherwise}
when Scala has \code{if}, \code{else if}, and \code{else}? Those statements are for
conditional execution of Scala code, not generating Chisel (multiplexer) hardware.
Those Scala conditionals have their use in Chisel when we write circuit generators,
which take parameters to conditionally generate \emph{different} hardware instances.
\fi

\ifshowtransfirst %(自動翻訳)
Scalaは\code{if}、\code{else if}、および\code{else}を持っているとき\code{when}、RRR011S7qkXL3m、およびRRR011tzLJofG2を使用する理由の一つは、質問のでしょうか？これらのステートメントは、Chisel（マルチプレクサ）ハードウェアを生成しない、Scalaのコードの条件付き実行のためのものです。
我々は条件付きで\emph{different}ハードウェアのインスタンスを生成するためのパラメータを取る回路ジェネレータを、書くときこれらのScalaの条件文は、Chiselでの使用を持っています。
\fi

\ifshowtranssecond %(校正 9/30 diningyo) ( fix 10/09 for build error  mune10)
質問として考えられそうな事の1つに「Scalaには\code{if}、\code{else if}、\code{else}という構文があるのに、
なぜ\code{when}、\code{.elsewhen}、\code{.otherwise}を使うのか？」ということありそうです。
これらの構文はScalaの条件分岐処理であり、Chiselのハードウェア（マルチプレクサ）を生成するものではありません。
これらのScalaの条件分岐は、パラメータを用いて条件によって異なるハードウェアを生成する回路ジェネレータを作成する際に使用されます。
\fi

\ifshoworiginal
\section{Decoder}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Decoder}
\fi
\ifshowtranssecond %(校正)
\section{デコーダー}
\fi

\index{Decoder}

\ifshoworiginal
A \myref{https://en.wikipedia.org/wiki/Binary_decoder}{decoder}
converts a binary number of $n$ bits to an $m$-bit signal, where $m \leq 2^n$.
The output is one-hot encoded (where exactly one bit is one).
\fi

\ifshowtransfirst %(自動翻訳)
A \myref{https://en.wikipedia.org/wiki/Binary_decoder}{decoder}
%は$ M $ビット信号、$ M \当量2 ^ N $に$ N $ビットの2進数に変換します。
%出力は、（厳密に1ビットが1である）ワンホットエンコードされています。
\fi

\ifshowtranssecond %(校正 10/5 diningyo)
\myref{https://en.wikipedia.org/wiki/Binary_decoder}{decoder}は、nビットの2進数を$m \leq 2^n$であるようなmビットの信号に変換します。
その出力はワン・ホットにエンコードされたもの（特定の1bitだけが1）になります。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/decoder}
  \caption{A 2-bit to 4-bit decoder.}
  \label{fig:decoder}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:decoder} shows a 2-bit to 4-bit decoder. We can describe the function
of the decoder with a truth table, such as Table~\ref{tab:decoder}.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:decoder}は、2ビットから4ビットのデコーダを示しています。
私たちは、このような表〜\ref{tab:decoder}として、真理値表とデコーダの機能を記述することができます。
\fi
\ifshowtranssecond %(校正 10/5 diningyo)
図〜\ref{fig:decoder}は、2ビットから4ビットのデコーダを示しています。このデコーダの機能は、表〜\ref{tab:decoder}のような真理値表として表現できます。
\fi

\begin{table}
 \centering
 \label{tab:decoder}
  \begin{tabular}{rr}
    \toprule
    a & b \\
    \midrule
    00 & 0001 \\
    01 & 0010 \\
    10 & 0100 \\
    11 & 1000 \\
    \bottomrule
  \end{tabular}
  \caption{Truth table for a 2 to 4 decoder.}
\end{table}

\ifshoworiginal
A Chisel \code{switch} statement describes the logic as a truth table.
The \code{switch} statement is not part of the core Chisel language.
Therefore, we need to include the elements of the package \code{chisel.util}.
\fi

\ifshowtransfirst %(自動翻訳)
Chisel\code{switch}文は、真理値表などのロジックを記述します。
\code{switch}文は、コアChisel言語の一部ではありません。
したがって、我々はパッケージ\code{chisel.util}の要素を含める必要があります。
\fi
\ifshowtranssecond %(校正 10/5 diningyo)
Chiselの\code{switch}文は、真理値表のような論理を記述します。\code{switch}文は、Chiselの言語機能の一部ではありません。そのため使用する際には、パッケージ\code{chisel3.util}をインポートする必要があります。
\fi

\shortlist{code/encdec_util.txt}

\ifshoworiginal
\noindent The following code introduces the \code{switch} statement of Chisel to describe a decoder:
\fi

\ifshowtransfirst %(自動翻訳)
次のコードデコーダを記述するためにChiselの\code{switch}文を紹介します。
\fi
\ifshowtranssecond %(校正 10/5 diningyo)
\noindent 次のコードは、Chiselの\code{switch}文で記述したデコーダーを紹介するためのものです。
\fi


\index{switch}

\shortlist{code/encdec_dec.txt}

\ifshoworiginal
\noindent The above \code{switch} statement lists all possible values of the \code{sel} signal
and assigns the decoded value to the \code{result} signal.
Note that even if we enumerate all possible input values, Chisel still needs us to assign a
default value, as we do by assigning 0 to \code{result}.
This assignment will never be active and therefore optimized away by the backend tool.
It is intended to avoid situations with incomplete assignments for combinational circuits
(in Chisel a \code{Wire}) that will result in unintended latches in hardware description
languages such as VHDL and Verilog. Chisel does not allow incomplete assignments.
\fi


\ifshowtransfirst %(自動翻訳)
\code{switch}上記のステートメントリスト\code{sel}信号および譲受人\code{result}信号にデコードされた値のすべての可能な値。
我々はすべての可能な入力値を列挙しても我々は\code{result}に0を割り当てることによって行うよう、Chiselはまだ、デフォルト値を割り当てるために私たちを必要としていることに注意してください。
この割り当ては、アクティブなので、離れて、バックエンドのツールによって、最適化されたことはありません。
このようなVHDLおよびVerilogなどのハードウェア記述言語での意図しないラッチをもたらすであろう（Chiselで\code{Wire}）組み合わせ回路のための不完全割り当て有する状況を回避することを意図しています。
Chiselは、不完全な割り当てを許可していません。
\fi

\ifshowtranssecond %(校正 10/5 diningyo)
上記の\code{switch}文では\code{sel}が取りうる値をすべてリストアップし、それらすべてのケースで\code{result}にデコード後の値を割り当てています。
Chiselではたとえ\code{switch}文中で、可能性のあるすべての値を列挙したとしても、デフォルトの値を割り当てる必要がある点に注意してください。上記のコードでは\code{result}に0を割り当てている部分が該当しています。
この割当ては決して有効にならないため、バックエンドの最適化において削除されます。これはVHDLやVerilogのようなハードウェア記述言語において、組み合わせ回路（Chiselでは\code{Wire}）での不完全な割り当てが、意図しないラッチを生成することがあることを避けるためのものです。Chiselではこのような不完全な割り当ては許容されません。
\fi

\shortlist{code/encdec_shift.txt}

\ifshoworiginal
In the example before we used unsigned integers for the signals. Maybe a clearer representation
of an encode circuit uses the binary notation:
\fi

\ifshowtransfirst %(自動翻訳)
例では、信号用の符号なし整数を使用する前に。
多分エンコード回路の明確な表現は、バイナリ表記を使用します。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
前の例では、信号に符号なし整数を使用していました。
エンコード回路をより明確に表現するためには、2進数表記を使用した方が良いかもしれません。
\fi

\shortlist{code/encdec_decbin.txt}

\ifshoworiginal
\todo{from Luca: for very small examples. What if the one-hot input is 256 wires? Can Chisel capture that? Or I need 256 lines? I would suggest to put an additional example. Maybe there is something like the for loop in VHDL.}
\fi

\ifshoworiginal
A table gives a very readable representation of the decoder function but is also
a little bit verbose.
When examining the table, we see a regular structure: a 1 is shifted left by the number
represented by \code{sel}. Therefore, we can express a decoder with the Chisel shift
operation \code{<<}.
\fi

\ifshowtransfirst %(自動翻訳)
テーブルには、デコーダ機能の非常に読みやすい表現を与えるだけでなく、少し冗長です。
テーブルを調べるとき、私たちは規則的な構造を参照してください：1は\code{sel}によって表される数だけ左にシフトしています。
したがって、我々は、Chiselシフト操作\code{<<}とデコーダを表現することができます。
\fi
\ifshowtranssecond %(校正 10/5 diningyo)
テーブルはデコーダの機能をとても読みやすく表現しますが、少し冗長でもあります。このテーブルを調べてみると、1を\code{sel}だけ左にシフトした値となるという規則に気づきます。この規則を利用すると、先程のデコーダはChiselのシフト演算子\code{<<}を使って次のように表現できます。
\fi
\shortlist{code/encdec_shift.txt}


\ifshoworiginal
Decoders are used as a building block for a multiplexer by using the output as an enable
with an AND gate for the multiplexer data input. However, in Chisel, we do not need to construct
a multiplexer, as a \code{Mux} is available in the core library.
Decoders can also be used for address decoding, and then the outputs are used as
select signals, e.g., different IO devices connected to a microprocessor.
\fi


\ifshowtransfirst %(自動翻訳)
デコーダは、マルチプレクサデータ入力のためのANDゲートと有効として出力を使用して、マルチプレクサのためのビルディングブロックとして使用されます。
しかし、Chiselでは、我々は\code{Mux}は、コアライブラリで利用可能になると、マルチプレクサを構築する必要はありません。
デコーダは、アドレス復号化のために使用することができ、その後、出力選択信号、Eとして使用されます。
グラム。
、異なったIOデバイスは、マイクロプロセッサに接続されています。
\fi
\ifshowtranssecond %(校正 10/5 diningyo)
デコーダはその出力をイネーブル信号として、ANDゲートと共にマルチプレクサへのデータ入力のために使用することで、マルチプレクサを構成するブロックの1つとして使用されます。しかし、Chiselのコアライブラリには、\code{Mux}というマルチプレクサを実装したものが用意されているため、自分でマルチプレクサを構築する必要はありません。
デコーダはアドレスのデコードにも使用され、その出力を例えば、マイクロプロセッサに接続される異なる種類のIOデバイスを選択する信号として使用します。
\fi

\ifshoworiginal
\section{Encoder}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Encoder}
\fi
\ifshowtranssecond %(校正)
\section{エンコーダー}
\fi

\index{Encoder}

\ifshoworiginal
An \myref{https://en.wikipedia.org/wiki/Encoder_(digital)}{encoder}
converts a one-hot encoded input signal into a binary encoded output signal.
The encoder does the inverse operation of a decoder.
\fi

\ifshowtransfirst %(自動翻訳)
AN \myref{https://en.wikipedia.org/wiki/Encoder_(digital)}{encoder}バイナリ符号化された出力信号にワンホットエンコードされた入力信号を変換します。
エンコーダは、デコーダの逆の動作を行います。
\fi
\ifshowtranssecond %(校正 10/7 diningyo)
\myref{https://en.wikipedia.org/wiki/Encoder_(digital)}{エンコーダ}はワンホットな入力信号をバイナリの出力信号に変換します。エンコーダはデコーダの逆の処理を行います。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/encoder}
  \caption{A 4-bit to 2-bit encoder.}
  \label{fig:encoder}
\end{figure}


\begin{table}
 \centering
 \label{tab:encoder}
  \begin{tabular}{rr}
    \toprule
    a & b \\
    \midrule
    0001 & 00 \\
    0010 & 01 \\
    0100 & 10 \\
    1000 & 11 \\
    ???? & ?? \\
    \bottomrule
  \end{tabular}
  \caption{Truth table for a 4 to 2 encoder.}
\end{table}

\ifshoworiginal
Figure~\ref{fig:encoder} shows a 4-bit one-hot input to a 2-bit binary output encoder, and
Table~\ref{tab:encoder} shows the truth table of the encode function. However, an encoder
works only as expected when the input signal is one-hot coded. For all other input values, the output
is undefined. As we cannot describe a function with undefined outputs, we use a default
assignment that catches all undefined input patterns.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:encoder}は、2ビットのバイナリ出力エンコーダに4ビットのワンホット入力を示し、そして表〜\ref{tab:encoder}は、エンコード機能の真理値表を示します。
入力信号はワンホット符号化である場合しかし、エンコーダは、期待通りにのみ機能します。
他の全ての入力値については、出力は不定れます。
我々は未定義の出力を持つ関数を記述することはできませんように、我々はすべての未定義の入力パターンをキャッチデフォルトの割り当てを使用しています。
\fi

\ifshowtranssecond %(校正 10/8 diningyo)
図〜\ref{fig:encoder}は、4ビットのワンホットな入力を2ビットのバイナリに変換したものを示しており、表〜\ref{tab:encoder}は、そのエンコードの真理値表です。しかし、エンコーダは入力信号がワンホットな場合にのみ、期待通りに動作します。その他のすべての入力については、出力値は未定義となります。未定義の出力をもった機能を実装することは出来ないので、未定義となる入力のパターンを処理するため、デフォルト値を割り当てます。
\fi

\ifshoworiginal
The following Chisel code assigns a default value of 00 and then uses the switch statement
for the legal input values.
\fi

\ifshowtransfirst %(自動翻訳)
以下Chiselコードは、00のデフォルト値を代入した後、有効な入力値のswitchステートメントを使用します。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
以下のChiselコードでは、デフォルト値の00を代入してから、switch文を使用して正規の入力値を指定しています。
\fi

\shortlist{code/encdec_enc.txt}

\ifshoworiginal
\section{Exercises}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Exercises}
\fi
\ifshowtranssecond %(校正)
\section{演習}
\fi

\ifshoworiginal
Describe a combinational circuit to convert a 4-bit binary input to the encoding of a
\myref{https://en.wikipedia.org/wiki/Seven-segment_display}{7-segment display}.
You can either define the codes for the decimal digits, which was the initial
usage of a 7-segment display or additionally, define encodings for the remaining bit pattern
to be able to display all 16 values of a single digit in
\myref{https://en.wikipedia.org/wiki/Hexadecimal}{hexadecimal}.
When you have an FPGA board with a 7-segment display, connect 4 switches or
buttons to the input of your circuit and the output to the 7-segment display.
\fi

\ifshowtransfirst %(自動翻訳)
\myref{https://en.wikipedia.org/wiki/Seven-segment_display}{7-segment display}のエンコードに4ビットのバイナリ入力を変換するために、組み合わせ回路を記載しています。
どちらかの7セグメントディスプレイの最初の使用であったか、さらに、\myref{https://en.wikipedia.org/wiki/Hexadecimal}{hexadecimal}に一桁の全16の値を表示することができるように、残りのビットパターンの符号化を定義する桁、ためのコードを定義することができます。
あなたは7セグメントディスプレイとFPGAボードを持っている場合は、7セグメントディスプレイにあなたの回路の入力と出力に4つのスイッチやボタンを接続します。
\fi

\ifshowtranssecond %(校正 10/8 diningyo)
4bitのバイナリ入力を\myref{https://en.wikipedia.org/wiki/Seven-segment_display}{7-segment display}のエンコードに変換する組み合わせ回路を実装してください。7セグメント・ディスプレイの当初の使い方であった10進数の表示を行うためのコードか、それに加えて\myref{https://en.wikipedia.org/wiki/Hexadecimal}{hexadecimal}に記載されている残りのパターンを含んだ、16種類の値の表示を行うコードを実装しても構いません。
もし7セグメント・ディスプレイが搭載されているFPGAを持っているなら、実装した回路の入力を4つのスイッチ、もしくはボタンに、出力を7セグメント・ディスプレイに接続しましょう。
\fi

\ifshoworiginal
\chapter{Sequential Building Blocks}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Sequential Building Blocks}
\fi
\ifshowtranssecond %(校正)
\chapter{ シーケンシャル回路ブロック (L5709 TODO)} %(校正  第6章  ========================================================================)
\fi

\ifshoworiginal
Sequential circuits are circuits where the output depends on the input \emph{and}
previous values. As we are interested in synchronous design (clocked designs),
we mean synchronous sequential circuits when we talk about sequential
circuits.\footnote{We can also build sequential circuits with asynchronous logic and
feedback, but this is a specific niche topic and cannot be expressed in Chisel.}
To build sequential circuits, we need elements that can store state:
the so-called registers.
\fi

\ifshowtransfirst %(自動翻訳)
シーケンシャル回路は、出力が入力\emph{and}前の値に依存する回路です。
我々は同期設計（クロックドデザイン）に興味を持っているとして、我々は、順序回路について話すとき、私たちは、同期式順序回路を意味します。
\footnote{我々はまた、非同期ロジックやフィードバックを順序回路を構築することができますが、これは特定のニッチな話題で、Chiselで表現することはできません。いわゆるレジスタを：}
順序回路を構築するために、我々は状態を格納できる要素が必要です。
\fi

\ifshowtranssecond %(校正 TODO)
シーケンシャル回路は、出力が入力\emph{and}前の値に依存する回路です。
我々は同期設計（クロックドデザイン）に興味を持っているとして、我々は、順序回路について話すとき、私たちは、同期式順序回路を意味します。
\footnote{我々はまた、非同期ロジックやフィードバックを順序回路を構築することができますが、これは特定のニッチな話題で、Chiselで表現することはできません。いわゆるレジスタを：}
順序回路を構築するために、我々は状態を格納できる要素が必要です。
\fi

\ifshoworiginal
\section{Registers}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Registers}
\fi
\ifshowtranssecond %(校正)
\section{レジスター (L5743 TODO)}
\fi

\index{Register}
\index{Flip-flop}

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/register}
  \caption{A D flip-flop based register.}
  \label{fig:register}
\end{figure}

\ifshoworiginal
The fundamental elements for building sequential circuits are registers. A register is a collection
of \myref{https://en.wikipedia.org/wiki/Flip-flop_(electronics)\#D_flip-flop}{D flip-flops}.
A D flip-flop captures the value of its input at the rising edge of the clock and stores
it at its output. Alternatively, in other words: the register updates its output with the value of the input on the rising edge of the clock.
\fi

\ifshowtransfirst %(自動翻訳)
順序回路を構築するための基本的な要素は、レジスタです。
レジスタは\myref{https://en.wikipedia.org/wiki/Flip-flop_(electronics)\#D_flip-flop}{D flip-flops}のコレクションです。
Dフリップフロップキャプチャクロックとその出力で記憶するの立ち上がりエッジで、入力の値。
あるいは、言い換えれば、レジスタは、クロックの立ち上がりエッジで入力の値とその出力を更新します。
\fi

\ifshowtranssecond %(校正 TODO)
順序回路を構築するための基本的な要素は、レジスタです。
レジスタは\myref{https://en.wikipedia.org/wiki/Flip-flop_(electronics)\#D_flip-flop}{D flip-flops}のコレクションです。
Dフリップフロップキャプチャクロックとその出力で記憶するの立ち上がりエッジで、入力の値。
あるいは、言い換えれば、レジスタは、クロックの立ち上がりエッジで入力の値とその出力を更新します。
\fi

\index{Clock}

\ifshoworiginal
Figure~\ref{fig:register} shows the schematic symbol of a register. It contains an input
\code{D} and an output \code{Q}. Each register also contains an input for a \code{clock} signal.
As this global clock signal is connected to all registers in a synchronous circuit, it is usually
not drawn in our schematics. The little triangle on the bottom of the box symbolizes the
clock input and tells us that this is a register. We omit the clock signal in the following
schematics.
The omission of the global clock signal is also reflected by Chisel where no explicit
connection of a signal to the register's clock input is needed.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:register}は、レジスタの回路図シンボルを示しています。
これは、入力と出力の\code{D} \code{Q}が含まれています。
各レジスタはまた\code{clock}信号の入力が含まれています。
このグローバルクロック信号が同期回路内のすべてのレジスタに接続されているとして、それは通常、私たちの回路図で描かれていません。
ボックスの下部にある小さな三角形は、クロック入力を象徴し、これはレジスタであることを教えてくれる。
我々は、次の回路図でクロック信号を省略します。
グローバルクロック信号の省略は、レジスタのクロック入力に信号の明示的な接続が必要とされないChiselによって反射されます。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:register}は、レジスタの回路図シンボルを示しています。
これは、入力と出力の\code{D} \code{Q}が含まれています。
各レジスタはまた\code{clock}信号の入力が含まれています。
このグローバルクロック信号が同期回路内のすべてのレジスタに接続されているとして、それは通常、私たちの回路図で描かれていません。
ボックスの下部にある小さな三角形は、クロック入力を象徴し、これはレジスタであることを教えてくれる。
我々は、次の回路図でクロック信号を省略します。
グローバルクロック信号の省略は、レジスタのクロック入力に信号の明示的な接続が必要とされないChiselによって反射されます。
\fi

\ifshoworiginal
In Chisel a register with input \code{d} and output \code{q} is defined with:
\fi

\ifshowtransfirst %(自動翻訳)
Chiselに入力\code{d}と出力\code{q}でレジスタを使用して定義されています。
\fi

\ifshowtranssecond %(校正 TODO)
Chiselに入力\code{d}と出力\code{q}でレジスタを使用して定義されています。
\fi

\shortlist{code/sequ_reg.txt}

\ifshoworiginal
\noindent Note that we do not need to connect a clock to the register, Chisel implicitly does this.
A register's input and output can be arbitrary complex types
made out of a combination of vectors and bundles.
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、レジスタへのクロックを接続する必要はありませんが、Chiselは、暗黙的にこれを行います。
レジスタの入力と出力は、ベクトルおよびバンドルの組み合わせで作られた任意の複合タイプすることができます。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
\noindent レジスタにクロックを接続する必要はありません。
Chiselは暗黙のうちにこれを行います。
レジスタの入力と出力は、ベクトルと束の組み合わせで作られた任意の複雑な型にすることができます。
\fi

\ifshoworiginal
A register can also be defined and used in two steps:
\fi

\ifshowtransfirst %(自動翻訳)
レジスタは、2つのステップで定義されており、使用することができます。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
また、レジスタは2段階で定義して使用することができます。
\fi

\shortlist{code/sequ_reg2.txt}

\ifshoworiginal
First, we define the register and give it a name. Second, we connect the signal
\code{delayIn} to the input of the register. Note also that the name of the register
contains the string \code{Reg}. To easily distinguish between combinational
circuits and sequential circuits, it is common practice to have the marker
\code{Reg} as part of to the name. Also, note that names in Scala (and therefore
also in Chisel) are usually in
\myref{https://en.wikipedia.org/wiki/Camel_case}{CamelCase}.
Variable names start with lowercase and classes start with upper case.
\fi

\ifshowtransfirst %(自動翻訳)
まず、我々は、レジスタを定義し、名前を付けます。
第二に、我々は、レジスタの入力に信号\code{delayIn}を接続します。
レジスタの名前は、文字列\code{Reg}が含まれていることにも注意してください。
簡単に組み合わせ回路と順序回路を区別するために、名前の一部としてマーカー\code{Reg}を持っているのが一般的です。
また、（ノミでもそのためと）スカラ座での名前は\myref{https://en.wikipedia.org/wiki/Camel_case}{CamelCase}に通常あることに注意してください。
変数名は小文字で始まり、クラスは大文字で始まります。
\fi

\ifshowtranssecond %(校正 TODO)
まず、我々は、レジスタを定義し、名前を付けます。
第二に、我々は、レジスタの入力に信号\code{delayIn}を接続します。
レジスタの名前は、文字列\code{Reg}が含まれていることにも注意してください。
簡単に組み合わせ回路と順序回路を区別するために、名前の一部としてマーカー\code{Reg}を持っているのが一般的です。
また、（ノミでもそのためと）スカラ座での名前は\myref{https://en.wikipedia.org/wiki/Camel_case}{CamelCase}に通常あることに注意してください。
変数名は小文字で始まり、クラスは大文字で始まります。
\fi

\index{Reset}
\index{Initialization}
\index{リセット}
\index{初期化}

\ifshoworiginal
A register can also be initialized on reset. The \code{reset} signal is, as the \code{clock} signal,
implicit in Chisel. We supply the reset value, e.g., zero, as a parameter to the register
constructor \code{RegInit}. The input for the register is connected with a Chisel
assignment statement.
\fi

\ifshowtransfirst %(自動翻訳)
レジスタはリセット時に初期化することができます。
\code{reset}信号は、\code{clock}信号として、Chiselで暗黙的です。
私たちは、電子をリセット値を供給しています。
グラム。
、レジスタコンストラクタ\code{RegInit}へのパラメータとして、ゼロ。
レジスタの入力は、Chisel代入文が接続されています。
\fi

\ifshowtranssecond %(校正 TODO)
レジスタはリセット時に初期化することができます。
\code{reset}信号は、\code{clock}信号として、Chiselで暗黙的です。
私たちは、電子をリセット値を供給しています。
グラム。
、レジスタコンストラクタ\code{RegInit}へのパラメータとして、ゼロ。
レジスタの入力は、Chisel代入文が接続されています。
\fi

\shortlist{code/sequ_reg_init.txt}

\ifshoworiginal
The default implementation of reset in Chisel is a synchronous
reset.\footnote{Support for asynchronous reset is currently under development}
For a synchronous reset no change is needed on a D flip-flop, just a multiplexer
needs to be added\footnote{Current FPGA flip-flops contain a synchronous reset input.
Therefore, no additional resources are needed for the multiplexer.} to the input that
selects between the initialization value under reset and the data value.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselでリセットの既定の実装は同期リセットです。
\footnote{非同期リセットのサポートは現在開発中である}
変化がDフリップフロップに必要とされない同期リセットのために、単にマルチプレクサは
現在のFPGAの同期リセット入力を含むフリップフロップ追加する必要があります。そのため、追加のリソースがマルチプレクサのために必要とされていません。
リセット下の初期値及びデータ値の間で選択を入力します。
\fi

\ifshowtranssecond %(校正 TODO)
Chiselでリセットの既定の実装は同期リセットです。
\footnote{非同期リセットのサポートは現在開発中である}
変化がDフリップフロップに必要とされない同期リセットのために、単にマルチプレクサは
現在のFPGAの同期リセット入力を含むフリップフロップ追加する必要があります。そのため、追加のリソースがマルチプレクサのために必要とされていません。
リセット下の初期値及びデータ値の間で選択を入力します。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/register-reset}
  \caption{A D flip-flop based register with a synchronous reset.}
  \label{fig:register-reset}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:register-reset} shows the schematics of a register with a synchronous reset
where the reset drives the multiplexer. However, as synchronous reset is used quite often
modern FPGAs flip-flops contain a synchronous reset (and set) input to not waste LUT
resources for the multiplexer.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:register-reset}は、同期リセットリセットドライブマルチプレクサとレジスタの回路図を示しています。
しかし、同期リセットとして、現代のFPGAは、マルチプレクサのためのLUTのリソースを無駄にしないために同期リセット（セット）入力が含まれているフリップフロップかなり頻繁に使用されています。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:register-reset}は、同期リセットリセットドライブマルチプレクサとレジスタの回路図を示しています。
しかし、同期リセットとして、現代のFPGAは、マルチプレクサのためのLUTのリソースを無駄にしないために同期リセット（セット）入力が含まれているフリップフロップかなり頻繁に使用されています。
\fi

\ifshoworiginal
Sequential circuits change their value over time. Therefore, their behavior can be described
by a diagram showing the signals over time. Such a diagram is called a waveform or
\myref{https://en.wikipedia.org/wiki/Digital_timing_diagram}{timing diagram}.
\fi

\ifshowtransfirst %(自動翻訳)
順序回路は、時間の経過とともにその値を変更します。
したがって、彼らの行動は、時間の経過と共に信号を示す図によって説明することができます。
そのような図は、波形又は\myref{https://en.wikipedia.org/wiki/Digital_timing_diagram}{timing diagram}と呼ばれています。
\fi

\ifshowtranssecond %(校正 TODO)
順序回路は、時間の経過とともにその値を変更します。
したがって、彼らの行動は、時間の経過と共に信号を示す図によって説明することができます。
そのような図は、波形又は\myref{https://en.wikipedia.org/wiki/Digital_timing_diagram}{timing diagram}と呼ばれています。
\fi

\index{Timing diagram}
\index{Waveform diagram}
\index{波形図}

\todo{from Luca: Do readers know about timing diagrams?}

\begin{figure}
  \centering
  \includegraphics[scale=1]{figures/reg_wave}
  \caption{A waveform diagram for a register with a reset.}
  \label{fig:register-wave}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:register-wave} shows a waveform for the register with a reset
and some input data applied to it.
Time advances from left to right. On top of the figure, we see the clock that drives our circuit.
In the first clock cycle, before a reset, the register content is undefined. In the second clock cycle reset
is asserted high, and on the rising edge of this clock cycle (labeled B) the register
takes the initial value \code{0}. Input \code{inVal} is ignored. In the next clock cycle
\code{reset} is \code{0}, and the value of \code{inVal} is captured on the next rising
edge (labeled C). From then on \code{reset} stays \code{0}, as it should be, and the
register output follows the input signal with one clock cycle delay.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:register-wave}はリセットでレジスタのための波形を示し、いくつかの入力データは、それに適用されます。
時間は左から右へと移行します。
図の上部には、私たちは私たちの回路を駆動するクロックを参照してください。
最初のクロックサイクルでは、リセットする前に、レジスタの内容が定義されていません。
第2クロックサイクルリセットにハイにアサートされ、このクロック・サイクル（標識B）の立ち上がりエッジでレジスタが初期値\code{0}をとります。
入力\code{inVal}は無視されます。
次のクロックサイクルで\code{reset}は\code{0}あり、\code{inVal}の値は次の立ち上がりエッジ（標識C）上に捕捉されています。
その時から\code{reset}にそれがあるべきよう、\code{0}をままで、レジスタ出力は、1クロックサイクル遅れて入力信号に従います。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:register-wave}はリセットでレジスタのための波形を示し、いくつかの入力データは、それに適用されます。
時間は左から右へと移行します。
図の上部には、私たちは私たちの回路を駆動するクロックを参照してください。
最初のクロックサイクルでは、リセットする前に、レジスタの内容が定義されていません。
第2クロックサイクルリセットにハイにアサートされ、このクロック・サイクル（標識B）の立ち上がりエッジでレジスタが初期値\code{0}をとります。
入力\code{inVal}は無視されます。
次のクロックサイクルで\code{reset}は\code{0}あり、\code{inVal}の値は次の立ち上がりエッジ（標識C）上に捕捉されています。
その時から\code{reset}にそれがあるべきよう、\code{0}をままで、レジスタ出力は、1クロックサイクル遅れて入力信号に従います。
\fi

\ifshoworiginal
Waveforms are an excellent tool to specify the behavior of a circuit graphically.
Especially in more complex circuits where many operations happen in parallel
and data moves pipelined through the circuit, timing diagrams are convenient.
Chisel testers can also produce waveforms during testing that can be displayed
with a waveform viewer and used for debugging.
\fi

\ifshowtransfirst %(自動翻訳)
波形がグラフィカルに回路の動作を指定するための優れたツールです。
特に、多くの動作は並行して起こるとデータ移動が回路を通ってパイプラインより複雑な回路において、タイミング図は便利です。
Chiselテスターは、それがA波形ビューアで表示され、デバッグのために使用することができるテスト中の波形をも生成することができます。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
波形は、回路の動作をグラフィカルに指定するための優れたツールです。
特に、多くの演算が並列に行われ、データが回路内をパイプラインで移動するような複雑な回路では、タイミングダイアグラムが便利です。
また、Chiselテスターでは、テスト中に波形を作成し、波形ビューワで表示してデバッグに利用することもできます。
\fi

\ifshoworiginal
A typical design pattern is a register with an enable signal. Only when the enable signal
is \code{true} (high), the register captures the input; otherwise, it keeps its old value.
The enable can be implemented, similar to the synchronous reset, with
a multiplexer at the input of the register. One input to the multiplexer is the feedback of the
output of the register.
\fi

\index{Register!with enable}

\ifshowtransfirst %(自動翻訳)
典型的なデザインパターンは、イネーブル信号とレジスタです。
\code{true}（高）、レジスタキャプチャ入力する場合にのみイネーブル信号です。それ以外の場合は、その古い値を保持します。
レジスタの入力においてマルチプレクサと、同期リセットと同様、実現することができる可能にします。
マルチプレクサへの一方の入力には、レジスタの出力のフィードバックです。
\fi

\ifshowtranssecond %(校正 TODO)
典型的なデザインパターンは、イネーブル信号とレジスタです。
\code{true}（高）、レジスタキャプチャ入力する場合にのみイネーブル信号です。それ以外の場合は、その古い値を保持します。
レジスタの入力においてマルチプレクサと、同期リセットと同様、実現することができる可能にします。
マルチプレクサへの一方の入力には、レジスタの出力のフィードバックです。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/register-enable}
  \caption{A D flip-flop based register with an enable signal.}
  \label{fig:register-enable}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:register-enable} shows the schematics of a register with enable.
As this is also a common design pattern, modern FPGA flip-flops contain a
dedicated enable input, and no additional resources are needed.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:register-enable}が可能とレジスタの回路図を示します。
これはまた、一般的なデザインパターンであるとして、現代のFPGA専用のイネーブル入力が含まれているフリップフロップ、および追加のリソースが必要ありません。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:register-enable}が可能とレジスタの回路図を示します。
これはまた、一般的なデザインパターンであるとして、現代のFPGA専用のイネーブル入力が含まれているフリップフロップ、および追加のリソースが必要ありません。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=1]{figures/reg_en_wave}
  \caption{A waveform diagram for a register with an enable signal.}
  \label{fig:register-en-wave}
\end{figure}


\ifshoworiginal
Figure~\ref{fig:register-en-wave} shows an example waveform for a register
with enable. Most of the time, enable it high (\code{true}) and the register
follows the input with one clock cycle delay. Only in the fourth clock cycle
\code{enable} is low, and the register keeps its value (5) at rising edge D.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:register-en-wave}有効でレジスタのための波形例を示しています。
時間のほとんどは、高い（\code{true}）、それを有効にして、レジスタが1つのクロックサイクルの遅延と入力し、次。
唯一の第4のクロックサイクルで\code{enable}が低く、レジスタは、立ち上がりエッジDでその値（5）を保持します
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:register-en-wave}有効でレジスタのための波形例を示しています。
時間のほとんどは、高い（\code{true}）、それを有効にして、レジスタが1つのクロックサイクルの遅延と入力し、次。
唯一の第4のクロックサイクルで\code{enable}が低く、レジスタは、立ち上がりエッジDでその値（5）を保持します
\fi

\ifshoworiginal
A register with an enable can be described in a few lines of Chisel code
with a conditional update:
\fi

\ifshowtransfirst %(自動翻訳)
イネーブル付きレジスタは、条件付き更新とChiselの数行のコードで記述することができます。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
イネーブルを持つレジスタは、条件付きアップデートを用いて数行のChiselコードで記述することができます。
\fi

\shortlist{code/sequ_reg_ena.txt}

\ifshoworiginal
\noindent A register with enable can also be reset:
\fi

\ifshowtransfirst %(自動翻訳)
有効とレジスタもリセットすることができます：
\fi

\ifshowtranssecond %(校正 6/20 mune10)
\noindent また、イネーブルのレジスタをリセットすることもできます。
\fi

\shortlist{code/sequ_reg_init_ena.txt}

\ifshoworiginal
A register can also be part of an expression. The following circuit detects the rising edge
of a signal by comparing its current value with the one from the last clock cycle.
\fi

\ifshowtransfirst %(自動翻訳)
レジスタはまた、発現の一部にすることができます。
以下の回路は、最後のクロックサイクルからの1つで現在の値を比較することにより、信号の立ち上がりエッジを検出します。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
レジスタは式の一部にもなります。
次の回路は、信号の立ち上がりエッジを検出するために、その現在の値と最後のクロックサイクルからの値を比較します。
\fi

\shortlist{code/sequ_reg_rising.txt}

\ifshoworiginal
Now that we have explored all basic uses of a register, we put those registers to
good use and build more interesting sequential circuits.
\fi

\ifshowtransfirst %(自動翻訳)
今、私たちは、レジスタのすべての基本的な使い方を模索していることを、我々は良い使用してビルドより興味深い順序回路にこれらのレジスタを置きます。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
レジスタの基本的な使用法をすべて説明したところで、これらのレジスタを有効に使用して、より興味深いシーケンシャル回路を構築します。
\fi

\ifshoworiginal
\section{Counters}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Counters}
\fi
\ifshowtranssecond %(校正)
\section{カウンター (L6109 TODO)}
\fi

\label{sec:counter}
\index{Counter}
\index{カウンター}

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/counter}
  \caption{An adder and a register result in counter.}
  \label{fig:counter}
\end{figure}

\ifshoworiginal
One of the most basic sequential circuits is a counter. In its simplest form, a counter is a register
where the output is connected to an adder and the adder's output is connected to the input
of the register. Figure~\ref{fig:counter} shows such a free-running counter.
\fi

\ifshowtransfirst %(自動翻訳)
最も基本的な順序回路の一つはカウンターです。
その最も単純な形態では、カウンタ出力は加算器に接続され、加算器の出力は、レジスタの入力に接続されるレジスタです。
図〜\ref{fig:counter}は、フリーランニングカウンタを示しています。
\fi

\ifshowtranssecond %(校正 TODO)
最も基本的な順序回路の一つはカウンターです。
その最も単純な形態では、カウンタ出力は加算器に接続され、加算器の出力は、レジスタの入力に接続されるレジスタです。
図〜\ref{fig:counter}は、フリーランニングカウンタを示しています。
\fi

\ifshoworiginal
A free-running counter with a 4-bit register counts from 0 to 15 and then wraps around
to 0 again. A counter shall also be reset to a known value.
\fi

\ifshowtransfirst %(自動翻訳)
0 15から4ビットのレジスタ数とフリーランニングカウンタと再び0にラップアラウンド。
カウンタは、既知の値にリセットしなければなりません。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
4 ビットのレジスタを持つフリーランカウンタは、0 から 15 までカウントした後、再び 0 に折り返す。
また、カウンタは既知の値にリセットされなければならない。
\fi

\shortlist{code/sequ_free_counter.txt}

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/event-counter}
  \caption{Counting events.}
  \label{fig:event-counter}
\end{figure}

\ifshoworiginal
\noindent When we want to count events, we use a condition to increment the counter,
as shown in Figure~\ref{fig:event-counter} and in the following code.
\fi

\ifshowtransfirst %(自動翻訳)
私たちがイベントをカウントしたい場合には、図〜\ref{fig:event-counter}に、次のコードに示すように、我々は、カウンタをインクリメントする条件を使用しています。
\fi

\ifshowtranssecond %(校正 TODO)
私たちがイベントをカウントしたい場合には、図〜\ref{fig:event-counter}に、次のコードに示すように、我々は、カウンタをインクリメントする条件を使用しています。
\fi

\shortlist{code/sequ_event_counter.txt}

\ifshoworiginal
\subsection{Counting Up and Down}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Counting Up and Down}
\fi
\ifshowtranssecond %(校正)
\subsection{カウントアップとダウン (L6268 TODO)}
\fi

\ifshoworiginal
To count up to a value and then restart with \code{0}, we need to compare
the counter value with a maximum constant, e.g., with a \code{when}
conditional statement.
\fi

\ifshowtransfirst %(自動翻訳)
値をカウントアップし、その後\code{0}で再起動するには、我々は最大の定数、Eとカウンタ値を比較する必要があります。
グラム。
、\code{when}条件文で。
\fi

\ifshowtranssecond %(校正 TODO)
値をカウントアップし、その後\code{0}で再起動するには、我々は最大の定数、Eとカウンタ値を比較する必要があります。
グラム。
、\code{when}条件文で。
\fi

\shortlist{code/when_counter.txt}

\ifshoworiginal
\noindent We can also use a multiplexer for our counter:
\fi

\ifshowtransfirst %(自動翻訳)
また、当社のカウンターのためのマルチプレクサを使用することができます。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
\noindent  カウンターにはマルチプレクサを使用することもできます。
\fi

\shortlist{code/mux_counter.txt}

\ifshoworiginal
\noindent If we are in the mood of counting down, we start by resetting the counter register
with the maximum value and reset the counter to that value when reaching 0.
\fi

\ifshowtransfirst %(自動翻訳)
私たちはダウンカウントのムードにある場合、我々は最大値でカウンタレジスタをリセットすることで開始し、0に到達したときにその値にカウンタをリセットします。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
\noindent カウントダウンする場合、まずカウンタレジスタを最大値でリセットし、0になったらその値にリセットします。
\fi

\shortlist{code/down_counter.txt}

\ifshoworiginal
\noindent As we are coding and using more counters, we can
define a function with a parameter to generate a counter for us.
\fi

\ifshowtransfirst %(自動翻訳)
我々はコーディングや複数のカウンタを使用しているように、私たちは私たちのためにカウンタを生成するためのパラメータで関数を定義することができます。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
 私たちはコーディングをしていて、より多くのカウンタを使っているので、私たちのためにカウンタを生成するためのパラメータを持つ関数を定義することができます。
\fi

\shortlist{code/function_counter.txt}

\ifshoworiginal
\noindent The last statement of the function \code{genCounter} is the return
value of the function, in this example, the counting register \code{cntReg}.
\fi

\ifshowtransfirst %(自動翻訳)
機能\code{genCounter}の最後の文は、カウントが\code{cntReg}を登録し、この例では、関数の戻り値です。
\fi

\ifshowtranssecond %(校正 TODO)
機能\code{genCounter}の最後の文は、カウントが\code{cntReg}を登録し、この例では、関数の戻り値です。
\fi

\ifshoworiginal
Note, that in all the examples our counter had values between \code{0} and
\code{N}, including \code{N}. If we want to count 10 clock cycles we need
to set \code{N} to 9. Setting \code{N} to 10 would be a classic example of an
\myref{https://en.wikipedia.org/wiki/Off-by-one_error}{off-by-one error}.
\fi

\ifshowtransfirst %(自動翻訳)
注、すべての例では、当社のカウンターが\code{N}含む\code{0}と\code{N}、間の値を持っていたこと。
私たちは10回のクロックサイクルをカウントしたい場合は、私たちは9に\code{N}を設定する必要があります。
10に\code{N}を設定すると、\myref{https://en.wikipedia.org/wiki/Off-by-one_error}{off-by-one error}の古典的な例だろう。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
注、すべての例では、当社のカウンターが\code{N}含む\code{0}と\code{N}、間の値を持っていたこと。
私たちは10回のクロックサイクルをカウントしたい場合は、私たちは9に\code{N}を設定する必要があります。
10に\code{N}を設定すると、\myref{https://en.wikipedia.org/wiki/Off-by-one_error}{off-by-one error}の古典的な例だろう。
\fi

\ifshoworiginal
\subsection{Generating Timing with Counters}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Generating Timing with Counters}
\fi
\ifshowtranssecond %(校正)
\subsection{カウンタによるタイミングの生成 (L6371 TODO)}
\fi

\label{sec:gen:timing}
\index{Timing generation}

\ifshoworiginal
Besides counting events, counters are often used to generate a notion of time
(time as time on a wall clock).
A synchronous circuit runs with a clock with a fixed frequency.
The circuit proceeds in those clock ticks. There is no notion of time in a digital
circuit other than counting clock ticks. If we know the clock frequency, we
can generate circuits that generate timed events, such as blinking a LED
at some frequency as we have shown in the Chisel ``Hello World'' example.
\fi

\ifshowtransfirst %(自動翻訳)
イベントを数えるだけでなく、カウンターには、多くの場合、（壁時計の時間として時間）時間の概念を生成するために使用されています。
同期回路は、固定周波数のクロックで動作します。
回路は、これらのクロックティックで進行します。
クロックダニを数える以外のデジタル回路における時間の概念はありません。
私たちは、クロック周波数を知っている場合、我々はChisel `` Hello Worldの「」の例に示されているようないくつかの周波数でLEDを点滅させるなど、時限イベントを生成する回路を生成することができます。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
イベントを数える以外にも、カウンタは時間の概念を生成するためによく使われます（壁掛け時計の時間としての時間）。
同期回路は一定の周波数の時計で動作しています。
回路はそれらのクロックの刻みで進行します。デジタル回路では、クロックの刻みを数える以外に時間の概念はありません。
クロックの周波数がわかれば、例えば Chisel の ``Hello World'' の例で示したようにある周波数で LED を点滅させるような時間的なイベントを発生させる回路を作ることができます。
\fi


\ifshoworiginal
A common practice is to generate single-cycle \emph{ticks} with a frequency $f_{tick}$
that we need in our circuit. That tick occurs every $n$ clock cycles,
where $n = f_{clock}/f_{tick}$ and the tick is precisely one clock cycle long.
This tick is \emph{not} used as a derived clock, but as an enable signal for
registers in the circuit that shall logically operate at frequency $f_{tick}$.
Figure~\ref{fig:tick-wave} shows an example of a tick generated every
3 clock cycles.
\fi

\ifshowtransfirst %(自動翻訳)
一般的な方法は、我々の回路に必要なことを、周波数の$ F_ {ダニ} $でのシングルサイクル\emph{ticks}を生成することです。
そのティックは、すべて$ N $クロックサイクル、ここで$ N = F_ {クロック} / F_ {ティック} $を発生し、ダニが長く正確に1つのクロック・サイクルです。
このダニは\emph{not}派生クロックとして使用されるが、論理的に周波数の$ F_ {ティック} $で動作しなければならない回路におけるレジスタのイネーブル信号として。
図〜\ref{fig:tick-wave}は、すべての3クロックサイクル発生したダニの一例を示しています。
\fi

\ifshowtranssecond %(校正 TODO)
一般的な方法は、我々の回路に必要なことを、周波数の$ F_ {ダニ} $でのシングルサイクル\emph{ticks}を生成することです。
そのティックは、すべて$ N $クロックサイクル、ここで$ N = F_ {クロック} / F_ {ティック} $を発生し、ダニが長く正確に1つのクロック・サイクルです。
このダニは\emph{not}派生クロックとして使用されるが、論理的に周波数の$ F_ {ティック} $で動作しなければならない回路におけるレジスタのイネーブル信号として。
図〜\ref{fig:tick-wave}は、すべての3クロックサイクル発生したダニの一例を示しています。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=1]{figures/tick_wave}
  \caption{A waveform diagram for the generation of a slow frequency tick.}
  \label{fig:tick-wave}
\end{figure}

\ifshoworiginal
In the following circuit, we describe a counter that counts from \code{0}
to the maximum value of \code{N - 1}. When the maximum value is reached,
the \code{tick} is \code{true} for a single cycle, and the counter is reset to \code{0}.
When we count from \code{0} to \code{N - 1}, we generate one logical tick
every \code{N} clock cycles.
\fi

\ifshowtransfirst %(自動翻訳)
以下の回路では、我々は\code{0}から\code{N - 1}の最大値までカウントすることをカウンタについて説明します。
最大値に達したとき、\code{tick}は単一サイクルの\code{true}であり、そしてカウンタは\code{0}にリセットされます。
我々は\code{N - 1}に\code{0}から数えるとき、私たちは一つの論理目盛りごと\code{N}クロックサイクルを生成します。
\fi

\ifshowtranssecond %(校正 TODO)
以下の回路では、我々は\code{0}から\code{N - 1}の最大値までカウントすることをカウンタについて説明します。
最大値に達したとき、\code{tick}は単一サイクルの\code{true}であり、そしてカウンタは\code{0}にリセットされます。
我々は\code{N - 1}に\code{0}から数えるとき、私たちは一つの論理目盛りごと\code{N}クロックサイクルを生成します。
\fi

\shortlist{code/sequ_tick_gen.txt}

\index{Tick}

\ifshoworiginal
\noindent This logical timing of one tick every $n$ clock cycles can then be used
to advance other parts of our circuit with this slower, logical clock.
In the following code, we use just another counter that increments by \code{1}
every $n$ clock cycles.
\fi

\ifshowtransfirst %(自動翻訳)
1のこの論理的なタイミングは、ダニのすべての$ N $クロック・サイクルは、この遅く、論理クロックで私たちの回路の他の部分を前進させるために使用することができます。
次のコードでは、私たちは別のカウンタを使用すること\code{1}インクリメントごとに$ N $クロックサイクル。
\fi

\ifshowtranssecond %(校正 TODO)
1のこの論理的なタイミングは、ダニのすべての$ N $クロック・サイクルは、この遅く、論理クロックで私たちの回路の他の部分を前進させるために使用することができます。
次のコードでは、私たちは別のカウンタを使用すること\code{1}インクリメントごとに$ N $クロックサイクル。
\fi

\shortlist{code/sequ_tick_counter.txt}

\begin{figure}
  \centering
  \includegraphics[scale=1]{figures/tick_count_wave}
  \caption{Using the slow frequency tick.}
  \label{fig:tick-count-wave}
\end{figure}

\ifshoworiginal
\noindent Figure~\ref{fig:tick-count-wave} shows the waveform of the tick and the
slow counter that increments every tick ($n$ clock cycles).
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:tick-count-wave}は、ダニの波形及び遅いカウンタを増分毎ティック（$ N $クロックサイクル）ことを示しています。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:tick-count-wave}は、ダニの波形及び遅いカウンタを増分毎ティック（$ N $クロックサイクル）ことを示しています。
\fi

\index{Logical clock}

\ifshoworiginal
Examples of the usage of this slower \emph{logical} clock are: blinking an LED,
generating the baud rate for a serial bus, generating signals for 7-segment
display multiplexing, and subsampling input values for debouncing of buttons
and switches.
\fi

\ifshowtransfirst %(自動翻訳)
この遅い\emph{logical}クロックの使用の例は、LEDを点滅シリアルバスのボーレートを生成し、多重化7セグメントディスプレイのための信号を生成し、ボタンおよびスイッチのデバウンスの入力値をサブサンプリングします。
\fi

\ifshowtranssecond %(校正 TODO)
この遅い\emph{logical}クロックの使用の例は、LEDを点滅シリアルバスのボーレートを生成し、多重化7セグメントディスプレイのための信号を生成し、ボタンおよびスイッチのデバウンスの入力値をサブサンプリングします。
\fi

\ifshoworiginal
Although width inference should size the registers, it is better to explicitly
specify the width with the type at register definition or with the
initialization value. Explicit width definition can avoid surprises when a reset value of \code{0.U}
results in a counter with a width of a single bit.
\fi

\ifshowtransfirst %(自動翻訳)
幅推論サイズレジスタをべきであるが、明示的にレジスタ定義時または初期値のタイプと幅を指定することをお勧めします。
\code{0.U}のリセット値は、単一ビット幅のカウンタをもたらす場合、明示的な幅の定義は、驚きを回避することができます。
\fi

\ifshowtranssecond %(校正 TODO)
幅推論サイズレジスタをべきであるが、明示的にレジスタ定義時または初期値のタイプと幅を指定することをお勧めします。
\code{0.U}のリセット値は、単一ビット幅のカウンタをもたらす場合、明示的な幅の定義は、驚きを回避することができます。
\fi

\ifshoworiginal
\subsection{The Nerd Counter}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{The Nerd Counter}
\fi
\ifshowtranssecond %(校正)
\subsection{「オタク」カウンター (L6538 TODO)}
\fi

\ifshoworiginal
Many of us feel like being a \myref{https://en.wikipedia.org/wiki/Nerd}{nerd}, sometimes.
For example, we want to design a highly optimized version of our counter/tick generation.
A standard counter needs following resources: one register, one adder (or subtractor),
and a comparator. We cannot do much about the register or the adder. If we count
up, we need to compare against a number, which is a bit string. The comparator
can be built out of inverters for the zeros in the bit string and a large AND gate.
When counting down to zero, the comparator is a large NOR gate, which might be
a little bit cheaper than the comparator against a constant in an ASIC.
In an FPGA, where logic is built out of lookup tables, there is no difference between comparing
against 0 or 1. The resource requirement is the same for the up and down counter.
\fi

\ifshowtransfirst %(自動翻訳)
私たちの多くは、時々、\myref{https://en.wikipedia.org/wiki/Nerd}{nerd}ているように感じます。
たとえば、私たちは私たちのカウンタ/ダニ世代の高度に最適化されたバージョンをデザインしたいです。
標準カウンタは、次のリソースを必要とする：一つのレジスタ一の加算（または減算）、及びコンパレータ。
私たちは、レジスタや加算器についての多くを行うことはできません。
我々はカウントアップした場合、我々はビット列である数、と比較する必要があります。
コンパレータは、ビット列のゼロと大型ANDゲートのためのインバータから構築することができます。
ゼロまでカウントダウンすると、コンパレータは、ASICの定数に対するコンパレータよりも少し安くなる可能性がある、大きなNORゲートです。
ロジックはルックアップテーブルから構築されているFPGAでは、0又は1と比較するとの間に差がありません。
リソース要件は、アップとダウンカウンタでも同じです。
\fi

\ifshowtranssecond %(校正 TODO)
私たちの多くは、時々、\myref{https://en.wikipedia.org/wiki/Nerd}{nerd}ているように感じます。
たとえば、私たちは私たちのカウンタ/ダニ世代の高度に最適化されたバージョンをデザインしたいです。
標準カウンタは、次のリソースを必要とする：一つのレジスタ一の加算（または減算）、及びコンパレータ。
私たちは、レジスタや加算器についての多くを行うことはできません。
我々はカウントアップした場合、我々はビット列である数、と比較する必要があります。
コンパレータは、ビット列のゼロと大型ANDゲートのためのインバータから構築することができます。
ゼロまでカウントダウンすると、コンパレータは、ASICの定数に対するコンパレータよりも少し安くなる可能性がある、大きなNORゲートです。
ロジックはルックアップテーブルから構築されているFPGAでは、0又は1と比較するとの間に差がありません。
リソース要件は、アップとダウンカウンタでも同じです。
\fi

\ifshoworiginal
However, there is still one more trick a clever hardware designer can pull off.
Counting up or down needed a comparison against all counting bits, so far.
What if we count from N-2 down to -1? A negative number has the most significant bit
set to 1, and a positive number has this bit set to 0. We need to check this bit only to detect
that our counter reached -1. Here it is, the counter created by a nerd:
\fi


\ifshowtransfirst %(自動翻訳)
しかし、まだ1は、より巧妙なハードウェア設計者がやってのけることができるトリックがあります。
これまでのところ、すべてのカウント・ビットとの比較を必要とダウンカウントアップまたは。
我々は、N-2ダウンからの-1は何を数えますか？負の数は、1〜最上位ビットセットを有し、正の数が0にこのビットがセットされています。
私たちは私たちのカウンターに達したことを検出するために、このビットをチェックする必要が-1。
ここでは、オタクによって作成されたカウンタは、次のとおりです。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
しかし、巧妙なハードウェア設計者が引き出せるトリックがもう一つあります。
上か下かをカウントするには、これまでのところ、すべてのカウントビットとの比較が必要でした。
N-2から-1までカウントするとどうなるでしょうか？負の数は最上位ビットが1に設定されており、正の数はこのビットが0に設定されています。
このビットだけをチェックして，カウンタが-1に達したことを検出する必要があります． これがオタクが作ったカウンタです．
\fi

\shortlist{code/nerd_counter.txt}

\ifshoworiginal
\subsection{A Timer}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{A Timer}
\fi
\ifshowtranssecond %(校正)
\subsection{タイマー (L6610 TODO)}
\fi

\ifshoworiginal
Another form of timer we can create, is a one-shot timer. A one-shot timer is like a
kitchen timer: you set the number of minutes and press start. When the specified amount
of time has elapsed, the alarm sounds.
The digital timer is loaded with the time in clock cycles.
Then it counts down until reaching zero. At zero the timer asserts \emph{done}.
\fi

\ifshowtransfirst %(自動翻訳)
私たちが作成できるタイマーの別の形態は、ワンショットタイマです。
ワンショット・タイマは、キッチンタイマーのようなものです：あなたが分、プレス開始の数を設定します。
指定された時間が経過すると、アラームが鳴ります。
デジタルタイマーは、クロック・サイクルの時間をロードされます。
そして、それがゼロに達するまでカウントダウン。
ゼロでタイマーが\emph{done}を主張します。
\fi

\ifshowtranssecond %(校正 TODO)
私たちが作成できるタイマーの別の形態は、ワンショットタイマです。
ワンショット・タイマは、キッチンタイマーのようなものです：あなたが分、プレス開始の数を設定します。
指定された時間が経過すると、アラームが鳴ります。
デジタルタイマーは、クロック・サイクルの時間をロードされます。
そして、それがゼロに達するまでカウントダウン。
ゼロでタイマーが\emph{done}を主張します。
\fi

\ifshoworiginal
Figure~\ref{fig:timer} shows the block diagram of a timer. The register can be loaded with
the value of \code{din} by asserting \code{load}. When the \code{load} signal is de-asserted
counting down is selected (by selecting \code{cntReg - 1} as the input for the register).
When the counter reaches \code{0}, the signal \code{done} is asserted and the counter stops
counting by selecting input of the multiplexer that provides \code{0}.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:timer}は、タイマのブロック図を示します。
レジスタは\code{load}をアサートすることによって\code{din}の値をロードすることができます。
\code{load}信号である場合にはデアサートカウントダウンする（レジスタに対する入力として\code{cntReg - 1}を選択することによって）選択されます。
カウンタが\code{0}に到達すると、信号\code{done}がアサートされ、カウンタが\code{0}を提供するマルチプレクサの入力を選択することによりカウントを停止します。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:timer}は、タイマのブロック図を示します。
レジスタは\code{load}をアサートすることによって\code{din}の値をロードすることができます。
\code{load}信号である場合にはデアサートカウントダウンする（レジスタに対する入力として\code{cntReg - 1}を選択することによって）選択されます。
カウンタが\code{0}に到達すると、信号\code{done}がアサートされ、カウンタが\code{0}を提供するマルチプレクサの入力を選択することによりカウントを停止します。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/timer}
  \caption{A one-shot timer.}
  \label{fig:timer}
\end{figure}


\ifshoworiginal
Listing~\ref{lst:timer} shows the Chisel code for the timer. We use an 8-bit register \code{reg},
that is reset to \code{0}. The boolean value \code{done} is the result of comparing \code{reg}
with \code{0}. For the input multiplexer we introduce the wire \code{next} with a default
value of \code{0}. The \code{when/elsewhen} block introduces the other two inputs with
the select function. Signal \code{load} has priority over the decrement selection.
The last line connects the multiplexer, represented by \code{next}, to the input of the
register \code{reg}.
\fi

\ifshowtransfirst %(自動翻訳)
〜\ref{lst:timer}をリストタイマーのChiselコードを示します。
私たちは、\code{0}にリセットされ、8ビットのレジスタ\code{reg}を、使用しています。
ブール値\code{done}は\code{0}で\code{reg}を比較した結果です。
入力マルチプレクサのために我々は\code{0}のデフォルト値を持つワイヤ\code{next}をご紹介します。
\code{when/elsewhen}ブロックは、選択機能を持つ他の2つの入力を導入しています。
信号\code{load}はデクリメントの選択よりも優先されます。
最後の行は、レジスタ\code{reg}の入力に、\code{next}で表されるマルチプレクサを接続します。
\fi

\ifshowtranssecond %(校正 TODO)
〜\ref{lst:timer}をリストタイマーのChiselコードを示します。
私たちは、\code{0}にリセットされ、8ビットのレジスタ\code{reg}を、使用しています。
ブール値\code{done}は\code{0}で\code{reg}を比較した結果です。
入力マルチプレクサのために我々は\code{0}のデフォルト値を持つワイヤ\code{next}をご紹介します。
\code{when/elsewhen}ブロックは、選択機能を持つ他の2つの入力を導入しています。
信号\code{load}はデクリメントの選択よりも優先されます。
最後の行は、レジスタ\code{reg}の入力に、\code{next}で表されるマルチプレクサを接続します。
\fi

\longlist{code/timer.txt}{A one-shot timer}{lst:timer}

\ifshoworiginal
If we aim for a bit more concise code, we can directly assign the multiplexer values to
the register \code{reg}, instead of using the intermediate wire \code{next}.
\fi

\ifshowtransfirst %(自動翻訳)
我々はもう少し簡潔なコードを目指す場合は、代わりに直接、中間ワイヤ\code{next}を使用する、レジスタ\code{reg}マルチプレクサ値を割り当てることができます。
\fi

\ifshowtranssecond %(校正 TODO)
我々はもう少し簡潔なコードを目指す場合は、代わりに直接、中間ワイヤ\code{next}を使用する、レジスタ\code{reg}マルチプレクサ値を割り当てることができます。
\fi

\ifshoworiginal
\subsection{Pulse-Width Modulation}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Pulse-Width Modulation}
\fi
\ifshowtranssecond %(校正)
\subsection{パルス幅変調(PWM) (L6721 TODO)}
\fi

\ifshoworiginal
\myref{https://en.wikipedia.org/wiki/Pulse-width_modulation}{Pulse-width modulation} (PWM)
is a signal with a constant period and a modulation of the time the signal is \emph{high}
within that period.
\fi

\ifshowtransfirst %(自動翻訳)
\myref{https://en.wikipedia.org/wiki/Pulse-width_modulation}{Pulse-width modulation}（PWM）は、一定周期の信号であり、時間の変調は、信号がその期間内に\emph{high}あります。
\fi

\ifshowtranssecond %(校正 TODO)
\myref{https://en.wikipedia.org/wiki/Pulse-width_modulation}{Pulse-width modulation}（PWM）は、一定周期の信号であり、時間の変調は、信号がその期間内に\emph{high}あります。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/pwm}
  \caption{Pulse-width modulation.}
  \label{fig:pwm}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:pwm} shows a PWM signal. The arrows point to the start of the periods
of the signal. The percentage of time the signal is high, is also called the duty cycle.
In the first two periods the duty cycle is 25\,\%, in the next two 50\,\%, and in the last
two cycles it is 75\,\%. The pulse width is modulated between 25\,\% and 75\,\%.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:pwm}は、PWM信号を示しています。
矢印は信号の周期の開始を指します。
信号がハイである時間の割合は、また、デューティ・サイクルと呼ばれています。
%最初の二つの期間にデューティ・サイクルは、次の二つの50 \\％で、25 \\％であり、最後の2つのサイクルでは75 \\％です。
%パルス幅は％\\％及び75 \ \ 25の間で変調されます。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:pwm}は、PWM信号を示しています。
矢印は信号の周期の開始を指します。
信号がハイである時間の割合は、また、デューティ・サイクルと呼ばれています。
%最初の二つの期間にデューティ・サイクルは、次の二つの50 \\％で、25 \\％であり、最後の2つのサイクルでは75 \\％です。
%パルス幅は％\\％及び75 \ \ 25の間で変調されます。
\fi

\ifshoworiginal
Adding a \myref{https://en.wikipedia.org/wiki/Low-pass_filter}{low-pass filter} to a PWM
signal results in a simple
\myref{https://en.wikipedia.org/wiki/Digital-to-analog_converter}{digital-to-analog converter}.
The low-pass filter can be as simple as a resistor and a capacitor.
\fi

\ifshowtransfirst %(自動翻訳)
簡単\myref{https://en.wikipedia.org/wiki/Digital-to-analog_converter}{digital-to-analog converter}におけるPWM信号の結果に\myref{https://en.wikipedia.org/wiki/Low-pass_filter}{low-pass filter}を追加します。
ローパスフィルタは、抵抗およびコンデンサのような単純なようであることができます。
\fi

\ifshowtranssecond %(校正 TODO)
簡単\myref{https://en.wikipedia.org/wiki/Digital-to-analog_converter}{digital-to-analog converter}におけるPWM信号の結果に\myref{https://en.wikipedia.org/wiki/Low-pass_filter}{low-pass filter}を追加します。
ローパスフィルタは、抵抗およびコンデンサのような単純なようであることができます。
\fi

\ifshoworiginal
The following code example will generate a waveform of 3 clock cycles high every 10 clock cycles.
\fi

\ifshowtransfirst %(自動翻訳)
以下のコード例は、高い3つのクロック・サイクル毎に10クロックサイクルの波形を生成します。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
次のコード例では、10 クロックサイクルごとに 3 クロックサイクルのハイ（1）の波形を生成します。
\fi

\shortlist{code/pwm.txt}

\ifshoworiginal
\noindent We use a function for the PWM generator to provide a reusable, lightweight component.
The function has two parameters: a Scala integer configuring the PWM with the number of
clock cycles (\code{nrCycles}), and a Chisel wire (\code{din}) that gives the duty cycle (pulswidth) for the
PWM output signal. We use a multiplexer in this
example to express the counter. The last line of the function compares the counter value
with the input value \code{din} to return the PWM signal. The last expression in a Chisel function
is the return value, in our case the wire connected to the compare function.
\fi

\ifshowtransfirst %(自動翻訳)
我々は、再利用可能な、軽量コンポーネントを提供するために、PWMジェネレータの機能を使用しています。
（\code{nrCycles}）クロックサイクル数にPWMを設定Scalaの整数であり、PWM出力信号のデューティサイクル（pulswidth）を与えるChisel線（\code{din}）：関数は、2つのパラメータを有しています。
我々はカウンターを表現するために、この例では、マルチプレクサを使用しています。
関数の最後の行は、PWM信号を返すように入力値\code{din}とカウンタ値とを比較します。
Chisel関数の最後の式は、我々の場合には、比較機能に接続されたワイヤの戻り値です。
\fi

\ifshowtranssecond %(校正 TODO)
我々は、再利用可能な、軽量コンポーネントを提供するために、PWMジェネレータの機能を使用しています。
（\code{nrCycles}）クロックサイクル数にPWMを設定Scalaの整数であり、PWM出力信号のデューティサイクル（pulswidth）を与えるChisel線（\code{din}）：関数は、2つのパラメータを有しています。
我々はカウンターを表現するために、この例では、マルチプレクサを使用しています。
関数の最後の行は、PWM信号を返すように入力値\code{din}とカウンタ値とを比較します。
Chisel関数の最後の式は、我々の場合には、比較機能に接続されたワイヤの戻り値です。
\fi

\ifshoworiginal
We use the function \code{unsignedBitLength(n)} to specify the number of bits for the counter
\code{cntReg} needed to represent unsigned numbers up to (and including)
\code{n}.\footnote{The number of bits to represent an unsigned number $n$ in binary is $\lfloor log_2(n) \rfloor + 1$.}
Chisel also has a function \code{signedBitLength} to provide the number of bits
for a signed representation of a number.
\fi

\ifshowtransfirst %(自動翻訳)
我々は、最大の符号なし数値を表すのに必要なカウンタ\code{cntReg}のビット数（を含む）\code{n}を指定する機能\code{unsignedBitLength(n)}を使用します。
\footnote{ビット数が符号なしの数$ N $バイナリを表すために$ \ lfloor log_2（N）\ rfloor + 1 $です。}
Chiselはまた、数の符号付き表現のためのビットの数を提供するために機能\code{signedBitLength}を有しています。
\fi

\ifshowtranssecond %(校正 TODO)
我々は、最大の符号なし数値を表すのに必要なカウンタ\code{cntReg}のビット数（を含む）\code{n}を指定する機能\code{unsignedBitLength(n)}を使用します。
\footnote{ビット数が符号なしの数$ N $バイナリを表すために$ \ lfloor log_2（N）\ rfloor + 1 $です。}
Chiselはまた、数の符号付き表現のためのビットの数を提供するために機能\code{signedBitLength}を有しています。
\fi

\ifshoworiginal
Another application is to use PWM to dim an LED. In that case the eye serves as low-pass
filter. We expand the above example to drive the PWM generation by a triangular function.
The result is an LED with continuously changing intensity.
\fi

\ifshowtransfirst %(自動翻訳)
別のアプリケーションは、LEDを調光するためにPWMを使用することです。
その場合、目は、ローパスフィルタとして機能します。
私たちは、三角関数によってPWM生成を駆動するために、上記の例を展開します。
結果は、連続的に強度を変化させるとLEDです。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
もう一つのアプリケーションは、LEDを調光するためにPWMを使用することです。この場合、目はローパスフィルタとして機能します。
上記の例を拡張して、三角関数でPWM生成を駆動します。
その結果、強度が連続的に変化するLEDが得られます。
\fi

\shortlist{code/pwm_modulate.txt}

\ifshoworiginal
We use two registers for the modulation: (1) \code{modulationReg} for counting up and down
and (2) \code{upReg} as a flag to determine if we shall count up or down. We count up
to the frequency of our clock input (100\,MHz in our example), which results in a signal
of 0.5\,Hz. The lengthy \code{when/.elsewhen/.otherwise} expression handles the up- or
down-counting and the switch of the direction.
\fi

\ifshowtransfirst %(自動翻訳)
我々はカウントアップまたはダウンしなければならないかどうかを判断するためのフラグとして（1）\code{modulationReg}カウントアップするとダウンし、（2）\code{upReg}：私たちは、変調のための2つのレジスタを使用します。
当社は、クロック入力の周波数にカウントアップ（\ 100、MHzで私たちの例では）、0の信号で結果。
0.5ヘルツ。
アップ又はダウンカウントおよび方向のスイッチ長い\code{when/.elsewhen/.otherwise}式ハンドル。
\fi

\ifshowtranssecond %(校正 TODO)
我々はカウントアップまたはダウンしなければならないかどうかを判断するためのフラグとして（1）\code{modulationReg}カウントアップするとダウンし、（2）\code{upReg}：私たちは、変調のための2つのレジスタを使用します。
当社は、クロック入力の周波数にカウントアップ（\ 100、MHzで私たちの例では）、0の信号で結果。
0.5ヘルツ。
アップ又はダウンカウントおよび方向のスイッチ長い\code{when/.elsewhen/.otherwise}式ハンドル。
\fi

\ifshoworiginal
As our PWM counts only up to the 1000th of the frequency to generate a 1\,kHz signal,
we need to divide the modulation signal by 1000. As real division is very expensive in hardware,
we simply shift by 10 to the right, which equates a division by $2^{10} = 1024$.
As we have defined the PWM circuit as a function, we can simply instantiate that circuit
with a function call. Wire \code{sig} represents the modulated PWM signal.
\fi

\ifshowtransfirst %(自動翻訳)
までしか周波数の1000分に私達のPWMカウントは 1kHz の信号を生成するように、我々は1000で変調信号を分割する必要があります。
実際の分割は、ハードウェアで非常に高価であるので、我々は、単に
%= 1024 $ $ 2 ^ {10}
による除算を相当右、10だけシフト。
我々は機能としてPWM回路を定義したように、我々は単に関数呼び出しとその回路をインスタンス化することができます。
ワイヤ\code{sig}はPWM変調信号を表します。
\fi

\ifshowtranssecond %(校正 TODO)
までしか周波数の1000分に私達のPWMカウントは 1kHz の信号を生成するように、我々は1000で変調信号を分割する必要があります。
実際の分割は、ハードウェアで非常に高価であるので、我々は、単に
%= 1024 $ $ 2 ^ {10}
による除算を相当右、10だけシフト。
我々は機能としてPWM回路を定義したように、我々は単に関数呼び出しとその回路をインスタンス化することができます。
ワイヤ\code{sig}はPWM変調信号を表します。
\fi

\ifshoworiginal
\section{Shift Registers}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Shift Registers}
\fi
\ifshowtranssecond %(校正)
\section{シフトレジスタ (L6919 TODO)}
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/shiftregister}
  \caption{A 4 stage shift register.}
  \label{fig:shiftregister}
\end{figure}

\ifshoworiginal
A \myref{https://en.wikipedia.org/wiki/Shift_register}{shift register} is a collection of flip-flops
connected in a sequence. Each output of a register (flip-flop) is connected to the input of the
next register. Figure~\ref{fig:shiftregister} shows a 4-stage shift register.
The circuit \emph{shifts} the data from left to right on each clock tick. In this simple form the
circuit implements a 4-tap delay from \code{din} to \code{dout}.
\fi

\ifshowtransfirst %(自動翻訳)
A \myref{https://en.wikipedia.org/wiki/Shift_register}{shift register}は、フリップフロップ順に接続のコレクションです。
レジスタ（フリップフロップ）の各出力は、次のレジスタの入力に接続されています。
図〜\ref{fig:shiftregister}は4段のシフトレジスタを示しています。
回路\emph{shifts}各クロックチックに左から右へのデータ。
この単純な形態では、回路は\code{dout}に\code{din}から4タップ遅延を実現します。
\fi

\ifshowtranssecond %(校正 TODO)
A \myref{https://en.wikipedia.org/wiki/Shift_register}{shift register}は、フリップフロップ順に接続のコレクションです。
レジスタ（フリップフロップ）の各出力は、次のレジスタの入力に接続されています。
図〜\ref{fig:shiftregister}は4段のシフトレジスタを示しています。
回路\emph{shifts}各クロックチックに左から右へのデータ。
この単純な形態では、回路は\code{dout}に\code{din}から4タップ遅延を実現します。
\fi

\ifshoworiginal
The Chisel code for this simple shift register does: (1) create a 4-bit register \code{shiftReg},
(2) concatenate the lower 3 bits of the shift register with the input \code{din} for the next
input to the register, and (3) uses the most significant bit (MSB) of the register as the output \code{dout}.
\fi

\ifshowtransfirst %(自動翻訳)
この単純なシフトレジスタのChiselコードを行います4ビット\code{shiftReg}レジスタ作成（1）、（2）レジスタへの次の入力のための入力\code{din}有するシフトレジスタの下位3ビットを連結し、そして（3）用途出力\code{dout}としてレジスタの最上位ビット（MSB）。
\fi

\ifshowtranssecond %(校正 TODO)
この単純なシフトレジスタのChiselコードを行います4ビット\code{shiftReg}レジスタ作成（1）、（2）レジスタへの次の入力のための入力\code{din}有するシフトレジスタの下位3ビットを連結し、そして（3）用途出力\code{dout}としてレジスタの最上位ビット（MSB）。
\fi

\shortlist{code/shift_register.txt}

\ifshoworiginal
Shift registers are often used to convert from serial data to parallel data or from parallel data
to serial data. Section~\ref{sec:uart} shows a serial port that uses shift registers for the receive and
send functions.
\fi

\ifshowtransfirst %(自動翻訳)
シフトレジスタは、多くの場合、シリアルデータからパラレルデータまたはシリアルデータをパラレルデータに変換するために使用されます。
節〜\ref{sec:uart}は用途が受信および送信機能するシフトレジスタというシリアルポートを示します。
\fi

\ifshowtranssecond %(校正 TODO)
シフトレジスタは、多くの場合、シリアルデータからパラレルデータまたはシリアルデータをパラレルデータに変換するために使用されます。
節〜\ref{sec:uart}は用途が受信および送信機能するシフトレジスタというシリアルポートを示します。
\fi

\ifshoworiginal
\subsection{Shift Register with Parallel Output}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Shift Register with Parallel Output}
\fi
\ifshowtranssecond %(校正)
\subsection{パラレル出力付きシフトレジスタ (L6992 TODO)}
\fi

\ifshoworiginal
A serial-in parallel-out configuration of a shift register transforms a serial input stream into parallel
words. This may be used in a serial port (UART) for the receive function.
Figure~\ref{fig:shiftreg-paraout} shows a 4-bit shift register, where each flip-flop output
is connected to one output bit. After 4 clock cycles this circuit converts a 4-bit serial data word
to a 4-bit parallel data word that is available in \code{q}. In this example we assume that bit 0
(the least significant bit) is sent first and therefore arrives in the last stage when we want to read
the full word.
\fi

\ifshowtransfirst %(自動翻訳)
シリアルにシフトレジスタのパラレルアウト構成は、パラレルワードにシリアル入力ストリームを変換します。
これは、受信機能のためにシリアルポート（UART）で使用することができます。
図〜\ref{fig:shiftreg-paraout}は、各フリップフロップの出力が1つの出力ビットに接続される4ビットのシフトレジスタを示しています。
4クロックサイクル後、この回路は\code{q}で提供され、4ビットパラレルデータワードに4ビットのシリアル・データ・ワードに変換します。
この例では、最初に送信されるビット0（最下位ビット）を想定し、我々は完全な言葉を読みたいときので、最後の段階に到着します。
\fi

\ifshowtranssecond %(校正 TODO)
シリアルにシフトレジスタのパラレルアウト構成は、パラレルワードにシリアル入力ストリームを変換します。
これは、受信機能のためにシリアルポート（UART）で使用することができます。
図〜\ref{fig:shiftreg-paraout}は、各フリップフロップの出力が1つの出力ビットに接続される4ビットのシフトレジスタを示しています。
4クロックサイクル後、この回路は\code{q}で提供され、4ビットパラレルデータワードに4ビットのシリアル・データ・ワードに変換します。
この例では、最初に送信されるビット0（最下位ビット）を想定し、我々は完全な言葉を読みたいときので、最後の段階に到着します。
\fi

\ifshoworiginal
In the following Chisel code we initialize the shift register \code{outReg} with 0. Then we shift in from the
MSB, which means a right shift. The parallel result, \code{q}, is just the reading of the register
\code{outReg}.
\fi

\ifshowtransfirst %(自動翻訳)
次Chiselコードでは、0と\code{outReg}シフトレジスタを初期化します。
その後、我々は右シフトを意味し、MSBからシフトします。
パラレル結果、\code{q}は、レジスタ\code{outReg}だけの読書です。
\fi

\ifshowtranssecond %(校正 TODO)
次Chiselコードでは、0と\code{outReg}シフトレジスタを初期化します。
その後、我々は右シフトを意味し、MSBからシフトします。
パラレル結果、\code{q}は、レジスタ\code{outReg}だけの読書です。
\fi

\shortlist{code/shift_paraout.txt}

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/shiftreg-paraout}
  \caption{A 4-bit shift register with parallel output.}
  \label{fig:shiftreg-paraout}
\end{figure}

\ifshoworiginal
\noindent Figure~\ref{fig:shiftreg-paraout} shows a 4-bit shift register with a parallel output function.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:shiftreg-paraout}は、並列出力機能を有する4ビットのシフトレジスタを示しています。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:shiftreg-paraout}は、並列出力機能を有する4ビットのシフトレジスタを示しています。
\fi

\ifshoworiginal
\subsection{Shift Register with Parallel Load}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Shift Register with Parallel Load}
\fi
\ifshowtranssecond %(校正)
\subsection{パラレルロード付きシフトレジスタ (L7067 TODO)}
\fi

\ifshoworiginal
A parallel-in serial-out configuration of a shift register transforms a parallel input stream of words (bytes)
into a serial output stream.
This may be used in a serial port (UART) for the transmit function.
\fi

\ifshowtransfirst %(自動翻訳)
並列のシフトレジスタのシリアルアウト構成は、シリアル出力ストリームにワード（バイト）のパラレル入力ストリームを変換します。
これは、送信機能のためのシリアルポート（UART）で使用することができます。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
シフトレジスタのパラレルインシリアルアウト構成は、ワード（バイト）のパラレル入力ストリームをシリアル出力ストリームに変換します。
これは、シリアルポート（UART）で送信機能に使用することができます。
\fi


\begin{figure}
  \centering
  \includegraphics[scale=0.6]{figures/shiftreg-paraload}
  \caption{A 4-bit shift register with parallel load.}
  \label{fig:shiftreg-paraload}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:shiftreg-paraload} shows a 4-bit shift register with a parallel load function.
The Chisel description of that function is relatively straight forward:
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:shiftreg-paraload}は、並列ロード機能を有する4ビットのシフトレジスタを示しています。
その関数のChiselの説明は比較的簡単です：
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:shiftreg-paraload}は、並列ロード機能を有する4ビットのシフトレジスタを示しています。
その関数のChiselの説明は比較的簡単です：
\fi

\shortlist{code/shift_paraload.txt}

\ifshoworiginal
Note that we are now shifting to the right, filling in zeros at the MSB.
\fi

\ifshowtransfirst %(自動翻訳)
私たちは今、右にシフトしていることに注意してください、MSBにゼロで充填します。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
現在は右にシフトして、MSB のゼロを埋めていることに注意してください。
\fi

\ifshoworiginal
\section{Memory}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Memory}
\fi
\ifshowtranssecond %(校正)
\section{メモリー (L7128 TODO)}
\fi

\index{Memory}
\index{RAM}
\index{SRAM}
\index{メモリー}

\ifshoworiginal
A memory can be built out of a collection of registers, in Chisel a \code{Reg} of a \code{Vec}.
However, this is expensive in hardware, and larger memory structures are built
as \myref{https://en.wikipedia.org/wiki/Static_random-access_memory}{SRAM}.
For an ASIC, a memory compiler constructs memories.
FPGAs contain on-chip memory blocks, also called block RAMs.
Those on-chip memory blocks can be combined for larger memories.
Memories in an FPGA usually have one read and one write port, or
two ports that can be switched between read and write at runtime.
\fi

\ifshowtransfirst %(自動翻訳)
メモリはChiselでは、レジスタの集まりで\code{Vec}の\code{Reg}を構築することができます。
しかし、これはハードウェアに高価であり、より大きなメモリ構造は\myref{https://en.wikipedia.org/wiki/Static_random-access_memory}{SRAM}として構築されています。
ASICの場合は、メモリコンパイラは、思い出を構築します。
FPGAは、オンチップ・メモリ・ブロックとも呼ばれるブロックRAMが含まれています。
これらのオンチップ・メモリ・ブロックは、より大きいメモリのために組み合わせることができます。
FPGA内のメモリは、通常、1点のリードと1つの書き込みポート、または実行時に読み取りおよび書き込みの間で切り替えることができる2つのポートを有しています。
\fi

\ifshowtranssecond %(校正 TODO)
メモリはChiselでは、レジスタの集まりで\code{Vec}の\code{Reg}を構築することができます。
しかし、これはハードウェアに高価であり、より大きなメモリ構造は\myref{https://en.wikipedia.org/wiki/Static_random-access_memory}{SRAM}として構築されています。
ASICの場合は、メモリコンパイラは、思い出を構築します。
FPGAは、オンチップ・メモリ・ブロックとも呼ばれるブロックRAMが含まれています。
これらのオンチップ・メモリ・ブロックは、より大きいメモリのために組み合わせることができます。
FPGA内のメモリは、通常、1点のリードと1つの書き込みポート、または実行時に読み取りおよび書き込みの間で切り替えることができる2つのポートを有しています。
\fi

\index{Synchronous memory}

\ifshoworiginal
FPGAs (and also ASICs) usually support synchronous memories.
Synchronous memories have registers on their inputs (read and write address, write data,
and write enable). That means the read data is available one clock
cycle after setting the address.
\fi

\ifshowtransfirst %(自動翻訳)
FPGA（ともASICは）通常、同期の思い出をサポートしています。
同期メモリは、その入力（読み取りおよび書き込みアドレス、書き込みデータ、および書き込みが可能）のレジスタを持っています。
ことを意味し、読み出したデータは、アドレスを設定した後に利用できる1クロック・サイクルです。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
FPGA（およびASICも）は通常、同期メモリをサポートしています。
同期メモリは、入力にレジスタを持っています(リードアドレスとライトアドレス、ライトデータ、ライトイネーブル)。
つまり、アドレスを設定してから1クロック後に読み出しデータが利用可能になります。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/memory}
  \caption{A synchronous memory.}
  \label{fig:memory}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:memory} shows the schematics of such a synchronous memory.
The memory is dual-ported with one read port and one write port.
The read port has a single input, the read address (\code{rdAddr}) and
one output, the read data (\code{rdData}).
The write port has three inputs: the address (\code{wrAddr}), the data
to be written (\code{wrData}), and a write enable (\code{wrEna}).
Note that for all inputs, there is a register within the memory showing the
synchronous behavior.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:memory}は、同期メモリの回路図を示しています。
メモリは、1つの読み出しポートと1つの書き込みポートとデュアルポートです。
読み出しポートは、単一の入力を有し、読み出しアドレス（\code{rdAddr}）と1つの出力、リードデータ（\code{rdData}）。
アドレス（\code{wrAddr}）、（\code{wrData}）に書き込まれるデータ、および書き込みは（\code{wrEna}）を有効：ライト・ポートは3つの入力を持っています。
すべての入力のために、同期挙動を示すメモリ内のレジスタがあることに留意されたいです。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:memory}は、同期メモリの回路図を示しています。
メモリは、1つの読み出しポートと1つの書き込みポートとデュアルポートです。
読み出しポートは、単一の入力を有し、読み出しアドレス（\code{rdAddr}）と1つの出力、リードデータ（\code{rdData}）。
アドレス（\code{wrAddr}）、（\code{wrData}）に書き込まれるデータ、および書き込みは（\code{wrEna}）を有効：ライト・ポートは3つの入力を持っています。
すべての入力のために、同期挙動を示すメモリ内のレジスタがあることに留意されたいです。
\fi

\ifshoworiginal
To support on-chip memory, Chisel provides the memory constructor \code{SyncReadMem}.
Listing~\ref{lst:memory} shows a component \code{Memory} that implements
1~KiB of memory with byte-wide input and output data and a write enable.
\fi

\ifshowtransfirst %(自動翻訳)
オンチップ・メモリをサポートするために、Chiselは、メモリコンストラクタ\code{SyncReadMem}を提供します。
一覧〜\ref{lst:memory}はバイト幅の入力データと出力データとの実装メモリの1〜KiBの書き込みを有効にすることをコンポーネント\code{Memory}を示しています。
\fi

\ifshowtranssecond %(校正 TODO)
オンチップ・メモリをサポートするために、Chiselは、メモリコンストラクタ\code{SyncReadMem}を提供します。
一覧〜\ref{lst:memory}はバイト幅の入力データと出力データとの実装メモリの1〜KiBの書き込みを有効にすることをコンポーネント\code{Memory}を示しています。
\fi

\longlist{code/memory.txt}{1\,KiB of synchronous memory.}{lst:memory}

\ifshoworiginal
An interesting question is which value is returned from a read when in the same clock
cycle a new value is written to the same address that is read out.
We are interested in the read-during-write behavior of the memory.
There are three possibilities: the newly written value, the old value, or undefined
(which might be a mix of some bits from the old value and some of the newly written data).
Which possibility is available in an FPGA depends on the FPGA type and
sometimes can be specified.
Chisel documents that the read data is undefined.
\fi

\ifshowtransfirst %(自動翻訳)
興味深い質問は、同じクロック・サイクルで新しい値が読み出され、同じアドレスに書き込まれたとき、読み取りから返される値です。
私たちは、メモリの読み取り時の書き込み動作に興味を持っています。
（古い値と新たに書き込まれたデータの一部からいくつかのビットの組み合わせであるかもしれない）新たに書き込まれた値が、古い値、または未定義：3つの可能性があります。
これは可能性FPGAで利用できるのは、FPGAの種類に依存し、時に指定することができます。
読み出しデータが定義されていないことをChisel文書。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
興味深い質問は、同じクロックサイクルで新しい値が読み出されたのと同じアドレスに書き込まれた場合、どのような値が読み出されて返されるかということです。
私たちは、メモリの読み書き動作に興味を持っています。
新たに書き込まれた値、 古い値、 または未定義( 古い値の一部のビットと新たに書き込まれたデータの一部が混在している可能性がある) の3 つの可能性があります。
どの可能性がFPGA で利用可能かはFPGA のタイプに依存し、指定できる場合もあります。
Chiselは、読み取りデータが未定義であることを指摘します。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/memory-forwarding}
  \caption{A synchronous memory with forwarding for a defined read-during-write behavior.}
  \label{fig:memory:forwarding}
\end{figure}

\index{Data forwarding}

\ifshoworiginal
If we want to read out the newly written value, we can build a forwarding
circuit that detects that the addresses are equal and \emph{forwards} the
write data. Figure~\ref{fig:memory:forwarding} shows the memory with
the forwarding circuit. Read and write addresses are compared and gated with
the write enable to select between the forwarding path of the write data or the
memory read data. The write data is delayed by one clock cycle with a register.
\fi

\ifshowtransfirst %(自動翻訳)
我々は新たに書き込まれた値を読み出したい場合、我々はアドレスは、書き込みデータ等しいと\emph{forwards}されていることを検出することを転送回路を構築することができます。
図〜\ref{fig:memory:forwarding}は、転送回路とメモリを示しています。
読み出しおよび書き込みアドレスは、データを読み取り、書き込みデータの転送経路又はメモリとの間で選択することが可能に比べ書き込みでゲートされます。
書き込みデータは、レジスタと1つのクロックサイクルによって遅延されます。
\fi

\ifshowtranssecond %(校正 TODO)
我々は新たに書き込まれた値を読み出したい場合、我々はアドレスは、書き込みデータ等しいと\emph{forwards}されていることを検出することを転送回路を構築することができます。
図〜\ref{fig:memory:forwarding}は、転送回路とメモリを示しています。
読み出しおよび書き込みアドレスは、データを読み取り、書き込みデータの転送経路又はメモリとの間で選択することが可能に比べ書き込みでゲートされます。
書き込みデータは、レジスタと1つのクロックサイクルによって遅延されます。
\fi

\ifshoworiginal
Listing~\ref{lst:memory:forward} shows the Chisel code for a synchronous memory
including the forwarding circuit. We need to store the write data into a register
(\code{wrDataReg}) to be available in the next clock cycle in order to fit
the synchronous memory that also provides the read value in the next clock
cycle.
We compare the two input addresses (\code{wrAddr} and \code{rdAddr})
and check if \code{wrEna} is true for the forwarding condition.
That condition is also delayed by one clock cycle.
A multiplexer selects between the forwarding (write) data or the read
data from memory.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:memory:forward}は、転送回路を含む同期メモリのChiselコードを示します。
我々はまた、次のクロック・サイクルでの読み出し値を提供し、同期メモリを合わせるために、次のクロックサイクルで利用できるようにするレジスタ（\code{wrDataReg}）への書き込みデータを格納する必要があります。
我々は2つの入力アドレス（\code{wrAddr}と\code{rdAddr}）を比較し、\code{wrEna}は、転送条件に当てはまるかどうかを確認します。
その条件はまた、1つのクロックサイクルによって遅延されます。
転送（書き込み）データ又はメモリから読み出されたデータとの間のマルチプレクサを選択します。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:memory:forward}は、転送回路を含む同期メモリのChiselコードを示します。
我々はまた、次のクロック・サイクルでの読み出し値を提供し、同期メモリを合わせるために、次のクロックサイクルで利用できるようにするレジスタ（\code{wrDataReg}）への書き込みデータを格納する必要があります。
我々は2つの入力アドレス（\code{wrAddr}と\code{rdAddr}）を比較し、\code{wrEna}は、転送条件に当てはまるかどうかを確認します。
その条件はまた、1つのクロックサイクルによって遅延されます。
転送（書き込み）データ又はメモリから読み出されたデータとの間のマルチプレクサを選択します。
\fi

\longlist{code/memory_forwarding.txt}{A memory with a forwarding circuit.}{lst:memory:forward}

\ifshoworiginal
Chisel also provides \code{Mem}, which represents a memory with synchronous
write and an asynchronous read. As this memory type is usually not directly available
in an FPGA, the synthesise tool will build it out of flip-flops.
Therefore, we recommend using \code{SyncReadMem}.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselはまた、同期書き込みと非同期読み出しとメモリを表す\code{Mem}を提供します。
このメモリタイプは、FPGAに通常直接使用できないため、合成ツールは、フリップフロップのそれを構築します。
したがって、我々は\code{SyncReadMem}を使用することをお勧めします。
\fi

\ifshowtranssecond %(校正 TODO)
Chiselはまた、同期書き込みと非同期読み出しとメモリを表す\code{Mem}を提供します。
このメモリタイプは、FPGAに通常直接使用できないため、合成ツールは、フリップフロップのそれを構築します。
したがって、我々は\code{SyncReadMem}を使用することをお勧めします。
\fi

\ifshoworiginal
\section{Exercises}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Exercises}
\fi
\ifshowtranssecond %(校正)
\section{演習 (L6986 7332)}
\fi

\ifshoworiginal
Use the 7-segment encoder from the last exercise and add a 4-bit counter as input
to switch the display from \code{0} to \code{F}. When you directly connect this
counter to the clock of the FPGA board, you will see all 16 numbers
overlapped (all 7 segments will light up).
Therefore, you need to slow down the counting. Create another
counter that can generate a single-cycle \emph{tick} signal every 500 milliseconds.
Use that signal as enable signal for the 4-bit counter.
\fi

\ifshowtransfirst %(自動翻訳)
最後運動から7セグメントエンコーダを使用し\code{F}に\code{0}から表示を切り替えるための入力として4ビットカウンタを追加します。
あなたが直接FPGAボードのクロックにこのカウンタを接続した場合、あなたはすべての16個の数字は、（すべての7つのセグメントが点灯します）重なって表示されます。
そのため、あなたはカウントを遅くする必要があります。
単一サイクル\emph{tick}は500ミリ秒ごとに信号を生成することができます別のカウンタを作成します。
4ビットカウンタのイネーブル信号としてその信号を使用します。
\fi

\ifshowtranssecond %(校正 TODO)
最後運動から7セグメントエンコーダを使用し\code{F}に\code{0}から表示を切り替えるための入力として4ビットカウンタを追加します。
あなたが直接FPGAボードのクロックにこのカウンタを接続した場合、あなたはすべての16個の数字は、（すべての7つのセグメントが点灯します）重なって表示されます。
そのため、あなたはカウントを遅くする必要があります。
単一サイクル\emph{tick}は500ミリ秒ごとに信号を生成することができます別のカウンタを作成します。
4ビットカウンタのイネーブル信号としてその信号を使用します。
\fi

\ifshoworiginal
Construct a PWM waveform with a generator function and set the threshold with a
function (triangular or a sine function).
A triangular function can be created by counting up and down. A sinus function with the
use of a lookup table that you can generate with a few lines of Scala code
(see Section~\ref{sec:gen:comb:logic}).
Drive a LED on an FPGA board with that modulated PWM function. What frequency shall your
PWM signal be? What frequency is the driver running?
\fi

\ifshowtransfirst %(自動翻訳)
発電機能を有するPWM波形を構築し、機能（三角形または正弦関数）としきい値を設定します。
三角関数は、アップとダウンカウントによって作成することができます。
あなたはScalaの数行のコードを生成することができ、ルックアップテーブルを用いて、洞機能（節〜\ref{sec:gen:comb:logic}を参照してください）。
その変調PWM機能をFPGAボード上のLEDを駆動します。
あなたのPWM信号は、どのような周波数でなければなりませんか？ドライバは何周波数を実行していますか？
\fi

\ifshowtranssecond %(校正 TODO)
発電機能を有するPWM波形を構築し、機能（三角形または正弦関数）としきい値を設定します。
三角関数は、アップとダウンカウントによって作成することができます。
あなたはScalaの数行のコードを生成することができ、ルックアップテーブルを用いて、洞機能（節〜\ref{sec:gen:comb:logic}を参照してください）。
その変調PWM機能をFPGAボード上のLEDを駆動します。
あなたのPWM信号は、どのような周波数でなければなりませんか？ドライバは何周波数を実行していますか？
\fi

\ifshoworiginal
Digital designs are often sketched as a circuit on paper. Not all details need to be shown.
We use block diagrams, like in the figures in this book. It is an important skill to be able
to fluently translate between a schematic representation of the circuit and a Chisel description.
Sketch the block diagram for the following circuits:
\fi

\ifshowtransfirst %(自動翻訳)
デジタルデザインは、多くの場合、紙の上の回路として描かれています。
いないすべての詳細が示される必要があります。
私たちは、本書の図のように、ブロック図を使用しています。
流暢回路の概略図とChiselの説明の間で翻訳することができるようにする重要なスキルです。
以下の回路ブロック図をスケッチ：
\fi
\ifshowtranssecond %(校正 6/20 mune10)
デジタル設計は、紙の上に回路としてスケッチすることが多いです。その際に、すべての詳細を示す必要はありません。
本書の図のようにブロック図を使います。
回路を模式的に表現したものと、Chiselの記述との間を流暢に行き来できることが重要なスキルです。
それでは、以下の回路のブロック図をスケッチしてください。
\fi

\shortlist{code/draw_mux6.txt}

\ifshoworiginal
\noindent Here a little bit more complex circuit, containing a register:
\fi

\ifshowtransfirst %(自動翻訳)
レジスタを含むここではもう少し複雑な回路であって、
\fi
\ifshowtranssecond %(校正 6/20 mune10)
\noindent ここでは、レジスタを含むもう少し複雑な回路を紹介します。
\fi

\shortlist{code/draw_acc.txt}

\todo{Luca: More exercises would be nice. Maybe in the future?}

\ifshoworiginal
\chapter{Input Processing}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Input Processing}
\fi
\ifshowtranssecond %(校正)
\chapter{入力処理 (L7452 TODO)}%(校正  第7章  ========================================================================)
\fi

\ifshoworiginal
Input signals from the external world into our synchronous circuit are usually
not synchronous to the clock; they are asynchronous.
An input signal may come from a source that does not have a clean transition from
0 to 1 or 1 to 0. An example is a bouncing button or switch.
Input signals may be noisy with spikes that could trigger a transition in our
synchronous circuit. This chapter describes circuits that deal with such input
conditions.
\fi

\ifshowtransfirst %(自動翻訳)
私たちの同期回路に外界からの入力信号は、通常はクロックに同期していません。彼らは非同期です。
入力信号は、1〜0又は1から0へのクリーンな遷移を有していないソースから来るかもしれません。
例では、バウンスボタンやスイッチです。
入力信号は、我々の同期回路での遷移を引き起こす可能性がスパイクと騒々しいであってもよいです。
この章では、このような入力条件を扱う回路を説明しています。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
外部から同期回路に入力される信号は、通常、クロックに同期しているわけではなく、非同期です。
入力信号は、0から1または1から0へのきれいな遷移を持たないソースから来る場合があります。 例えば、ボタンやスイッチの跳ね返りなどがその例です。
入力信号は、同期回路の遷移のトリガーとなるスパイクを伴うノイズが多い場合があります。
この章では、このような入力条件に対応する回路について説明します。
\fi

\ifshoworiginal
The latter two issues, debouncing switches, and filtering noise, can also be
solved with external, analog components. However, it is more (cost-)efficient
to deal with those issues in the digital domain.
\fi

\ifshowtransfirst %(自動翻訳)
後者の二つの問題、デバウンススイッチ、およびノイズフィルタリングは、外部、アナログコンポーネントと解決することができます。
しかし、それはデジタル領域でこれらの問題に対処するために多くの（費用）効率的です。
\fi

\ifshowtranssecond %(校正 TODO)
後者の二つの問題、デバウンススイッチ、およびノイズフィルタリングは、外部、アナログコンポーネントと解決することができます。
しかし、それはデジタル領域でこれらの問題に対処するために多くの（費用）効率的です。
\fi

\ifshoworiginal
\section{Asynchronous Input}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Asynchronous Input}
\fi
\ifshowtranssecond %(校正)
\section{非同期入力 (L7502 TODO)}
\fi

\index{Asynchronous Input}
\index{Metastability}
\index{非同期入力}
\index{メタステーブル}

\todo{read Dally on this topic to check for correct wording and facts.}

\ifshoworiginal
Input signals that are not synchronous to the system clock are called
asynchronous signals. Those signals may violate the setup and hold time
of the input of a flip-flop. This violation may result in
\myref{https://en.wikipedia.org/wiki/Metastability_(electronics)}{Metastability}
of the flip-flop. The Metastability may result in an output value between 0 and
1 or it may result in oscillation. However, after some time the flip-flop will
stabilize at 0 or 1.
\fi

\ifshowtransfirst %(自動翻訳)
システムクロックに同期していない入力信号は非同期信号と呼ばれています。
これらの信号は、フリップフロップの入力のセットアップおよびホールド時間に違反してもよいです。
この違反は、フリップフロップの\myref{https://en.wikipedia.org/wiki/Metastability_(electronics)}{Metastability}をもたらすことができます。
準安定性は、0と1の間の出力値をもたらすことができるか、発振を生じ得ます。
しかし、いくつかの時間後に、フリップフロップは、0または1で安定します。
\fi

\ifshowtranssecond %(校正 TODO)
システムクロックに同期していない入力信号は非同期信号と呼ばれています。
これらの信号は、フリップフロップの入力のセットアップおよびホールド時間に違反してもよいです。
この違反は、フリップフロップの\myref{https://en.wikipedia.org/wiki/Metastability_(electronics)}{Metastability}をもたらすことができます。
準安定性は、0と1の間の出力値をもたらすことができるか、発振を生じ得ます。
しかし、いくつかの時間後に、フリップフロップは、0または1で安定します。
\fi


\ifshoworiginal
We cannot avoid Metastability, but we can contain its effects.
A classic solution is to use two flip-flops at the input. The assumption is:
when the first flip-flop becomes metastable, it will resolve to a stable
state within the clock period so that the setup and hold times of the
second flip-flop will not be violated.
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、準安定性を回避することはできませんが、我々はその効果を含めることができます。
古典的な溶液は、2個の入力にフリップフロップを使用することです。
仮定がある：第1のフリップフロップがメタステーブルになったときに第2のフリップフロップのセットアップおよびホールドタイムに違反しないように、クロック周期内で安定した状態に解決されます。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
メタスタビリティを回避することはできませんが、その影響を抑えることはできます。
古典的な解決策は、入力に2つのフリップフロップを使用することです。
前提条件は次のとおりです。
1 番目のフリップフロップがメタスタビリティになると、クロック周期内に安定した状態に落ち着き、2 番目のフリップフロップのセットアップ時間とホールド時間が侵害されないようになります。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/synchronizer}
  \caption{Input synchronizer.}
  \label{fig:synchronizer}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:synchronizer} shows the border between the synchronous
circuit and the external world. The input synchronizer consists of
two flip-flops. The Chisel code for the input synchronizer is a one-liner that
instantiates two registers.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:synchronizer}は同期回路と外部世界との間の境界線を示しています。
入力同期は、2つのフリップフロップから構成されています。
入力同期用Chiselのコードは、2つのレジスタをインスタンスワンライナーです。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:synchronizer}は同期回路と外部世界との間の境界線を示しています。
入力同期は、2つのフリップフロップから構成されています。
入力同期用Chiselのコードは、2つのレジスタをインスタンスワンライナーです。
\fi

\shortlist{code/input_sync.txt}

\ifshoworiginal
All asynchronous external signals need an input
synchronizer.\footnote{The exception is when the input signal is dependent
on a synchronous output signal, and we know the maximum propagation delay.
A classic example is the interfacing an asynchronous SRAM
to a synchronous circuit, e.g., by a microprocessor.}
We also need to synchronize an external reset signal. The reset signal
shall pass through the two flip-flops before it is used as the reset signal
for other flip-flops in the circuit. Concrete the de-assertion of the reset need
to be synchronous to the clock.
\fi

\ifshowtransfirst %(自動翻訳)
すべての非同期外部からの信号が入力シンクロナイザを必要としています。
\footnote{入力信号は同期出力信号に依存している場合は例外であり、我々は最大伝播遅延を知っています。古典的な例は、同期回路、例えば非同期SRAMのインタフェースです。グラム。、マイクロプロセッサによる。}
また、外部リセット信号を同期する必要があります。
リセット信号が通過しなければならない2つのフリップフロップは他のリセット信号として使用される前に回路内のフリップフロップ。
クロックに同期するリセットニーズのデアサーションコンクリート。
\fi

\ifshowtranssecond %(校正 TODO)
すべての非同期外部からの信号が入力シンクロナイザを必要としています。
\footnote{入力信号は同期出力信号に依存している場合は例外であり、我々は最大伝播遅延を知っています。古典的な例は、同期回路、例えば非同期SRAMのインタフェースです。グラム。、マイクロプロセッサによる。}
また、外部リセット信号を同期する必要があります。
リセット信号が通過しなければならない2つのフリップフロップは他のリセット信号として使用される前に回路内のフリップフロップ。
クロックに同期するリセットニーズのデアサーションコンクリート。
\fi

\ifshoworiginal
\section{Debouncing}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Debouncing}
\fi
\ifshowtranssecond %(校正)
\section{デバウンス (L7640 TODO)}
\fi

\index{Debouncing}

\ifshoworiginal
Switches and buttons may need some time to transition between on and off.
During the transition, the switch may bounce between those two states.
If we use such a signal without further processing, we might detect more
transition events than we want to. One solution is to use time to filter out
this bouncing. Assuming a maximum bouncing time of $t_{bounce}$ we will sample the
input signals with a period $T > t_{bounce}$. We will only use the
sampled signal further downstream.
\fi

\ifshowtransfirst %(自動翻訳)
スイッチやボタンは、オンとオフの間の遷移にある程度の時間が必要な場合があります。
遷移の間、スイッチは、これら2つの状態の間で跳ね返ることができます。
私たちは、さらに処理せずに、このような信号を使用している場合は、私たちがしたいより多くの遷移イベントを検出することがあります。
一つの解決策は、このバウンスをフィルタリングするために時間を使うことです。
%$ T_ {バウンス}の最大バウンス時間を仮定すると、我々は、期間$ T> T_ {バウンス} $で入力信号をサンプリングします$。
私たちは、さらに下流のサンプリングされた信号を使用します。
\fi

\ifshowtranssecond %(校正 TODO)
スイッチやボタンは、オンとオフの間の遷移にある程度の時間が必要な場合があります。
遷移の間、スイッチは、これら2つの状態の間で跳ね返ることができます。
私たちは、さらに処理せずに、このような信号を使用している場合は、私たちがしたいより多くの遷移イベントを検出することがあります。
一つの解決策は、このバウンスをフィルタリングするために時間を使うことです。
%$ T_ {バウンス}の最大バウンス時間を仮定すると、我々は、期間$ T> T_ {バウンス} $で入力信号をサンプリングします$。
私たちは、さらに下流のサンプリングされた信号を使用します。
\fi

\ifshoworiginal
When sampling the input with this long period, we know that on a transition
from 0 to 1 only one sample may fall into the bouncing region.
The sample before will safely read a 0, and the sample after the bouncing
region will safely read a 1. The sample in the bouncing region will
either be  0 or a 1. However, this does not matter as it then belongs either
to the still 0 samples or to the already 1 samples. The critical point
is that we have only one transition from 0 to 1.
\fi

\ifshowtransfirst %(自動翻訳)
この長い期間での入力をサンプリングする場合、我々は0から1への移行に一つだけのサンプルは、バウンス領域に入り得ることを知っています。
サンプルは、前に安全に0を読みますと、バウンス地域後のサンプルでは、​​安全に1を読み込みます。
バウンス領域におけるサンプルは、0または1のいずれかであろう。
それは、その後、まだ0サンプルに、または既に1サンプルのいずれかに属しているようしかし、これは問題ではありません。
重要な点は、私たちが0から1への1回の遷移のみを持っているということです。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
この長い周期で入力をサンプリングする場合、0 から 1 への遷移時に 1 つのサンプルだけがバウンス領域に落ちる可能性があることがわかっています。
バウンス領域に入る前のサンプルは安全に 0 を読み、バウンシング領域に入った後のサンプルは安全に 1 を読みます。
バウンス領域に入ったサンプルは 0 か 1 のどちらかになりますが、まだ 0 のサンプルか既に 1 のサンプルかのどちらかになるので、これは問題ではありません。
重要なのは、0から1への遷移が1つしかないということです。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/debounce}
  \caption{Debouncing an input signal.}
  \label{fig:debounce}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:debounce} shows the sampling for the debouncing in action.
The top signal shows the bouncing input, and the arrows below show the sampling
points. The distance between those sampling points needs to be longer
than the maximum bouncing time. The first sample safely samples a 0, and the last
sample in the figure samples a 1. The middle sample falls into the
bouncing time. It may either be 0 or 1. The two possible outcomes are
shown as \code{debounce A} and \code{debounce B}.
Both have a single transition from 0 to 1. The only difference between these
two outcomes is that the transition in version B is one sample period later.
However, this is usually a non-issue.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:debounce}はアクションでデバウンスのためのサンプリングを示しています。
トップ信号が示すバウンス入力、及び下矢印はサンプリング点を示します。
これらのサンプリング点間の距離が長く、最大バウンス時間よりもする必要があります。
安全第一のサンプルは、サンプル0を、図サンプル1内の最後のサンプル。
中央のサンプルは、バウンス時に落ちます。
これは、0または1です。
二つの可能な結果は\code{debounce A}と\code{debounce B}として示されています。
両方の0から1への単一の遷移を有します。
これら2つの結果の間の唯一の違いは、バージョンBの遷移は、一つのサンプル期間後であることです。
しかし、これは通常、非問題です。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:debounce}はアクションでデバウンスのためのサンプリングを示しています。
トップ信号が示すバウンス入力、及び下矢印はサンプリング点を示します。
これらのサンプリング点間の距離が長く、最大バウンス時間よりもする必要があります。
安全第一のサンプルは、サンプル0を、図サンプル1内の最後のサンプル。
中央のサンプルは、バウンス時に落ちます。
これは、0または1です。
二つの可能な結果は\code{debounce A}と\code{debounce B}として示されています。
両方の0から1への単一の遷移を有します。
これら2つの結果の間の唯一の違いは、バージョンBの遷移は、一つのサンプル期間後であることです。
しかし、これは通常、非問題です。
\fi

\ifshoworiginal
The Chisel code for the debouncing is a little bit more evolved than the
code for the synchronizer.
We generate the sample timing with a counter that delivers a single
cycle \code{tick} signal, as we have done in Section~\ref{sec:gen:timing}.
\fi

\ifshowtransfirst %(自動翻訳)
デバウンス用Chiselコードがもう少し進化シンクロナイザのコードよりなります。
私たちは、セクション〜\ref{sec:gen:timing}に行ったように、単一サイクル\code{tick}信号を出力するカウンタとサンプルタイミングを生成します。
\fi

\ifshowtranssecond %(校正 TODO)
デバウンス用Chiselコードがもう少し進化シンクロナイザのコードよりなります。
私たちは、セクション〜\ref{sec:gen:timing}に行ったように、単一サイクル\code{tick}信号を出力するカウンタとサンプルタイミングを生成します。
\fi

\shortlist{code/input_fac.txt}
\shortlist{code/input_debounce.txt}

\ifshoworiginal
First, we need to decide on the sampling frequency. The above example
assumes a 100~MHz clock and results in a sampling frequency of 100~Hz
(assuming that the bouncing time is below 10~ms). The maximum
counter value is \code{FAC}, the division factor.
We define a register \code{btnDebReg} for the debounced signal,
without a reset value. The register \code{cntReg} serves
as counter, and the \code{tick} signal is true when the counter has
reached the maximum value. In that case, the \code{when} condition
is \code{true} and (1) the counter is reset to 0 and (2) the debounce
register stores the input sample. In our example, the input signal is named
\code{btnSync} as it is the output from the input synchronizer shown
in the previous section.
\fi

\ifshowtransfirst %(自動翻訳)
まず、サンプリング周波数を決定する必要があります。
上記の例は、（バウンス時間は10〜ミリ秒未満であることを仮定して）100〜[Hz]のサンプリング周波数で100〜MHzクロックと結果を想定しています。
最大カウンタ値は\code{FAC}、分割係数です。
私たちは、リセット値なし、デバウンス信号用レジスタ\code{btnDebReg}を定義します。
レジスタ\code{cntReg}カウンタとして機能し、カウンタが最大値に達したときに\code{tick}信号が真です。
その場合、\code{when}条件は、カウンタが0と（2）デバウンスレジスタは入力サンプルにリセットさ\code{true}と（1）です。
それは前のセクションで示した入力同期から出力されるようにこの例では、入力信号が\code{btnSync}命名されます。
\fi

\ifshowtranssecond %(校正 TODO)
まず、サンプリング周波数を決定する必要があります。
上記の例は、（バウンス時間は10〜ミリ秒未満であることを仮定して）100〜[Hz]のサンプリング周波数で100〜MHzクロックと結果を想定しています。
最大カウンタ値は\code{FAC}、分割係数です。
私たちは、リセット値なし、デバウンス信号用レジスタ\code{btnDebReg}を定義します。
レジスタ\code{cntReg}カウンタとして機能し、カウンタが最大値に達したときに\code{tick}信号が真です。
その場合、\code{when}条件は、カウンタが0と（2）デバウンスレジスタは入力サンプルにリセットさ\code{true}と（1）です。
それは前のセクションで示した入力同期から出力されるようにこの例では、入力信号が\code{btnSync}命名されます。
\fi

\ifshoworiginal
The debouncing circuit comes after the synchronizer circuit.
First, we need to synchronize in the asynchronous signal, then
we can further process it in the digital domain.
\fi

\ifshowtransfirst %(自動翻訳)
デバウンス回路は、同期回路の後に来ます。
まず、我々は、我々はさらにデジタル領域でそれを処理することができ、非同期信号に同期させる必要があります。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
デバウンス回路はシンクロナイザ回路の後に来ます。
まず、非同期信号を同期させてから、デジタルドメインで処理します。
\fi

\ifshoworiginal
\section{Filtering of the Input Signal}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Filtering of the Input Signal}
\fi
\ifshowtranssecond %(校正)
\section{ 入力信号のフィルタリング (L7820 TODO)}
\fi

\index{Majority voting}

\ifshoworiginal
Sometimes our input signal may be noisy, maybe containing spikes
that we might sample unintentionally with the input synchronizer and
debouncing unit.
One option to filter those input spikes is to use a majority voting
circuit. In the simplest case, we take three samples and perform
the majority vote. The \myref{https://en.wikipedia.org/wiki/Majority_function}{majority function},
which is related to the median function, results in the value of the majority.
In our case, where we use sampling for the debouncing, we perform the
majority voting on the sampled signal.
Majority voting ensures that the signal is stable for longer than the sampling period.
\fi

\ifshowtransfirst %(自動翻訳)
時々、私たちの入力信号は、多分私達は、入力同期とデバウンス単位で意図せずにサンプリング可能性があるスパイクを含む、うるさいかもしれません。
それらの入力スパイクをフィルタリングするための1つのオプションは、多数決回路を使用することです。
最も単純なケースでは、我々は三つのサンプルを取り、多数決を行います。
中央値関数に関連する\myref{https://en.wikipedia.org/wiki/Majority_function}{majority function}は、大部分の値になります。
私たちはデバウンスのためのサンプリングを使用我々のケースでは、我々は、サンプリングされた信号の多数決を行います。
信号がサンプリング周期よりも長いため安定していることを多数決保証します。
\fi

\ifshowtranssecond %(校正 TODO)
時々、私たちの入力信号は、多分私達は、入力同期とデバウンス単位で意図せずにサンプリング可能性があるスパイクを含む、うるさいかもしれません。
それらの入力スパイクをフィルタリングするための1つのオプションは、多数決回路を使用することです。
最も単純なケースでは、我々は三つのサンプルを取り、多数決を行います。
中央値関数に関連する\myref{https://en.wikipedia.org/wiki/Majority_function}{majority function}は、大部分の値になります。
私たちはデバウンスのためのサンプリングを使用我々のケースでは、我々は、サンプリングされた信号の多数決を行います。
信号がサンプリング周期よりも長いため安定していることを多数決保証します。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/majority}
  \caption{Majority voting on the sampled input signal.}
  \label{fig:majority}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:majority} shows the circuit of the majority voter.
It consists of a 3-bit shift register enabled by the \code{tick} signal
we used for the debouncing sampling. The output of the three registers
is feed into the majority voting circuit. The majority voting function filters
any signal change shorter than the sample period.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:majority}は、大多数の有権者の回路を示しています。
これは、レジスタは、我々がデバウンスサンプリングに使用\code{tick}信号によってイネーブル3ビットのシフトで構成されています。
3つのレジスタの出力は、多数決回路に供給されます。
多数決関数は、サンプル期間よりも短い任意の信号変化をフィルタリングします。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:majority}は、大多数の有権者の回路を示しています。
これは、レジスタは、我々がデバウンスサンプリングに使用\code{tick}信号によってイネーブル3ビットのシフトで構成されています。
3つのレジスタの出力は、多数決回路に供給されます。
多数決関数は、サンプル期間よりも短い任意の信号変化をフィルタリングします。
\fi

\ifshoworiginal
The following Chisel code shows the 3-bit shift register, enabled by the
\code{tick} signal and the voting function, resulting in the signal \code{btnClean}.
\fi

\ifshowtransfirst %(自動翻訳)
以下Chiselコード示す3ビットのシフトレジスタ、信号\code{btnClean}その結果、\code{tick}信号と投票機能により可能となりました。
\fi

\ifshowtranssecond %(校正 TODO)
以下Chiselコード示す3ビットのシフトレジスタ、信号\code{btnClean}その結果、\code{tick}信号と投票機能により可能となりました。
\fi

\ifshoworiginal
Note, that a majority voting is very seldom needed.
\fi

\ifshowtransfirst %(自動翻訳)
多数決はほとんど必要ありませんので、注意してください。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
多数決は非常にまれであることに注意してください。
\fi

\shortlist{code/input_majority.txt}

\ifshoworiginal
To use the output of our carefully processed input signal, we first detect
the rising edge with a \code{RegNext} delay element and then compare this
signal with the current value of \code{btnClean} to enable the counter to increment.
\fi

\ifshowtransfirst %(自動翻訳)
当社慎重に処理された入力信号の出力を使用するには、まず\code{RegNext}遅延素子との立ち上がりエッジを検出し、その後増加にカウンターを有効にするために\code{btnClean}の現在の値と、この信号を比較します。
\fi

\ifshowtranssecond %(校正 TODO)
当社慎重に処理された入力信号の出力を使用するには、まず\code{RegNext}遅延素子との立ち上がりエッジを検出し、その後増加にカウンターを有効にするために\code{btnClean}の現在の値と、この信号を比較します。
\fi

\index{Edge detection}

\shortlist{code/input_usage.txt}

\ifshoworiginal
\section{Combining the Input Processing with Functions}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Combining the Input Processing with Functions}
\fi
\ifshowtranssecond %(校正)
\section{入力処理と関数の組み合わせ (L7936 TODO)}
\fi

\ifshoworiginal
To summarize the input processing, we show some more Chisel code.
As the presented circuits might be tiny, but reusable building blocks, we encapsulate
them in functions. Section~\ref{sec:functions} showed how we can abstract
small building blocks in lightweight Chisel functions instead of full modules.
Those Chisel functions create hardware instances, e.g., the function
\code{sync} creates two flip-flops connected to the input and to each other.
The function returns the output of the second flip-flop.
If useful, those functions can be elevated to some utility class object.
\fi

\ifshowtransfirst %(自動翻訳)
入力処理を要約すると、我々はいくつかのより多くのChiselのコードを示しています。
提示回路は小さなことが、再利用可能なビルディング・ブロックかもしれませんが、我々は機能でそれらをカプセル化します。
節〜\ref{sec:functions}ではなく、完全なモジュールの軽量リグ機能でどのように我々はできる、抽象小さなビルディングブロックを示しました。
これらのリグ機能は、電子をハードウェアのインスタンスを作成します。
グラム。
、機能\code{sync}は、2個の入力に、互いに接続されたフリップフロップ作成します。
関数は、第2のフリップフロップの出力を返します。
便利な場合は、それらの機能は、いくつかのユーティリティクラスオブジェクトに上昇させることができます。
\fi

\ifshowtranssecond %(校正 TODO)
入力処理を要約すると、我々はいくつかのより多くのChiselのコードを示しています。
提示回路は小さなことが、再利用可能なビルディング・ブロックかもしれませんが、我々は機能でそれらをカプセル化します。
節〜\ref{sec:functions}ではなく、完全なモジュールの軽量リグ機能でどのように我々はできる、抽象小さなビルディングブロックを示しました。
これらのリグ機能は、電子をハードウェアのインスタンスを作成します。
グラム。
、機能\code{sync}は、2個の入力に、互いに接続されたフリップフロップ作成します。
関数は、第2のフリップフロップの出力を返します。
便利な場合は、それらの機能は、いくつかのユーティリティクラスオブジェクトに上昇させることができます。
\fi

\longlist{code/input_func.txt}{Summarizing input processing with functions.}{lst:input:func}

\ifshoworiginal
\section{Exercise}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Exercise}
\fi
\ifshowtranssecond %(校正)
\section{演習 (L7981 DONE)}
\fi

\ifshoworiginal
Build a counter that is incremented by an input button.
Display the counter value in binary with the LEDs on an FPGA board.
Build the complete input processing chain with: (1) an input synchronizer,
(2) a debouncing circuit, (3) a majority voting circuit to suppress noise,
and (4) an edge detection circuit to trigger the increment of the counter.
\fi

\ifshowtransfirst %(自動翻訳)
入力ボタンでインクリメントされるカウンタを作成します。
FPGAボード上のLEDを有するバイナリカウンタの値を表示します。
カウンタのインクリメントをトリガするために、（1）入力同期、（2）デバウンス回路、（3）を抑制ノイズに対する多数決回路、及び（4）エッジ検出回路：完全入力処理チェーンとを構築します。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
入力ボタンでインクリメントされるカウンタを構築します。
FPGAボード上のLEDでカウンタの値をバイナリで表示します。
入力処理チェーン全体を構築する。(1)入力同期回路、(2)デバウンス回路、(3)ノイズを抑制する多数決回路、(4)カウンタのインクリメントをトリガーとするエッジ検出回路、を備えた入力処理チェーンを構築します。
\fi

\ifshoworiginal
As there is no guarantee that modern button will always bounce, you can
simulate the bouncing and the spikes by pressing the button manually in a fast succession
and using a low sample frequency. Select, e.g., one second as sample frequency,
i.e., if the input clock runs at 100~MHz, divide it by 100,000,000.
Simulate a bouncing button by pressing several times in fast succession
before settling to a stable press. Test your circuit without and with the
debouncing circuit sampling at 1~Hz.
With the majority voting, you need to press between one and two seconds
for a reliable increment of the counter. Also, the release of the button is
majority voted. Therefore, the circuit only recognizes the release when it is
longer than 1--2 seconds.
\fi


\ifshowtransfirst %(自動翻訳)
現代のボタンは常にバウンスするという保証はありません、あなたは速い連続で手動ボタンを押すと、低サンプル周波数を使用してバウンスやスパイクをシミュレートすることができます。
、Eを選択します。
グラム。
、サンプル周波数と一秒、I。
え。
入力クロックは100〜MHzで動作している場合、100,000,000で割り。
安定したプレスにセトリングする前に速い連続して数回押して、バウンスボタンをシミュレートします。
なしと1〜Hzでデバウンス回路のサンプリングを使用して回路をテストします。
多数決を使用すると、カウンタの信頼性の増加のために1〜2秒の間押す必要があります。
また、ボタンのリリースは、過半数が投票しています。
それは1--2秒よりも長いときにそのため、回路にのみリリースを認識します。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
最近のボタンは必ず跳ね返るという保証はありませんので、手動でボタンを高速で連続して押し、低いサンプル周波数を使用することで、跳ね返りやスパイクをシミュレートすることができます。
サンプル周波数としては、例えば1秒を選択してください。
ボタンを数回連続で押すことで、ボタンの跳ね返りをシミュレートする。
安定したプレスに落ち着く前に、回路をテストしてください。
1~Hzでサンプリングしたデバウンス回路を使用しない場合と使用した場合の回路をテストします。
多数決では、カウンターの確実なインクリメントには1秒から2秒の間に押す必要があります。
また、ボタンのリリースも多数決です。そのため、回路は1～2秒より長い場合にのみリリースを認識します。
\fi

\ifshoworiginal
\chapter{Finite-State Machines}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Finite-State Machines}
\fi
\ifshowtranssecond %(校正)
\chapter{有限状態機械（FSM）(L8048 TODO)}%(校正  第8章  ========================================================================)
\fi

\index{Finite-state machine}
\index{FSM}
\index{Synchronous sequential circuit}
\index{有限状態機械}
\index{有限オートマトン}

\ifshoworiginal
A finite-state machine (FSM) is a basic building block in digital design.
An FSM can be described as a set of \emph{states} and conditional (guarded)
\emph{state transitions} between states.
An FSM has an initial state, which is set on reset.
FSMs are also called synchronous sequential circuits.
\fi

\ifshowtransfirst %(自動翻訳)
有限状態機械（FSM）は、デジタル設計の基本的なビルディング・ブロックです。
AN FSMは状態間\emph{states}のセットと条件（ガード）\emph{state transitions}として説明することができます。
アンFSMは、リセット時に設定された初期状態を、持っています。
FSMは、同期順序回路と呼ばれています。
\fi

\ifshowtranssecond %(校正 TODO)
有限状態機械（FSM）は、デジタル設計の基本的なビルディング・ブロックです。
AN FSMは状態間\emph{states}のセットと条件（ガード）\emph{state transitions}として説明することができます。
アンFSMは、リセット時に設定された初期状態を、持っています。
FSMは、同期順序回路と呼ばれています。
\fi

\ifshoworiginal
An implementation of an FSM consists of three parts: (1) a register that holds the current state,
(2) combinational logic that computes the next state that depends on the current
state and the input, and (3) combinational logic that computes the output of the FSM.
\fi

\ifshowtransfirst %(自動翻訳)
（1）現在の状態を保持するレジスタ、（2）現在の状態と入力に依存する次の状態を計算し、組合せ論理、および計算（3）組み合わせ論理：FSMの実装は、3つの部分から構成さFSMの出力。
\fi

\ifshowtranssecond %(校正 TODO)
（1）現在の状態を保持するレジスタ、（2）現在の状態と入力に依存する次の状態を計算し、組合せ論理、および計算（3）組み合わせ論理：FSMの実装は、3つの部分から構成さFSMの出力。
\fi

\ifshoworiginal
In principle, every digital circuit that contains a register or other memory elements
to store state can be described as a single FSM. However, this might
not be practical, e.g., try to describe your laptop as a single FSM.
In the next chapter, we describe how to build larger systems
out of smaller FSMs by combining them into communicating FSMs.
\fi

\ifshowtransfirst %(自動翻訳)
原理的には、格納状態にレジスタまたは他のメモリ要素を含むすべてのデジタル回路は、単一のFSMとして記述することができます。
しかし、これは、電子実用的ではないかもしれません。
グラム。
、単一FSMとしてあなたのラップトップを記述してみてください。
次の章では、FSMの通信にそれらを組み合わせることにより、より小さなのFSMのうち、大規模なシステムを構築する方法について説明します。
\fi

\ifshowtranssecond %(校正 TODO)
原理的には、格納状態にレジスタまたは他のメモリ要素を含むすべてのデジタル回路は、単一のFSMとして記述することができます。
しかし、これは、電子実用的ではないかもしれません。
グラム。
、単一FSMとしてあなたのラップトップを記述してみてください。
次の章では、FSMの通信にそれらを組み合わせることにより、より小さなのFSMのうち、大規模なシステムを構築する方法について説明します。
\fi

\ifshoworiginal
\section{Basic Finite-State Machine}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Basic Finite-State Machine}
\fi
\ifshowtranssecond %(校正)
\section{  有限状態機械の基本 (L8124 TODO)}
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/fsm}
  \caption{A finite state machine (Moore type).}
  \label{fig:fsm}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:fsm} shows the schematics of an FSM. The register contains the current \code{state}.
The next state logic computes the next state value (\code{next\_state})
from the current \code{state} and the input (\code{in}).
On the next clock tick, \code{state} becomes \code{next\_state}.
The output logic computes the output (\code{out}). As the output depends on the current
state only, this state machine is called a
\myref{https://en.wikipedia.org/wiki/Moore_machine}{Moore machine}.
\fi

\index{Finite-State Machine!Moore}

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:fsm}は、FSMの回路図を示しています。
レジスタは、現在の\code{state}が含まれています。
次の状態の論理は、現在\code{state}と入力（\code{in}）から次の状態値（\code{next\_state}）を算出します。
次のクロックチックで、\code{state}は\code{next\_state}になります。
出力論理は、出力（\code{out}）を計算します。
出力は現在の状態のみに依存したように、このステートマシンは\myref{https://en.wikipedia.org/wiki/Moore_machine}{Moore machine}と呼ばれています。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:fsm}は、FSMの回路図を示しています。
レジスタは、現在の\code{state}が含まれています。
次の状態の論理は、現在\code{state}と入力（\code{in}）から次の状態値（\code{next\_state}）を算出します。
次のクロックチックで、\code{state}は\code{next\_state}になります。
出力論理は、出力（\code{out}）を計算します。
出力は現在の状態のみに依存したように、このステートマシンは\myref{https://en.wikipedia.org/wiki/Moore_machine}{Moore machine}と呼ばれています。
\fi

\ifshoworiginal
A \myref{https://en.wikipedia.org/wiki/State_diagram}{state diagram}
describes the behavior of such an FSM visually.
In a state diagram, individual states are depicted as circles labeled
with the state names.
State transitions are shown with arrows between states.
The guard (or condition) when this transition is taken is drawn as a label
for the arrow.
\fi

\ifshowtransfirst %(自動翻訳)
A \myref{https://en.wikipedia.org/wiki/State_diagram}{state diagram}は、視覚的なFSMの動作について説明します。
状態図では、個々の状態は、状態名で標識された円として示されています。
状態遷移は、状態間の矢印で示されています。
この遷移が行われるガード（または状態）は矢印のラベルとして描かれています。
\fi

\ifshowtranssecond %(校正 TODO)
A \myref{https://en.wikipedia.org/wiki/State_diagram}{state diagram}は、視覚的なFSMの動作について説明します。
状態図では、個々の状態は、状態名で標識された円として示されています。
状態遷移は、状態間の矢印で示されています。
この遷移が行われるガード（または状態）は矢印のラベルとして描かれています。
\fi

\index{State diagram}

\ifshoworiginal
Figure~\ref{fig:diag-moore} shows the state diagram of a simple example FSM.
The FSM has three states: \emph{green}, \emph{orange}, and \emph{red},
indicating a level of alarm. The FSM starts at the \emph{green} level.
When a \emph{bad event} happens the alarm level is switched to \emph{orange}.
On a second bad event, the alarm level is switched to \emph{red}.
In that case, we want to ring a bell; \emph{ring bell} is the only output of this FSM.
We add the output to the \emph{red} state.
The alarm can be reset with a \emph{clear} signal.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:diag-moore}は、単純な例のFSMの状態図を示します。
\emph{green}、\emph{orange}、及び\emph{red}、警報のレベルを示す：FSMは、三つの状態を有します。
FSMは\emph{green}レベルで開始します。
\emph{bad event}が発生するとアラームレベルは\emph{orange}に切り替えています。
二悪いイベントでは、警報レベルは\emph{red}に切り替えています。
その場合には、我々は、鐘を鳴らしたいです。 \emph{ring bell}はこのFSMの出力のみです。
私たちは、\emph{red}状態に出力を追加します。
アラームは\emph{clear}信号とリセットすることができます。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:diag-moore}は、単純な例のFSMの状態図を示します。
\emph{green}、\emph{orange}、及び\emph{red}、警報のレベルを示す：FSMは、三つの状態を有します。
FSMは\emph{green}レベルで開始します。
\emph{bad event}が発生するとアラームレベルは\emph{orange}に切り替えています。
二悪いイベントでは、警報レベルは\emph{red}に切り替えています。
その場合には、我々は、鐘を鳴らしたいです。 \emph{ring bell}はこのFSMの出力のみです。
私たちは、\emph{red}状態に出力を追加します。
アラームは\emph{clear}信号とリセットすることができます。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/state-diag-moore}
  \caption{The state diagram of an alarm FSM.}
  \label{fig:diag-moore}
\end{figure}

\ifshoworiginal
Although a state diagram may be visually pleasing and the function of an FSM
can be grasped quickly, a state table may be quicker to write down.
Table~\ref{tab:state:table} shows the state table for our alarm FSM.
We list the current state, the input values, the resulting next state, and
the output value for the current state. In principle, we would need to
specify all possible inputs for all possible states. This table would have
$3 \times 4 = 12$ rows. We simplify the table by indicating that the \emph{clear}
input is a don't care when a \emph{bad event} happens. That means
\emph{bad event} has priority over \emph{clear}. The output column
has some repetition. If we have a larger FSM and/or more outputs, we
can split the table into two, one for the next state logic and one for the
output logic.
\fi

\ifshowtransfirst %(自動翻訳)
状態図は、視覚的に満足することができ、FSMの機能を迅速に把握することができるが、状態テーブルは書き留めて速くすることができます。
表〜\ref{tab:state:table}は、私たちのアラームFSMの状態テーブルを示しています。
我々は、現在の状態、入力値の、結果として得られる次の状態、および現在の状態に対する出力値をリストします。
原則として、我々はすべての可能な状態のすべての可能な入力を指定する必要があります。
%このテーブルには、$ 3 \回4 = 12 $の行を持っているでしょう。
私たちは、\emph{clear}入力が\emph{bad event}が発生したときに気にしないであることを示すことにより、テーブルを簡素化します。
手段\emph{bad event}は\emph{clear}に優先を持っていること。
出力列には、いくつかの繰り返しを持っています。
我々は、より大きなFSM及び/又は複数の出力がある場合、我々は2つの次の状態ロジック用と出力論理のための1つにテーブルを分割することができます。
\fi

\ifshowtranssecond %(校正 TODO)
状態図は、視覚的に満足することができ、FSMの機能を迅速に把握することができるが、状態テーブルは書き留めて速くすることができます。
表〜\ref{tab:state:table}は、私たちのアラームFSMの状態テーブルを示しています。
我々は、現在の状態、入力値の、結果として得られる次の状態、および現在の状態に対する出力値をリストします。
原則として、我々はすべての可能な状態のすべての可能な入力を指定する必要があります。
%このテーブルには、$ 3 \回4 = 12 $の行を持っているでしょう。
私たちは、\emph{clear}入力が\emph{bad event}が発生したときに気にしないであることを示すことにより、テーブルを簡素化します。
手段\emph{bad event}は\emph{clear}に優先を持っていること。
出力列には、いくつかの繰り返しを持っています。
我々は、より大きなFSM及び/又は複数の出力がある場合、我々は2つの次の状態ロジック用と出力論理のための1つにテーブルを分割することができます。
\fi

\begin{table}
\centering
\caption{State table for the alarm FSM.}
\begin{tabular}{ccccc}
\toprule
& \multicolumn{2}{c}{Input} \\
\cmidrule{2-3}
State &  Bad event & Clear & Next state & Ring bell \\
\midrule
green & 0 & 0 & green & 0 \\
green & 1 & - & orange & 0 \\
orange & 0 & 0 & orange & 0 \\
orange & 1 & - & red & 0 \\
orange & 0 & 1 & green & 0 \\
red & 0 & 0 & red & 1 \\
red & 0 & 1 & green & 1 \\
\bottomrule
\end{tabular}
\label{tab:state:table}
\end{table}


\ifshoworiginal
Finally, after all the design of our warning level FSM, we shall code it in Chisel.
Listing~\ref{lst:fsm:alarm} shows the Chisel code for the alarm FSM.
Note, that we use the Chisel type \code{Bool} for the inputs and the
output of the FSM.
To use \code{Enum} and the \code{switch} control instruction, we need to
import \code{chisel3.util.\_}.
\fi

\ifshowtransfirst %(自動翻訳)
最後に、私たちの警告レベルのFSMのすべての設計した後、我々は、Chiselでそれをコーディングするものとします。
一覧〜\ref{lst:fsm:alarm}は、アラームFSMのためのChiselコードを示します。
注意、我々は入力用Chiselタイプ\code{Bool}とFSMの出力を使用すること。
\code{Enum}と\code{switch}制御命令を使用するために、我々は\code{chisel3.util.\_}をインポートする必要があります。
\fi

\ifshowtranssecond %(校正 TODO)
最後に、私たちの警告レベルのFSMのすべての設計した後、我々は、Chiselでそれをコーディングするものとします。
一覧〜\ref{lst:fsm:alarm}は、アラームFSMのためのChiselコードを示します。
注意、我々は入力用Chiselタイプ\code{Bool}とFSMの出力を使用すること。
\code{Enum}と\code{switch}制御命令を使用するために、我々は\code{chisel3.util.\_}をインポートする必要があります。
\fi

\longlist{code/simple_fsm.txt}{The Chisel code for the alarm FSM.}{lst:fsm:alarm}


\ifshoworiginal
The complete Chisel code for this simple FSM fits into one page.
Let us step through the individual parts.
The FSM has two input and a single output signal, captured in a Chisel \code{Bundle}:
%
\fi

\ifshowtransfirst %(自動翻訳)
1ページに、この単純なFSMフィットのための完全なChiselコード。
私たちは、個々の部品をステップ実行してみましょう。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
このシンプルなFSMのための完全なチゼルコードは1ページに収まっています。
個々の部分を順を追って見ていきましょう。
FSMは2つの入力と1つの出力信号を持っています。Chisel \code{Bundle}でキャプチャされています。
\fi

\shortlist{code/simple_fsm_io.txt}

\ifshoworiginal
\noindent Quite some work has been spent in optimal state encoding. Two common options
are binary or one-hot encoding. However, we leave those low-level decisions to
the synthesize tool and aim for readable code.\footnote{In the current version
of Chisel the \code{Enum} type represents states in binary encoding.
If we want a different encoding, e.g., one-hot encoding, we can define Chisel
constants for the state names.}
Therefore, we use an enumeration type with symbolic names for the states:
\fi

\ifshowtransfirst %(自動翻訳)
かなりの作業が最適な状態エンコーディングに費やされました。
二つの一般的なオプションは、バイナリまたはワンホットエンコーディングです。
しかし、我々はのsynthesizeツールにこれらの低レベルの意思決定を残して、読みやすいコードを目指します。
Chisel\code{Enum}タイプの現在のバージョンで
\footnote{バイナリエンコーディングの状態を表しています。我々は別のエンコーディングを使用する場合は、電子。グラム。、ワンホットエンコーディング、我々は状態名のChisel定数を定義することができます。}
したがって、我々は状態のシンボリック名を列挙型を使用します。
\fi

\ifshowtranssecond %(校正 TODO)
かなりの作業が最適な状態エンコーディングに費やされました。
二つの一般的なオプションは、バイナリまたはワンホットエンコーディングです。
しかし、我々はのsynthesizeツールにこれらの低レベルの意思決定を残して、読みやすいコードを目指します。
Chisel\code{Enum}タイプの現在のバージョンで
\footnote{バイナリエンコーディングの状態を表しています。我々は別のエンコーディングを使用する場合は、電子。グラム。、ワンホットエンコーディング、我々は状態名のChisel定数を定義することができます。}
したがって、我々は状態のシンボリック名を列挙型を使用します。
\fi

\shortlist{code/simple_fsm_states.txt}

\ifshoworiginal
\noindent The individual state values are described as a list where the individual
elements are concatenated with the \code{::} operator; \code{Nil} represents
the end of the list. An \code{Enum} instance is \emph{assigned} to the list of states.
The register holding the state is defined with the \emph{green} state as the reset value:
\fi

\ifshowtransfirst %(自動翻訳)
個々の状態値は、個々の要素は\code{::}演算子で連結されたリストとして記述されています。 \code{Nil}は、リストの最後を表します。
\code{Enum}インスタンスは、状態のリストに\emph{assigned}です。
状態を保持するレジスタをリセット値として\emph{green}状態と定義されます。
\fi

\ifshowtranssecond %(校正 TODO)
個々の状態値は、個々の要素は\code{::}演算子で連結されたリストとして記述されています。 \code{Nil}は、リストの最後を表します。
\code{Enum}インスタンスは、状態のリストに\emph{assigned}です。
状態を保持するレジスタをリセット値として\emph{green}状態と定義されます。
\fi

\shortlist{code/simple_fsm_register.txt}

\ifshoworiginal
\noindent The meat of the FSM is in the next state logic. We use a Chisel switch on the
state register to cover all states. Within each \code{is} branch we code the next state
logic, which depends on the inputs, by assigning a new value for our state register:
\fi

\ifshowtransfirst %(自動翻訳)
FSMの肉は、次の状態論理です。
我々は、すべての州をカバーするために、状態レジスタにChiselスイッチを使用します。
各\code{is}支店内で私達は私達の状態レジスタに新しい値を割り当てることによって、入力に依存して次の状態ロジックを、コード：
\fi

\ifshowtranssecond %(校正 TODO)
FSMの肉は、次の状態論理です。
我々は、すべての州をカバーするために、状態レジスタにChiselスイッチを使用します。
各\code{is}支店内で私達は私達の状態レジスタに新しい値を割り当てることによって、入力に依存して次の状態ロジックを、コード：
\fi

\shortlist{code/simple_fsm_next.txt}

\ifshoworiginal
\noindent Last, but not least, we code our \emph{ringing bell} output to be true when
the state is \emph{red}.
\fi

\ifshowtransfirst %(自動翻訳)
状態が\emph{red}ときに最後には、ではなく、少なくとも、私たちは\emph{ringing bell}出力が真であることをコーディングします。
\fi

\ifshowtranssecond %(校正 TODO)
状態が\emph{red}ときに最後には、ではなく、少なくとも、私たちは\emph{ringing bell}出力が真であることをコーディングします。
\fi

\shortlist{code/simple_fsm_output.txt}

\ifshoworiginal
Note that we did \emph{not} introduce a \code{next\_state} signal for the register input,
as it is common practice in Verilog or VHDL.
Registers in Verilog and VHDL are described in a special syntax and cannot
be assigned (and reassigned) within a combinational block.
Therefore, the additional signal, computed in a combinational block, is
introduced and connected to the register input.
In Chisel a register is a base type and can be freely used within a combinational block.
\fi

\ifshowtransfirst %(自動翻訳)
それはVerilogまたはVHDLで一般的に行われているとして、我々は、レジスタの入力に\code{next\_state}信号を\emph{not}導入しなかったことに注意してください。
VerilogおよびVHDLのレジスタは、特別な構文に記載されており、組み合わせブロック内で割り当てられた（及び再割り当て）することができません。
したがって、組合せブロックで計算付加信号は、導入及びレジスタ入力に接続されています。
Chiselのレジスタは、基本型であり、自由に組み合わせたブロック内で使用することができます。
\fi

\ifshowtranssecond %(校正 TODO)
それはVerilogまたはVHDLで一般的に行われているとして、我々は、レジスタの入力に\code{next\_state}信号を\emph{not}導入しなかったことに注意してください。
VerilogおよびVHDLのレジスタは、特別な構文に記載されており、組み合わせブロック内で割り当てられた（及び再割り当て）することができません。
したがって、組合せブロックで計算付加信号は、導入及びレジスタ入力に接続されています。
Chiselのレジスタは、基本型であり、自由に組み合わせたブロック内で使用することができます。
\fi

\ifshoworiginal
\section{Faster Output with a Mealy FSM}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Faster Output with a Mealy FSM}
\fi
\ifshowtranssecond %(校正)
\section{ミーリー FSMで出力を高速化 (L78454 TODO)}
\fi

\ifshoworiginal
On a Moore FSM, the output depends only on the current state.
That means that a change of an input can be seen as a change of the
output \emph{earliest} in the next clock cycle.
If we want to observe an immediate change, we need a combinational
path from the input to the output.
Let us consider a minimal example, an edge detection circuit.
We have seen this Chisel one-liner before:
\fi

\ifshowtransfirst %(自動翻訳)
ムーアFSMでは、出力は現在の状態に依存します。
入力の変化は、次のクロックサイクルにおいて出力\emph{earliest}の変化として見ることができることを意味します。
我々はすぐに変化を観察したい場合は、我々は、入力から出力への組み合わせパスが必要です。
私たちは、最小限の例では、エッジ検出回路を考えてみましょう。
我々は前にこのリグワンライナーを見てきました：
\fi

\ifshowtranssecond %(校正 TODO)
ムーアFSMでは、出力は現在の状態に依存します。
入力の変化は、次のクロックサイクルにおいて出力\emph{earliest}の変化として見ることができることを意味します。
我々はすぐに変化を観察したい場合は、我々は、入力から出力への組み合わせパスが必要です。
私たちは、最小限の例では、エッジ検出回路を考えてみましょう。
我々は前にこのリグワンライナーを見てきました：
\fi

\shortlist{code/sequ_reg_rising.txt}

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/fsm-rising}
  \caption{A rising edge detector (Mealy type FSM).}
  \label{fig:fsm-rising}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:fsm-rising} shows the schematic of the rising edge detector.
The output becomes 1 for one clock cycle when the current input is 1
and the input in the last clock cycle was 0.
The state register is just a single D flip-flop where the next state
is just the input. We can also consider this as a delay element of one
clock cycle. The output logic \emph{compares} the current
input with the current state.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:fsm-rising}は、立ち上がりエッジ検出器の概略図を示します。
現在の入力が1であり、最後のクロックサイクルで入力が0のとき出力は、1つのクロック・サイクルの1となります。
状態レジスタは、次の状態がちょうど入力されたただ1つのDフリップフロップです。
また、1つのクロックサイクルの遅延要素としてこれを考慮することができます。
出力論理は、現在の状態と現在の入力を\emph{compares}。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:fsm-rising}は、立ち上がりエッジ検出器の概略図を示します。
現在の入力が1であり、最後のクロックサイクルで入力が0のとき出力は、1つのクロック・サイクルの1となります。
状態レジスタは、次の状態がちょうど入力されたただ1つのDフリップフロップです。
また、1つのクロックサイクルの遅延要素としてこれを考慮することができます。
出力論理は、現在の状態と現在の入力を\emph{compares}。
\fi

\ifshoworiginal
When the output depends also on the input, i.e., there is a combinational path between
the input of the FSM and the output, this is called a
\myref{https://en.wikipedia.org/wiki/Mealy_machine}{Mealy machine}.
\fi

\ifshowtransfirst %(自動翻訳)
とき出力iは、入力にも依存します。
え。
、、これは\myref{https://en.wikipedia.org/wiki/Mealy_machine}{Mealy machine}呼ばれるFSMの入力と出力との間の組み合わせパスがあります。
\fi

\ifshowtranssecond %(校正 TODO)
とき出力iは、入力にも依存します。
え。
、、これは\myref{https://en.wikipedia.org/wiki/Mealy_machine}{Mealy machine}呼ばれるFSMの入力と出力との間の組み合わせパスがあります。
\fi

\index{Finite-State Machine!Mealy}

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/mealy}
  \caption{A Mealy type finite state machine.}
  \label{fig:mealy}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:mealy} shows the schematic of a Mealy type FSM.
Similar to the Moore FSM, the register contains the current \code{state}, and
the next state logic computes the next state value (\code{next\_state})
from the current \code{state} and the input (\code{in}).
On the next clock tick, \code{state} becomes \code{next\_state}.
The output logic computes the output (\code{out}) from the current state
\emph{and} the input to the FSM.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:mealy}はミーリ型FSMの概略図を示します。
ムーアFSMと同様に、レジスタは現在\code{state}を含み、次の状態の論理は、現在\code{state}と入力（\code{in}）から次の状態値（\code{next\_state}）を算出します。
次のクロックチックで、\code{state}は\code{next\_state}になります。
出力論理は、現在の状態\emph{and} FSMへの入力から出力（\code{out}）を計算します。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:mealy}はミーリ型FSMの概略図を示します。
ムーアFSMと同様に、レジスタは現在\code{state}を含み、次の状態の論理は、現在\code{state}と入力（\code{in}）から次の状態値（\code{next\_state}）を算出します。
次のクロックチックで、\code{state}は\code{next\_state}になります。
出力論理は、現在の状態\emph{and} FSMへの入力から出力（\code{out}）を計算します。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/state-diag-mealy}
  \caption{The state diagram of the rising edge detector as Mealy FSM.}
  \label{fig:diag:mealy}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:diag:mealy} shows the state diagram of the Mealy FSM for the
edge detector. As the state register consists just of a single D flip-flop,
only two states are possible, which we name \code{zero} and \code{one} in this
example.
As the output of a Mealy FSM does not only depend on the state, but also
on the input, we cannot describe the output as part of the state circle.
Instead, the transitions between the states are labeled with the input
value (condition) \emph{and} the output (after the slash).
Note also that we draw self transitions, e.g., in state \code{zero} when
the input is \code{0} the FSM stays in state \code{zero}, and the output is {0}.
The rising edge FSM generates the \code{1} output only on the transition
from state \code{zero} to state \code{one}. In state \code{one}, which represents
that the input is now \code{1}, the output is \code{0}. We only want a single (cycle)
puls for each rising edge of the input.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:diag:mealy}は、エッジ検出のためのミーリーFSMの状態図を示します。
状態レジスタが1つだけDフリップフロップで構成されているように、2つだけの状態では、我々は、この例では\code{zero}と\code{one}に名前を付けた、可能です。
ミーリーFSMの出力が状態だけでなく、入力に依存しないように、我々は国家の円の一部として出力を記述することはできません。
その代わりに、状態間の遷移は、入力値（条件）\emph{and}（スラッシュの後の）出力で標識されます。
私たちは、電子を自己遷移を描画することにも注意してください。
グラム。
、状態\code{zero}に入力\code{0}状態\code{zero}におけるFSMの滞在である場合、出力は{0}です。
立ち上がりエッジFSMは、状態\code{zero}から状態\code{one}への遷移に\code{1}出力を生成します。
入力が現在\code{1}であることを表す状態\code{one}において、出力は\code{0}あります。
私たちは、入力の各立ち上がりエッジのための単一の（サイクル）のパルスをしたいです。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:diag:mealy}は、エッジ検出のためのミーリーFSMの状態図を示します。
状態レジスタが1つだけDフリップフロップで構成されているように、2つだけの状態では、我々は、この例では\code{zero}と\code{one}に名前を付けた、可能です。
ミーリーFSMの出力が状態だけでなく、入力に依存しないように、我々は国家の円の一部として出力を記述することはできません。
その代わりに、状態間の遷移は、入力値（条件）\emph{and}（スラッシュの後の）出力で標識されます。
私たちは、電子を自己遷移を描画することにも注意してください。
グラム。
、状態\code{zero}に入力\code{0}状態\code{zero}におけるFSMの滞在である場合、出力は{0}です。
立ち上がりエッジFSMは、状態\code{zero}から状態\code{one}への遷移に\code{1}出力を生成します。
入力が現在\code{1}であることを表す状態\code{one}において、出力は\code{0}あります。
私たちは、入力の各立ち上がりエッジのための単一の（サイクル）のパルスをしたいです。
\fi

\longlist{code/rising_fsm.txt}{Rising edge detection with a Mealy FSM.}{lst:fsm:rising}

\ifshoworiginal
Listing~\ref{lst:fsm:rising} shows the Chisel code for the rising edge detection
with a Mealy machine.
As in the previous example, we use the Chisel type \code{Bool} for the
single-bit input and output.
The output logic is now part of the next state logic; on the transition from
\code{zero} to \code{one}, the output is set to \code{true.B}. Otherwise,
the default assignment to the output (\code{false.B}) counts.
\fi

\ifshowtransfirst %(自動翻訳)
〜\ref{lst:fsm:rising}をリストミーリー機械と立ち上がりエッジ検出のためのChiselコードを示します。
前の例のように、我々は、単一ビットの入力及び出力のためのChisel型\code{Bool}を使用します。
出力論理は現在、次の状態の論理の一部です。 \code{zero}から\code{one}への遷移で、出力が\code{true.B}に設定されています。
出力にそれ以外の場合は、デフォルトの割り当て（\code{false.B}）カウント。
\fi

\ifshowtranssecond %(校正 TODO)
〜\ref{lst:fsm:rising}をリストミーリー機械と立ち上がりエッジ検出のためのChiselコードを示します。
前の例のように、我々は、単一ビットの入力及び出力のためのChisel型\code{Bool}を使用します。
出力論理は現在、次の状態の論理の一部です。 \code{zero}から\code{one}への遷移で、出力が\code{true.B}に設定されています。
出力にそれ以外の場合は、デフォルトの割り当て（\code{false.B}）カウント。
\fi

\ifshoworiginal
One can ask if a full-blown FSM is the best solution for the edge detection circuit,
especially, as we have seen a Chisel one-liner for the same functionality.
The hardware consumptions is similar. Both solutions need a single D flip-flop
for the state. The combinational logic for the FSM is probably a bit more complicated, as
the state change depends on the current state and the input value.
For this function, the one-liner is easier to write and easier to read,
which is more important. Therefore, the one-liner is the preferred solution.
\fi

\ifshowtransfirst %(自動翻訳)
一つは、本格的なFSMどうかを確認することができ、我々は同じ機能のためのリグワンライナーを見てきたように、特に、エッジ検出回路に最適なソリューションです。
ハードウェアの消費似ています。
両方の溶液は、状態のための単一のDフリップフロップを必要とします。
状態変化が現在の状態と入力値に依存するFSMのための組み合わせロジックは、おそらく、もう少し複雑です。
この機能のために、ワンライナーがより重要である、書き込みを簡単かつ読みやすいです。
したがって、ワンライナーは、好ましい解決策です。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
特に、同じ機能のChisel ワンライナーを見たことがあるので、エッジ検出回路に本格的なFSMが最適かどうかを問うことができます。
ハードウェア消費量は似ています。
どちらのソリューションも、ステート用に単一のDフリップフロップを必要とします。
FSM の組み合わせ ロ ジ ッ ク は、 状態の変化が現在の状態 と 入力値に依存す る ため、 多少複雑にな り ます。
この機能のためには、ワンライナーの方が書きやすく、読みやすいので、より重要です。したがって、ワンライナーが好ましい解決策である。
\fi

\ifshoworiginal
We have used this example to show one of the smallest possible Mealy FSMs.
FSMs shall be used for more complex circuits with three and more states.
\fi

\ifshowtransfirst %(自動翻訳)
我々は可能な限り最小のミーリのFSMの1を表示するには、この例を使用しています。
FSMが3と以上の状態で、より複雑な回路に使用されなければなりません。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
この例を用いて、可能な限り最小のMealy FSMの1つを示した。
FSMは、３つ以上の状態を持つより複雑な回路に使用するものとする。
\fi

\ifshoworiginal
\section{Moore versus Mealy}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Moore versus Mealy}
\fi
\ifshowtranssecond %(校正)
\section{ムーア対ミーリー (L78692 TODO)}
\fi

\ifshoworiginal
To show the difference between a Moore and Mealy FSM, we redo the edge
detection with a Moore FSM.
\fi

\ifshowtransfirst %(自動翻訳)
ムーアとミーリFSMの違いを示すために、我々は、ムーアFSMとエッジ検出をやり直します。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
ムーアFSMとミーリーFSMの違いを示すために、ムーアFSMでエッジ検出をやり直します。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/state-diag-rising-moore}
  \caption{The state diagram of the rising edge detector as Moore FSM.}
  \label{fig:diag:rising:moore}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:diag:rising:moore} shows the state diagram for the rising
edge detection with a Moore FSM. The first thing to notice is that the Moore FSM
needs three states, compared to two states in the Mealy version.
The state \code{puls} is needed to produce the single-cycle puls.
The FSM stays in state \code{puls} just one clock cycle and then
proceeds either back to the start state \code{zero} or to the \code{one}
state, waiting for the input to become 0 again.
We show the input condition on the state transition arrows and the
FSM output within the state representing circles.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:diag:rising:moore}ムーアFSMを有する立ち上がりエッジ検出のための状態図を示します。
通知に最初の事はムーアFSMはミーリバージョンで二つの状態に比べて3つの状態が、必要があることです。
状態\code{puls}は、シングルサイクルPULSを生成するために必要とされます。
状態\code{puls}ちょうど1クロックサイクルでFSM滞在し、入力が再び0になるのを待って、バック開始状態\code{zero}または\code{one}状態のいずれかに進みます。
我々は、状態遷移矢印の入力条件及び状態を表す円内のFSMの出力を示します。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:diag:rising:moore}ムーアFSMを有する立ち上がりエッジ検出のための状態図を示します。
通知に最初の事はムーアFSMはミーリバージョンで二つの状態に比べて3つの状態が、必要があることです。
状態\code{puls}は、シングルサイクルPULSを生成するために必要とされます。
状態\code{puls}ちょうど1クロックサイクルでFSM滞在し、入力が再び0になるのを待って、バック開始状態\code{zero}または\code{one}状態のいずれかに進みます。
我々は、状態遷移矢印の入力条件及び状態を表す円内のFSMの出力を示します。
\fi

\longlist{code/rising_moore_fsm.txt}{Rising edge detection with a Moore FSM.}{lst:fsm:rising:moore}

\ifshoworiginal
Listing~\ref{lst:fsm:rising:moore} shows the Moore version of the rising edge detection
circuit. It uses double the number of D flip-flops than the Mealy or direct
coded version. The resulting next state logic is therefore also larger
than the Mealy or direct coded version.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:fsm:rising:moore}は、立ち上がり検出回路のムーアのバージョンを示しています。
これはミーリーよりフリップフロップDの数を2倍または符号化されたバージョンを指示する使用します。
得られた次の状態の論理は、従って、ミーリーまたは直接符号化されたバージョンよりも大きくなっています。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:fsm:rising:moore}は、立ち上がり検出回路のムーアのバージョンを示しています。
これはミーリーよりフリップフロップDの数を2倍または符号化されたバージョンを指示する使用します。
得られた次の状態の論理は、従って、ミーリーまたは直接符号化されたバージョンよりも大きくなっています。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=1]{figures/rising}
  \caption{Mealy and a  Moore FSM waveform for rising edge detection.}
  \label{fig:rising}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:rising} shows the waveform of a Mealy and a  Moore version
of the rising edge detection FSM. We can see that the Mealy output closely
follows the input rising edge, while the Moore output rises after the clock tick.
We can also see that the Moore output is one clock cycle wide, where the Mealy
output is usually less than a clock cycle.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:rising}はミーリ、立ち上がりエッジ検出FSMのムーアバージョンの波形を示しています。
私たちは、ムーアの出力は、クロックティックの後に上昇しながらミーリ出力は密接に、入力の立ち上がりエッジを、次のことがわかります。
また、ムーア出力はミーリー出力が通常より少ないクロック・サイクルよりも1つのクロックサイクルの広い、であることがわかります。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:rising}はミーリ、立ち上がりエッジ検出FSMのムーアバージョンの波形を示しています。
私たちは、ムーアの出力は、クロックティックの後に上昇しながらミーリ出力は密接に、入力の立ち上がりエッジを、次のことがわかります。
また、ムーア出力はミーリー出力が通常より少ないクロック・サイクルよりも1つのクロックサイクルの広い、であることがわかります。
\fi

\ifshoworiginal
From the above example, one is tempted to find Mealy FSMs the \emph{better}
FSMs as they need less state (and therefore logic) and react faster than a Moore FSM.
However, the combinational path within a Mealy machine can cause trouble in
larger designs. First, with a chain of communicating FSM (see next chapter), this
combinational path can become lengthy. Second, if the communicating FSMs build
a circle, the result is a combinational loop, which is an error in synchronous design.
Due to a cut in the combinational path with the state register in a Moore FSM,
all the above issues do not exist for communicating Moore FSMs.
\fi

\ifshowtransfirst %(自動翻訳)
上記の例から、一方は、それらがより少ない状態（従って論理）を必要と高速ムーアFSMよりも反応するようミーリーFSMの\emph{better}のFSMを見つけるために誘惑されます。
しかし、ミーリー機械内の組み合わせパスは、大規模なデザインでトラブルを引き起こす可能性があります。
まず、FSMを（次の章を参照してください）通信のチェーンで、この組み合わせパスが長くなることができます。
通信のFSMが円を構築する場合には、第2、、結果は、同期設計の誤りである組合せループがあります。
ムーアFSMの状態レジスタとの組み合わせパスでカットのためには、上記のすべての問題は、ムーアのFSMを通信するために存在していません。
\fi

\ifshowtranssecond %(校正 TODO)
上記の例から、一方は、それらがより少ない状態（従って論理）を必要と高速ムーアFSMよりも反応するようミーリーFSMの\emph{better}のFSMを見つけるために誘惑されます。
しかし、ミーリー機械内の組み合わせパスは、大規模なデザインでトラブルを引き起こす可能性があります。
まず、FSMを（次の章を参照してください）通信のチェーンで、この組み合わせパスが長くなることができます。
通信のFSMが円を構築する場合には、第2、、結果は、同期設計の誤りである組合せループがあります。
ムーアFSMの状態レジスタとの組み合わせパスでカットのためには、上記のすべての問題は、ムーアのFSMを通信するために存在していません。
\fi

\ifshoworiginal
In summary, Moore FSMs combine better for communicating state machines; they
are \emph{more robust} than Mealy FSMs. Use Mealy FSMs only when the reaction within the same
cycle is of utmost importance. Small circuits such as the rising edge detection,
which are practically Mealy machines, are fine as well.
\fi

\ifshowtransfirst %(自動翻訳)
要約すると、ムーアのFSMは、ステートマシンを通信するためのより良い組み合わせ。彼らはミーリのFSMより\emph{more robust}です。
使用ミーリのFSM同じサイクル内での反応が最も重要であるのみ。
事実上ミーリマシンですな立ち上がりエッジ検出などの小型回路は、同様に罰金です。
\fi

\ifshowtranssecond %(校正 TODO)
要約すると、ムーアのFSMは、ステートマシンを通信するためのより良い組み合わせ。彼らはミーリのFSMより\emph{more robust}です。
使用ミーリのFSM同じサイクル内での反応が最も重要であるのみ。
事実上ミーリマシンですな立ち上がりエッジ検出などの小型回路は、同様に罰金です。
\fi

\ifshoworiginal
\section{Exercise}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Exercise}
\fi
\ifshowtranssecond %(校正)
\section{演習 (L8843 TODO)}
\fi

\ifshoworiginal
% This is a boring example, maybe I can find something more interesting
In this chapter, you have seen many examples of very small FSMs.
Now it is time to write some \emph{real} FSM code.
Pick a little bit more complex example and implement the FSM and
write a test bench for it.
\fi

\ifshowtransfirst %(自動翻訳)
今では、いくつかの\emph{real} FSMコードを書くための時間です。
もう少し複雑な例を選び、FSMを実装し、そのためのテストベンチを書きます。
\fi

\ifshowtranssecond %(校正 TODO)
今では、いくつかの\emph{real} FSMコードを書くための時間です。
もう少し複雑な例を選び、FSMを実装し、そのためのテストベンチを書きます。
\fi

\ifshoworiginal
A classic example for a FSM is a traffic light controller (see~\cite[Section~14.3]{dally:vhdl:2016}).
A traffic light controller has to ensure that on a switch from red to green
there is a phase in between where both roads in the intersection
have a no-go light (red and orange).
To make this example a little bit more interesting, consider a priority road.
The minor road has two car detectors (on both entries into the intersection).
Switch to green for the minor road only when a car is detected and then switch
back to green for the priority road.
\fi

\ifshowtransfirst %(自動翻訳)
FSMのための古典的な例は、トラフィック光コントローラ（〜\cite[Section~14.3]{dally:vhdl:2016}を参照します）。
トラフィックライトコントローラは、赤から緑にスイッチの交差点の両方の道路が無行く光（赤、オレンジ）を有する場合との間の位相があることを確認しなければなりません。
もう少し面白いこの例を作成するには、優先道路を考えます。
マイナーな道路は、（交差点に両方のエントリに）2つの車の検出器を持っています。
車が検出された後、優先道路のために戻って緑に切り替えているだけマイナーな道路のための緑に切り替えます。
\fi

\ifshowtranssecond %(校正 TODO)
FSMのための古典的な例は、トラフィック光コントローラ（〜\cite[Section~14.3]{dally:vhdl:2016}を参照します）。
トラフィックライトコントローラは、赤から緑にスイッチの交差点の両方の道路が無行く光（赤、オレンジ）を有する場合との間の位相があることを確認しなければなりません。
もう少し面白いこの例を作成するには、優先道路を考えます。
マイナーな道路は、（交差点に両方のエントリに）2つの車の検出器を持っています。
車が検出された後、優先道路のために戻って緑に切り替えているだけマイナーな道路のための緑に切り替えます。
\fi

\todo{Luca: Greatest common divisor with Euclide algorithm can be also a nice exercise.
Martin: but this is shown at the Chisel homepage without an FSM.}

\todo{Here a more interesting exercise. And not one from Dally.}

\ifshoworiginal
\chapter{Communicating State Machines}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Communicating State Machines}
\fi
\ifshowtranssecond %(校正)
\chapter{コミュニケートステートマシン (L8903 TODO)} %(校正  第9章  ========================================================================)
\fi

\index{Communicating state machines}

\ifshoworiginal
A problem is often too complex to describe it with a single FSM.
In that case, the problem can be divided into two or more smaller and simpler FSMs.
Those FSMs then communicate with signals. One FSMs output is
another FSMs input, and the FSM watches the output of the other FSM.
When we split a large FSM into simpler ones, this is called factoring FSMs.
However, often communicating FSMs are directly designed from the specification,
as often a single FSM would be infeasible large.
\fi

\ifshowtransfirst %(自動翻訳)
問題は、多くの場合、単一のFSMでそれを説明するにはあまりにも複雑です。
その場合、問題は、二つ以上の小さく、簡単のFSMに分割することができます。
それらのFSMは、その後、信号と通信します。
一つのFSMの出力は、別のFSM入力され、FSMは他のFSMの出力を監視します。
我々は単純なものに大きなFSMを分割すると、これは、ファクタリングのFSMと呼ばれています。
しかし、多くの場合、通信のFSMを直接しばしば単一FSMが大きい不可能であるように、仕様から設計されています。
\fi

\ifshowtranssecond %(校正 6/20 mune10)
問題はしばしば、単一のFSMで記述するには複雑すぎることがあります。
その場合、問題を2つ以上のより小さくて単純なFSMに分割することができます。
そして、それらのFSMは信号で通信します。1つのFSMの出力は
が別の FSM の入力を入力し、その FSM は他の FSM の出力を監視します。
大きなFSMをより単純なものに分割する場合、これをファクタリングFSMと呼びます。
しかし、多くの場合、通信するFSMは仕様から直接設計されています。
多くの場合、単一のFSMは、実行不可能な大規模なものになります。
\fi

\ifshoworiginal
\section{A Light Flasher Example}
\fi
\ifshowtransfirst %(自動翻訳)
\section{A Light Flasher Example}
\fi
\ifshowtranssecond %(校正)
\section{ライトフラッシャーの例 (L8944 TODO}
\fi

\ifshoworiginal
To discuss communicating FSMs, we use an example
from~\cite[Chapter~17]{dally:vhdl:2016}, the light flasher.
The light flasher has one input \code{start} and one output
\code{light}. The specification of the light flasher is as follows:
\fi

\ifshowtransfirst %(自動翻訳)
FSMの通信について議論するために、我々は〜\cite[Chapter~17]{dally:vhdl:2016}、光フラッシャーからの例を使用します。
光フラッシャーは、1つの入力\code{start}と1つの出力\code{light}を有しています。
次のように光フラッシャーの仕様は次のとおりシーケンスが開始されます。次のスタートのために。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
FSMの通信について議論するために、我々は〜\cite[Chapter~17]{dally:vhdl:2016}、光フラッシャーからの例を使用します。
光フラッシャーは、1つの入力\code{start}と1つの出力\code{light}を有しています。
次のように光フラッシャーの仕様は次のとおりシーケンスが開始されます。次のスタートのために。
\fi

\begin{itemize}
\item when \code{start} is high for one clock cycle, the flashing
sequence starts;
\item the sequence is to flash three times;
\item where the \code{light} goes \emph{on} for six clock cycles, and the \code{light} goes \emph{off} for four clock cycles between flashes;
\item after the sequence, the FSM switches the \code{light} \emph{off} and waits
for the next start.
\end{itemize}

\ifshoworiginal
The FSM for a direct implementation\footnote{The state diagram is shown
in~\cite[p.~376]{dally:vhdl:2016}.} has 27 states:
one initial state that is waiting for the input, $3 \times 6$ states for the three
\emph{on} states and $2 \times 4$ states for the \emph{off} states.
We do not show the code for this simple-minded implementation of the light
flasher.
\fi

\ifshowtransfirst %(自動翻訳)
ERROR-TBD
%直接実装\脚注ためのFSMは、{状態図は〜\cite[p.~376]{dally:vhdl:2016}に示されています。
%3つの\emph{on}状態と\emph{off}状態に対する$ 2 \倍4 $状態の入力を待っているつの初期状態、$ 3 \回6つの$状態：} 27の状態を有します。
%私たちは、光フラッシャーのこのシンプル志向の実装のためのコードを示していません。
\fi

\ifshowtranssecond %(校正 TODO)
ERROR-TBD
%直接実装\脚注ためのFSMは、{状態図は〜\cite[p.~376]{dally:vhdl:2016}に示されています。
%3つの\emph{on}状態と\emph{off}状態に対する$ 2 \倍4 $状態の入力を待っているつの初期状態、$ 3 \回6つの$状態：} 27の状態を有します。
%私たちは、光フラッシャーのこのシンプル志向の実装のためのコードを示していません。
\fi

\ifshoworiginal
The problem can be solved more elegantly by factoring this large FSM into
two smaller FSMs: the master FSM implements the flashing logic, and the timer FSM
implements the waiting. Figure~\ref{fig:flasher} shows the composition of
the two FSMs.
\fi

\ifshowtransfirst %(自動翻訳)
マスターFSMを実装点滅ロジック、およびタイマーFSMの実装待ち：問題は、2つの小さなのFSMにこの大規模なFSMを因数分解することで、よりエレガントに解決することができます。
図〜\ref{fig:flasher}は2つのFSMの組成を示します。
\fi

\ifshowtranssecond %(校正 TODO)
マスターFSMを実装点滅ロジック、およびタイマーFSMの実装待ち：問題は、2つの小さなのFSMにこの大規模なFSMを因数分解することで、よりエレガントに解決することができます。
図〜\ref{fig:flasher}は2つのFSMの組成を示します。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/flasher}
  \caption{The light flasher split into a Master FSM and a Timer FSM.}
  \label{fig:flasher}
\end{figure}

\ifshoworiginal
The timer FSM counts down for 6 or 4 clock cycles to produce the desired timing.
The timer specification is as follows:
\fi

\ifshowtransfirst %(自動翻訳)
タイマFSMは、所望のタイミングを生成するために6または4クロックサイクルの間カウントダウン。
次のようにタイマー仕様は次のとおりです。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
タイマーFSMは、所望のタイミングを作り出すために6または4クロックサイクルでカウントダウンします。
タイマーの仕様は以下の通りです。
\fi

\begin{itemize}
\item when \code{timerLoad} is asserted, the timer loads a value into the down counter,
independent of the state;
\item \code{timerSelect} selects between 5 or 3 for the load;
\item \code{timerDone} is asserted when the counter completed the countdown
and remains asserted;
\item otherwise, the timer counts down.
\end{itemize}


%国家の独立しました。そして、はアサートされたままです。

\ifshoworiginal
\noindent Following code shows the timer FSM of the light flasher:
\fi

\ifshowtransfirst %(自動翻訳)
光フラッシャーのタイマーFSMは、コードを示し、次のとおりです。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
\noindent 以下のコードは、ライトフラッシャーのタイマーFSMを示しています。
\fi

\shortlist{code/flasher_timer.txt}

\ifshoworiginal
\noindent Listing~\ref{lst:flasher:master} shows the master FSM.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:flasher:master}は、マスターFSMを示しています。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:flasher:master}は、マスターFSMを示しています。
\fi

\longlist{code/flasher_fsm.txt}{Master FSM of the light flasher.}{lst:flasher:master}

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/flasher2}
  \caption{The light flasher split into a Master FSM, a Timer FSM, and a Counter FSM.}
  \label{fig:flasher2}
\end{figure}

\ifshoworiginal
This solution with a master FSM and a timer has still redundancy in the code
of the master FSM. States \code{flash1}, \code{flash2}, and \code{flash3}
are performing the same function, states \code{space1} and \code{space2} as well.
We can factor out the number of remaining flashes into a second counter.
Then the master FSM is reduced to three states: \code{off}, \code{flash},
and \code{space}.
\fi

\ifshowtransfirst %(自動翻訳)
マスターFSMとタイマーとこのソリューションは、まだマスターFSMのコード内の冗長性を持っています。
米国\code{flash1}、\code{flash2}、および\code{flash3}は、同じ機能を実行している、うまくとして\code{space1}とRRR011TeVPYxsjを述べています。
私たちは、第二のカウンタに残っている点滅の数を考慮することができます。
\code{off}、\code{flash}、および\code{space}：次にマスターFSMは、次の3つの状態に還元されます。
\fi

\ifshowtranssecond %(校正 TODO)
マスターFSMとタイマーとこのソリューションは、まだマスターFSMのコード内の冗長性を持っています。
米国\code{flash1}、\code{flash2}、および\code{flash3}は、同じ機能を実行している、うまくとして\code{space1}とRRR011TeVPYxsjを述べています。
私たちは、第二のカウンタに残っている点滅の数を考慮することができます。
\code{off}、\code{flash}、および\code{space}：次にマスターFSMは、次の3つの状態に還元されます。
\fi

\ifshoworiginal
Figure~\ref{fig:flasher2} shows the design with a master FSM and two FSMs
that count: one FSM to count clock cycles for the interval length of \emph{on}
and \emph{off}; the second FSM to count the remaining flashes.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:flasher2}は、ショーマスターFSMと2つのFSMとデザインその回数：\emph{on}と\emph{off}の間隔の長さのためのクロックサイクルをカウントする1つのFSM;残りの点滅をカウントするための第2のFSM。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:flasher2}は、ショーマスターFSMと2つのFSMとデザインその回数：\emph{on}と\emph{off}の間隔の長さのためのクロックサイクルをカウントする1つのFSM;残りの点滅をカウントするための第2のFSM。
\fi

\ifshoworiginal
Following code shows the down counter FSM:
\fi

\ifshowtransfirst %(自動翻訳)
コード・ショーダウンカウンタFSM次のとおりです。
\fi

\ifshowtranssecond %(校正 TODO)
コード・ショーダウンカウンタFSM次のとおりです。
\fi

\shortlist{code/flasher2_counter.txt}

\ifshoworiginal
\noindent Note, that the counter is loaded with 2 for 3 flashes, as it counts the
\emph{remaining} flashes and is decremented in state \code{space} when the timer
is done. Listing~\ref{lst:flasher2:master} shows the master FSM for the double refactored flasher.
\fi

\ifshowtransfirst %(自動翻訳)
注、カウンタはそれが\emph{remaining}が点滅をカウントし、タイマーが実行されたときに、状態\code{space}にデクリメントされて、2〜3のための点滅がロードされていること。
一覧〜\ref{lst:flasher2:master}は、二重のリファクタリングフラッシャーのマスターFSMを示しています。
\fi

\ifshowtranssecond %(校正 TODO)
注、カウンタはそれが\emph{remaining}が点滅をカウントし、タイマーが実行されたときに、状態\code{space}にデクリメントされて、2〜3のための点滅がロードされていること。
一覧〜\ref{lst:flasher2:master}は、二重のリファクタリングフラッシャーのマスターFSMを示しています。
\fi

\longlist{code/flasher2_fsm.txt}{Master FSM of the double refactored light flasher.}{lst:flasher2:master}

\ifshoworiginal
Besides having a master FSM that is reduced to just three states, our current solution
is also better configurable. No FSM needs to be changed if we want to change
the length of the \emph{on} or \emph{off} intervals or the number of flashes.
\fi

\ifshowtransfirst %(自動翻訳)
ただ三つの状態に還元され、マスタFSMを持つだけでなく、私たちの現在のソリューションはまた、より良い設定可能です。
我々は\emph{on}または\emph{off}間隔の長さや点滅の数を変更したい場合は、[いいえFSMを変更する必要があります。
\fi

\ifshowtranssecond %(校正 TODO)
ただ三つの状態に還元され、マスタFSMを持つだけでなく、私たちの現在のソリューションはまた、より良い設定可能です。
我々は\emph{on}または\emph{off}間隔の長さや点滅の数を変更したい場合は、[いいえFSMを変更する必要があります。
\fi

\ifshoworiginal
In this section, we have explored communicating circuits, especially FSM, that
only exchange control signals. However, circuits can also exchange data.
For the coordinated exchange of data, we use handshake signals.
The next section describes the ready-valid interface for flow control of
unidirectional data exchange.
\fi

\ifshowtransfirst %(自動翻訳)
ここでは、通信回路、特にFSM、その唯一の交換制御信号を模索しています。
しかし、回路は、データを交換することができます。
データの協調交換のために、我々はハンドシェーク信号を使用します。
次のセクションでは、単方向のデータ交換のフロー制御のための準備ができて、有効なインタフェースについて説明します。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
ここでは、制御信号のみを交換する通信回路、特にＦＳＭについて探ってきました。
しかし、回路はデータを交換することもできます。
データの協調的な交換にはハンドシェイク信号を使用します。
次項では、一方向データ交換のフロー制御のためのレディバリッドインタフェースについて説明します。
\fi

\ifshoworiginal
\section{State Machine with Datapath}
\fi
\ifshowtransfirst %(自動翻訳)
\section{State Machine with Datapath}
\fi
\ifshowtranssecond %(校正)
\section{データパスを持つステートマシン (L9194 TODO)}
\fi

\index{State machine with datapath}
\index{FSMD}

\ifshoworiginal
One typical example of communicating state machines is a state machine
combined with a datapath. This combination is often called a finite state machine
with datapath (FSMD). The state machine controls the datapath, and the datapath
performs the computation. The FSM input is the input from the environment and the input
from the datapath. The data from the environment is fed into the datapath, and the
data output comes from the datapath. Figure~\ref{fig:popcnt-fsmd} shows an example
of the combination of the FSM with the datapath.
\fi

\ifshowtransfirst %(自動翻訳)
ステートマシンの通信の一つの典型的な例は、データパスと組み合わさ状態マシンです。
この組み合わせは、多くの場合、データパス（FSMD）と有限状態マシンと呼ばれています。
状態マシンは、データパスを制御し、データパスは、演算を行います。
FSMの入力は、環境からの入力およびデータパスから入力されます。
環境からのデータは、データパスに供給され、データ出力がデータパスから来ています。
図〜\ref{fig:popcnt-fsmd}は、データパスとFSMの組み合わせの一例を示しています。
\fi

\ifshowtranssecond %(校正 TODO)
ステートマシンの通信の一つの典型的な例は、データパスと組み合わさ状態マシンです。
この組み合わせは、多くの場合、データパス（FSMD）と有限状態マシンと呼ばれています。
状態マシンは、データパスを制御し、データパスは、演算を行います。
FSMの入力は、環境からの入力およびデータパスから入力されます。
環境からのデータは、データパスに供給され、データ出力がデータパスから来ています。
図〜\ref{fig:popcnt-fsmd}は、データパスとFSMの組み合わせの一例を示しています。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/popcnt-fsmd}
  \caption{A state machine with a datapath.}
  \label{fig:popcnt-fsmd}
\end{figure}

\ifshoworiginal
\subsection{Popcount Example}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Popcount Example}
\fi
\ifshowtranssecond %(校正)
\subsection{ポップカウントの例 (L9242 TODO)}
\fi

\ifshoworiginal
The FSMD shown in Figure~\ref{fig:popcnt-fsmd} serves as an example that computes the
popcount, also called the \myref{https://en.wikipedia.org/wiki/Hamming_weight}{Hamming weight}.
The Hamming weight is the number of symbols different from the zero symbol.
For a binary string, this is the number of `1's.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:popcnt-fsmd}に示すFSMDも\myref{https://en.wikipedia.org/wiki/Hamming_weight}{Hamming weight}呼ばPOPCOUNTを、計算例として機能します。
ハミング重みは、ゼロシンボルとは異なるシンボルの数です。
バイナリ文字列の場合、これは `1の数です。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:popcnt-fsmd}に示すFSMDも\myref{https://en.wikipedia.org/wiki/Hamming_weight}{Hamming weight}呼ばPOPCOUNTを、計算例として機能します。
ハミング重みは、ゼロシンボルとは異なるシンボルの数です。
バイナリ文字列の場合、これは `1の数です。
\fi

\ifshoworiginal
The popcount unit contains the data input \code{din} and the result output \code{popCount},
both connected to the datapath. For the input and the output we use a ready-valid handshake.
When data is available, valid is asserted. When a receiver can accept data it asserts ready.
When both signals are asserted the transfer takes place. The handshake signals are connected
to the FSM. The FSM is connected with the datapath with control signals towards the datapath
and with status signals from the datapath.
\fi

\index{Datapath}

\ifshowtransfirst %(自動翻訳)
POPCOUNTユニットは、データ入力\code{din}と結果出力\code{popCount}、データ経路に接続された両方を含みます。
入力と出力のために我々は準備ができて、有効なハンドシェイクを使用します。
データが利用可能である場合には、有効ながアサートされます。
受信機がデータを受け入れることができるとき、それは準備がアサートされます。
両方の信号がアサートされると転送が行われます。
ハンドシェーク信号は、FSMに接続されています。
FSMは、データパスに向かっておよびデータパスからのステータス信号と制御信号とのデータパスが接続されています。
\fi

\ifshowtranssecond %(校正 TODO)
POPCOUNTユニットは、データ入力\code{din}と結果出力\code{popCount}、データ経路に接続された両方を含みます。
入力と出力のために我々は準備ができて、有効なハンドシェイクを使用します。
データが利用可能である場合には、有効ながアサートされます。
受信機がデータを受け入れることができるとき、それは準備がアサートされます。
両方の信号がアサートされると転送が行われます。
ハンドシェーク信号は、FSMに接続されています。
FSMは、データパスに向かっておよびデータパスからのステータス信号と制御信号とのデータパスが接続されています。
\fi


\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/popcnt-states}
  \caption{State diagram for the popcount FSM.}
  \label{fig:popcnt-states}
\end{figure}

\ifshoworiginal
As a next step, we can design the FSM, starting with a state diagram, shown in
Figure~\ref{fig:popcnt-states}. We start in state \code{Idle}, where the FSM waits
for input. When data arrives, signaled with a valid signal, the FSM advances to state \code{Load}
to load a shift register. The FSM proceeds to the next state \code{Count}, there the number
of `1's is counted sequentially. We use a shift register, an adder, an accumulator
register, and a down counter to perform the computation. When the down counter reaches
zero, we are finished and the FSM moves to state \code{Done}. There the FSM signals with a valid
signal that the popcount value is ready to be consumed. On a ready signal from the
receiver, the FSM moves back to the \code{Idle} state, ready to compute the next popcount.
\fi

\ifshowtransfirst %(自動翻訳)
次のステップとして、我々は図〜\ref{fig:popcnt-states}に示した状態図、で始まる、FSMを設計することができます。
我々は、状態\code{Idle}、入力のためのFSMが待機中で開始します。
データが有効な信号で合図、到着すると、FSMは、シフトレジスタをロードするために状態\code{Load}に移行します。
FSMは、次の状態\code{Count}に進み、 `1基のの存在数を順次カウントします。
我々は、計算を実行するために、シフトレジスタ、加算器、アキュムレータレジスタ、及びダウンカウンタを使用します。
ダウンカウンタが0に達すると、我々が終了し、状態\code{Done}にFSMが移動しています。
そこPOPCOUNT値が消費される準備ができていること、有効な信号とFSM信号を。
受信機からのレディ信号に、FSMの移動は、次POPCOUNTを計算する準備ができて、\code{Idle}状態に戻り。
\fi

\ifshowtranssecond %(校正 TODO)
次のステップとして、我々は図〜\ref{fig:popcnt-states}に示した状態図、で始まる、FSMを設計することができます。
我々は、状態\code{Idle}、入力のためのFSMが待機中で開始します。
データが有効な信号で合図、到着すると、FSMは、シフトレジスタをロードするために状態\code{Load}に移行します。
FSMは、次の状態\code{Count}に進み、 `1基のの存在数を順次カウントします。
我々は、計算を実行するために、シフトレジスタ、加算器、アキュムレータレジスタ、及びダウンカウンタを使用します。
ダウンカウンタが0に達すると、我々が終了し、状態\code{Done}にFSMが移動しています。
そこPOPCOUNT値が消費される準備ができていること、有効な信号とFSM信号を。
受信機からのレディ信号に、FSMの移動は、次POPCOUNTを計算する準備ができて、\code{Idle}状態に戻り。
\fi

\ifshoworiginal
The top level component, shown in Listing~\ref{lst:pop:top} instantiates the FSM and the datapath components and connects
them with bulk connections.
\fi

\ifshowtransfirst %(自動翻訳)
リスト〜\ref{lst:pop:top}に示すトップレベルのコンポーネントは、FSMとデータパスコンポーネントをインスタンス化し、バルク接続とそれらを接続します。
\fi

\ifshowtranssecond %(校正 TODO)
リスト〜\ref{lst:pop:top}に示すトップレベルのコンポーネントは、FSMとデータパスコンポーネントをインスタンス化し、バルク接続とそれらを接続します。
\fi

\longlist{code/popcnt_main.txt}{The top level of the popcount circuit.
\todo{Bulk connection should be used here (and tested).}}{lst:pop:top}

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/popcnt-data}
  \caption{Datapath for the popcount circuit.}
  \label{fig:popcnt-data}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:popcnt-data} shows the datapath for the popcount circuit.
The data is loaded into the \code{shf} register. On the load also the \code{cnt}
register is reset to 0. To count the number of `1's, the \code{shf} register is shifted
right, and the least significant bit is added to \code{cnt} each clock cycle.
A counter, not shown in the figure, counts down until all bits have been shifted
through the least significant bit. When the counter reaches zero, the popcount
has finished. The FSM switches to state \code{Done} and signals the result
by asserting \code{popCntReady}. When the result is read, signaled by asserting
\code{popCntValid} the FSW switches back to \code{Idle}.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:popcnt-data}はPOPCOUNT回路のためのデータパスを示しています。
データは\code{shf}レジスタにロードされます。
負荷にも\code{cnt}レジスタが0にリセットされます。
`1つの数をカウントするには、\code{shf}レジスタは右にシフトし、最下位ビットは、各クロックサイクル\code{cnt}に追加されます。
すべてのビットが最下位ビットを介してシフトされるまで、図には示されていないカウンタは、カウントダウン。
カウンタが0に達すると、POPCOUNTが完了しました。
FSMは状態\code{Done}及び信号に\code{popCntReady}をアサートすることによって結果を切り替えます。
結果が読み取られると、FSWはバック\code{Idle}に切り替え\code{popCntValid}をアサートすることによって合図。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:popcnt-data}はPOPCOUNT回路のためのデータパスを示しています。
データは\code{shf}レジスタにロードされます。
負荷にも\code{cnt}レジスタが0にリセットされます。
`1つの数をカウントするには、\code{shf}レジスタは右にシフトし、最下位ビットは、各クロックサイクル\code{cnt}に追加されます。
すべてのビットが最下位ビットを介してシフトされるまで、図には示されていないカウンタは、カウントダウン。
カウンタが0に達すると、POPCOUNTが完了しました。
FSMは状態\code{Done}及び信号に\code{popCntReady}をアサートすることによって結果を切り替えます。
結果が読み取られると、FSWはバック\code{Idle}に切り替え\code{popCntValid}をアサートすることによって合図。
\fi


\ifshoworiginal
On a \code{load} signal, the \code{regData} register is loaded with the input,
the \code{regPopCount} register reset to 0, and the counter register \code{regCount}
set to the number of shifts to be performed.
\fi

\ifshowtransfirst %(自動翻訳)
\code{load}信号に、\code{regData}レジスタが0に\code{regPopCount}レジスタリセット入力がロードされ、カウンタは、実行されるシフトの数に\code{regCount}セットを登録します。
\fi

\ifshowtranssecond %(校正 TODO)
\code{load}信号に、\code{regData}レジスタが0に\code{regPopCount}レジスタリセット入力がロードされ、カウンタは、実行されるシフトの数に\code{regCount}セットを登録します。
\fi

\longlist{code/popcnt_data.txt}{Datapath of the popcount circuit.}{lst:pop:data}
\longlist{code/popcnt_fsm.txt}{The FSM of the popcount circuit.}{lst:pop:fsm}

\ifshoworiginal
Otherwise, the \code{regData} register is shifted to the right, the least significant bit
of the \code{regData} register added to the \code{regPopCount} register, and the counter
decremented until it is 0. When the counter is 0, the output contains the popcount.
Listing~\ref{lst:pop:data} shows the Chisel code for the datapath of the popcount
circuit.
\fi

\ifshowtransfirst %(自動翻訳)
そうでなければ、\code{regData}レジスタは、右\code{regData}の最下位ビットが0になるまで\code{regPopCount}レジスタに添加し、そしてカウンタをデクリメントレジスタにシフトされます。
カウンタが0の場合、出力はPOPCOUNTが含まれています。
一覧〜\ref{lst:pop:data}はPOPCOUNT回路のデータパスのためのChiselコードを示します。
\fi

\ifshowtranssecond %(校正 TODO)
そうでなければ、\code{regData}レジスタは、右\code{regData}の最下位ビットが0になるまで\code{regPopCount}レジスタに添加し、そしてカウンタをデクリメントレジスタにシフトされます。
カウンタが0の場合、出力はPOPCOUNTが含まれています。
一覧〜\ref{lst:pop:data}はPOPCOUNT回路のデータパスのためのChiselコードを示します。
\fi


\ifshoworiginal
The FSM starts in state \code{idle}. On a valid signal for the input data (\code{dinValid}) it
switches to the \code{count} state and waits till the datapath has finished counting.
When the popcount is valid, the FSM switches to state \code{done} and waits till the
popcount is read (signaled by \code{popCntReady}).
Listing~\ref{lst:pop:fsm} shows the code of the FSM.
\fi

\ifshowtransfirst %(自動翻訳)
FSMは状態\code{idle}で起動します。
入力データの有効信号（\code{dinValid}）には\code{count}状態に切り替わり、データパスまで待機は、完成したカウントを有します。
POPCOUNTが有効である場合、FSMは状態\code{done}に切り替わり、POPCOUNTまで待機を読み取る（\code{popCntReady}によって合図されます）。
一覧〜\ref{lst:pop:fsm}は、FSMのコードを示します。
\fi

\ifshowtranssecond %(校正 TODO)
FSMは状態\code{idle}で起動します。
入力データの有効信号（\code{dinValid}）には\code{count}状態に切り替わり、データパスまで待機は、完成したカウントを有します。
POPCOUNTが有効である場合、FSMは状態\code{done}に切り替わり、POPCOUNTまで待機を読み取る（\code{popCntReady}によって合図されます）。
一覧〜\ref{lst:pop:fsm}は、FSMのコードを示します。
\fi

\ifshoworiginal
\section{Ready-Valid Interface}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Ready-Valid Interface}
\fi
\ifshowtranssecond %(校正)
\section{Ready-Valid インターフェース (L9462 TODO)}
\fi

\index{Ready-valid interface}

\ifshoworiginal
Communication of subsystems can be generalized to the movement
of data and handshaking for flow control. In the popcount example,
we have seen a handshaking interface for the input and the output data
using valid and ready signals.
\fi

\ifshowtransfirst %(自動翻訳)
サブシステムの通信は、データフロー制御のためのハンドシェイクの動きに一般化することができます。
POPCOUNTの例では、我々は有効とレディ信号を使用して、入力および出力データのためのハンドシェイク・インタフェースを見てきました。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
サブシステムの通信は、データの移動とフロー制御のためのハンドシェイクに一般化することができます。
ポップカウントの例では、有効信号とレディ信号を使用した入力データと出力データのハンドシェイク・インターフェースを見てきました。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/readyvalid}
  \caption{The ready-valid flow control.}
  \label{fig:readyvalid}
\end{figure}

\ifshoworiginal
The ready-valid interface~\cite[p.~480]{dally:vhdl:2016} is a simple flow
control interface consisting of \code{data} and a \code{valid} signal at the
sender side (producer) and a \code{ready} signal at the receiver side (consumer).
Figure~\ref{fig:readyvalid} shows the ready-valid connection.
The sender asserts \code{valid} when \code{data} is available,
and the receiver asserts \code{ready} when it is ready to receive one word
of data. The transmission of the data happens when both signals, \code{valid}
and \code{ready}, are asserted. If either of the two signals is not asserted,
no transfer takes place.
\fi

\ifshowtransfirst %(自動翻訳)
即時有効なインターフェイス〜\cite[p.~480]{dally:vhdl:2016}送信側で\code{data}と\code{valid}信号からなるインタフェースシンプルフロー制御（生産者）と受信側（消費者）に\code{ready}信号です。
図〜\ref{fig:readyvalid}は、すぐ有効な接続を示しています。
\code{data}が利用可能な場合、送信者は\code{valid}をアサートし、1ワードのデータを受信する準備ができているとき、受信機は\code{ready}を主張します。
両方の信号、\code{valid}及び\code{ready}が、アサートされたときにデータの送信が起こります。
2つの信号のいずれかがアサートされていない場合、転送は行われません。
\fi

\ifshowtranssecond %(校正 TODO)
即時有効なインターフェイス〜\cite[p.~480]{dally:vhdl:2016}送信側で\code{data}と\code{valid}信号からなるインタフェースシンプルフロー制御（生産者）と受信側（消費者）に\code{ready}信号です。
図〜\ref{fig:readyvalid}は、すぐ有効な接続を示しています。
\code{data}が利用可能な場合、送信者は\code{valid}をアサートし、1ワードのデータを受信する準備ができているとき、受信機は\code{ready}を主張します。
両方の信号、\code{valid}及び\code{ready}が、アサートされたときにデータの送信が起こります。
2つの信号のいずれかがアサートされていない場合、転送は行われません。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=1]{figures/ready_valid1}
  \caption{Data transfer with a ready-valid interface, early ready}
  \label{fig:ready_valid1}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:ready_valid1} shows a timing diagram of the ready-valid
transaction where the receiver signals \code{ready} (from clock cycle 1 on)
before the sender has data. The data transfer happens in clock cycle 3.
From clock cycle 4 on neither the sender has data nor the receiver is ready
for the next transfer.
When the receiver can receive data in every clock cycle, it is called an
``always ready'' interface and \code{ready} can be hardcoded to \code{true}.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:ready_valid1}は、送信者がデータを有する前に、受信機は、（上のクロックサイクル1から）\code{ready}に信号をすぐ有効なトランザクションのタイミング図を示しています。
データ転送は、クロックサイクル3において起こります。
送信者どちらのクロックサイクル4からのデータを持っていたり、受信機は、次の転送の準備ができています。
受信機は、クロック・サイクルごとにデータを受信できた場合、 ``常に準備ができて「」インタフェースと\code{ready}が\code{true}にハードコードすることが可能と呼ばれています。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:ready_valid1}は、送信者がデータを有する前に、受信機は、（上のクロックサイクル1から）\code{ready}に信号をすぐ有効なトランザクションのタイミング図を示しています。
データ転送は、クロックサイクル3において起こります。
送信者どちらのクロックサイクル4からのデータを持っていたり、受信機は、次の転送の準備ができています。
受信機は、クロック・サイクルごとにデータを受信できた場合、 ``常に準備ができて「」インタフェースと\code{ready}が\code{true}にハードコードすることが可能と呼ばれています。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=1]{figures/ready_valid2}
  \caption{Data transfer with a ready-valid interface, late ready}
  \label{fig:ready_valid2}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:ready_valid2} shows a timing diagram of the ready-valid
transaction where the sender signals \code{valid} (from clock cycle 1 on)
before the receiver is ready. The data transfer happens in clock cycle 3.
From clock cycle 4 on neither the sender has data nor the receiver is ready
for the next transfer.
Similar to the ``always ready'' interface we can envision and always valid
interface. However, in that case the data will probably not change on signaling
\code{ready} and we would simply drop the handshake signals.
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:ready_valid2}は、受信前（上のクロックサイクル1から）送信側信号\code{valid}の準備ができてすぐ有効なトランザクションのタイミング図を示しています。
データ転送は、クロックサイクル3において起こります。
送信者どちらのクロックサイクル4からのデータを持っていたり、受信機は、次の転送の準備ができています。
``常に準備ができて「」常に我々が想像できるインターフェイスと有効なインターフェイスに似ています。
ただし、その場合にはデータは、おそらく\code{ready}のシグナリングに変更されませんし、我々は単にハンドシェーク信号をドロップします。
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:ready_valid2}は、受信前（上のクロックサイクル1から）送信側信号\code{valid}の準備ができてすぐ有効なトランザクションのタイミング図を示しています。
データ転送は、クロックサイクル3において起こります。
送信者どちらのクロックサイクル4からのデータを持っていたり、受信機は、次の転送の準備ができています。
``常に準備ができて「」常に我々が想像できるインターフェイスと有効なインターフェイスに似ています。
ただし、その場合にはデータは、おそらく\code{ready}のシグナリングに変更されませんし、我々は単にハンドシェーク信号をドロップします。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=1]{figures/ready_valid3}
  \caption{Single cycle ready/valid and back-to-back trasnfers}
  \label{fig:ready_valid3}
\end{figure}

\ifshoworiginal
Figure~\ref{fig:ready_valid2} shows further variations of the ready-valid
interface. In clock cycle 1 both signals (\code{ready} and \code{valid}
become asserted just for a single clock cycle and the data transfer
of \code{D1} happens. Data can be transferred back-to-back (in every
clock cycle) as shown in clock cycles 4 and 5 with the transfer of
\code{D2} and \code{D3}
\fi

\ifshowtransfirst %(自動翻訳)
図〜\ref{fig:ready_valid2}は、すぐ有効なインターフェイスの更なる変化を示しています。
クロックサイクル1において、両信号（\code{ready}と\code{valid}はちょうど単一のクロック・サイクルの間アサートと\code{D1}のデータ転送が起こるとなります。
\code{D2}と\code{D3}の転送にクロックサイクル4および5に示すように、データは、バックツーバック（クロックサイクル毎に）に転送することができます
\fi

\ifshowtranssecond %(校正 TODO)
図〜\ref{fig:ready_valid2}は、すぐ有効なインターフェイスの更なる変化を示しています。
クロックサイクル1において、両信号（\code{ready}と\code{valid}はちょうど単一のクロック・サイクルの間アサートと\code{D1}のデータ転送が起こるとなります。
\code{D2}と\code{D3}の転送にクロックサイクル4および5に示すように、データは、バックツーバック（クロックサイクル毎に）に転送することができます
\fi

\ifshoworiginal
To make this interface composable neither \code{ready} not \code{valid} is
allowed to depend combinational on the other signal.
As this interface is so common, Chisel defines the \code{DecoupledIO}
bundle, similar to the following:
\fi

\ifshowtransfirst %(自動翻訳)
このインタフェースは、構成可能なようにするにはどちらもない\code{ready}は\code{valid}は、他の信号に組み合わせ依存するように許可されません。
このインタフェースは、一般的であるように、Chiselは、次のような\code{DecoupledIO}バンドルを定義します。
\fi

\ifshowtranssecond %(校正 TODO)
このインタフェースは、構成可能なようにするにはどちらもない\code{ready}は\code{valid}は、他の信号に組み合わせ依存するように許可されません。
このインタフェースは、一般的であるように、Chiselは、次のような\code{DecoupledIO}バンドルを定義します。
\fi

\shortlist{code/fifo_decoupled.txt}

\ifshoworiginal
\noindent The \code{DecoupledIO} bundle is parameterized with the type for
the \code{data}. The interface defined by Chisel uses the field \code{bits}
for the data.
\fi

\ifshowtransfirst %(自動翻訳)
\code{DecoupledIO}バンドルは\code{data}の型でパラメータ化され。
Chiselによって定義されたインタフェースは、データのフィールド\code{bits}を使用しています。
\fi

\ifshowtranssecond %(校正 TODO)
\code{DecoupledIO}バンドルは\code{data}の型でパラメータ化され。
Chiselによって定義されたインタフェースは、データのフィールド\code{bits}を使用しています。
\fi

\ifshoworiginal
One question remains if the \code{ready} or \code{valid} may be de-asserted
after being active and \emph{no} data transfer has happened.
For example a receiver might be ready for some time and not receiving data, but
due to some other events may become not ready.
The same can be envisioned with the sender, having data valid only some clock
clock cycles and becoming non-valid without a data transfer.
If this behavior is allowed or not is not part of the ready-valid interface,
but needs to be defined by the concrete usage of the interface.
\fi

\ifshowtransfirst %(自動翻訳)
\code{ready}または\code{valid}がアクティブと\emph{no}データ転送された後にディアサートされる場合は、1つ疑問が残るが起こっています。
例えば、受信機は、いくつかの時間のために準備し、データを受信して​​いないかもしれないが、いくつかの他のイベントのためには準備ができていないことがあります。
同じことが、データ転送せずに一部だけクロッククロックサイクルとなってきて非有効な有効なデータを持つ、送信者と想定することができます。
場合は、この動作を許可するかの準備ができていません - 有効なインターフェイスの一部ではなく、インターフェースの具体的な使用方法で定義する必要があります。
\fi

\ifshowtranssecond %(校正 TODO)
\code{ready}または\code{valid}がアクティブと\emph{no}データ転送された後にディアサートされる場合は、1つ疑問が残るが起こっています。
例えば、受信機は、いくつかの時間のために準備し、データを受信して​​いないかもしれないが、いくつかの他のイベントのためには準備ができていないことがあります。
同じことが、データ転送せずに一部だけクロッククロックサイクルとなってきて非有効な有効なデータを持つ、送信者と想定することができます。
場合は、この動作を許可するかの準備ができていません - 有効なインターフェイスの一部ではなく、インターフェースの具体的な使用方法で定義する必要があります。
\fi

\ifshoworiginal
Chisel places no requirements on the signaling of \code{ready} and \code{valid}
when using the class \code{DecoupledIO}.
However, the class \code{IrrevocableIO} places following restrictions
on the sender:
\fi

\ifshowtransfirst %(自動翻訳)
クラス\code{DecoupledIO}を使用した場合Chiselは\code{ready}と\code{valid}のシグナリングに何の要件を置きません。
しかし、クラス\code{IrrevocableIO}は、送信者に次のような制限を課します。
\fi

\ifshowtranssecond %(校正 TODO)
クラス\code{DecoupledIO}を使用した場合Chiselは\code{ready}と\code{valid}のシグナリングに何の要件を置きません。
しかし、クラス\code{IrrevocableIO}は、送信者に次のような制限を課します。
\fi

\ifshoworiginal
\begin{quote}
A concrete subclass of \code{ReadyValidIO} that promises to not change
the value of \code{bits} after a cycle where \code{valid} is high and \code{ready} is low.
Additionally, once \code{valid} is raised it will never be lowered until after
\code{ready} has also been raised.
\end{quote}
\fi

\ifshowtransfirst %(自動翻訳)
約束は\code{valid}が高く、\code{ready}が低いサイクル後\code{bits}の値を変更しないために、その\code{ReadyValidIO}の具象サブクラス。
\code{valid}を上昇させた後さらに、それは\code{ready}も提起された後にまで低下することはありません。
\fi

\ifshowtranssecond %(校正 TODO)
約束は\code{valid}が高く、\code{ready}が低いサイクル後\code{bits}の値を変更しないために、その\code{ReadyValidIO}の具象サブクラス。
\code{valid}を上昇させた後さらに、それは\code{ready}も提起された後にまで低下することはありません。
\fi

\ifshoworiginal
\noindent Note that this is a convention that cannot be enforced by using the class
\fi

\ifshowtransfirst %(自動翻訳)
これはクラス\code{IrrevocableIO}を使用して実施することができない規則であることに注意してください。
\fi

\ifshowtranssecond %(校正 TODO)
これはクラス\code{IrrevocableIO}を使用して実施することができない規則であることに注意してください。
\fi

\code{IrrevocableIO}.

\ifshoworiginal
AXI uses one ready-valid interface for each of the following parts of the bus:
read address, read data, write address, and write data. AXI restricts the interface
that once \code{ready} or \code{valid} is asserted it is not allowed to get de-asserted
until the data transfer happened.
\fi

\ifshowtransfirst %(自動翻訳)
読み出しアドレスデータ、書き込みアドレス、書き込みデータを読み込む：AXIバスの以下の部分ごとに1つの既製有効なインターフェイスを使用しています。
AXIは\code{ready}または\code{valid}がアサートされると、データ転送が起こったまでデアサート取得するために許可されていないことインタフェースを制限します。
\fi

\ifshowtranssecond %(校正 TODO)
読み出しアドレスデータ、書き込みアドレス、書き込みデータを読み込む：AXIバスの以下の部分ごとに1つの既製有効なインターフェイスを使用しています。
AXIは\code{ready}または\code{valid}がアサートされると、データ転送が起こったまでデアサート取得するために許可されていないことインタフェースを制限します。
\fi

\todo{Read and cite AXI, and check if the above is true}

\ifshoworiginal
\chapter{Hardware Generators}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Hardware Generators}
\fi
\ifshowtranssecond %(校正)
\chapter{ハードウェアジェネレータ (L9245 TODO)} %(校正  第10章  ========================================================================)
\fi

\index{Hardware generators}

\ifshoworiginal
The strength of Chisel is that it allows us to write so-called hardware generators.
With older hardware description languages, such as VHDL and Verilog,
we usually use another language, e.g., Java or Python, to generate hardware.
The author has often written small Java programs to generate VHDL tables.
In Chisel, the full power of Scala (and Java libraries) is available at hardware
construction. Therefore, we can write our hardware generators in the same
language and execute them as part of the Chisel circuit generation.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselの強さは、それが、私たちは、いわゆるハードウェアジェネレータを書くことができることです。
そのようなVHDLおよびVerilogなどの古いハードウェア記述言語、で、我々は通常、別の言語、Eを使用しています。
グラム。
、JavaやPythonの、ハードウェアを生成します。
著者は、多くの場合、VHDLテーブルを生成するために、小さなJavaプログラムを書いています。
Chiselでは、スカラ（及びJavaライブラリー）のフルパワーは、ハードウェア構成で利用可能です。
したがって、我々は同じ言語で、当社ハードウェアジェネレータを書いて、Chisel回路生成の一部としてそれらを実行することができます。
\fi

\ifshowtranssecond %(校正 TODO)
Chiselの強さは、それが、私たちは、いわゆるハードウェアジェネレータを書くことができることです。
そのようなVHDLおよびVerilogなどの古いハードウェア記述言語、で、我々は通常、別の言語、Eを使用しています。
グラム。
、JavaやPythonの、ハードウェアを生成します。
著者は、多くの場合、VHDLテーブルを生成するために、小さなJavaプログラムを書いています。
Chiselでは、スカラ（及びJavaライブラリー）のフルパワーは、ハードウェア構成で利用可能です。
したがって、我々は同じ言語で、当社ハードウェアジェネレータを書いて、Chisel回路生成の一部としてそれらを実行することができます。
\fi

\ifshoworiginal
\section{Configure with Parameters}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Configure with Parameters}
\fi
\ifshowtranssecond %(校正)
\section{パラメータを使って設定する (L8932 TODO)}
\fi

\index{Parameters}

\ifshoworiginal
Chisel components and functions can be configured with parameters.
Parameters can be as simple as an integer constant, but can also be a Chisel
hardware type.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselコンポーネントおよび機能は、パラメータで設定することができます。
パラメータは、整数定数のような単純なようであることができるだけでなく、Chiselハードウェアのタイプとすることができます。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
Chiselのコンポーネントや関数は、パラメータを使って設定することができます。
パラメータは整数定数のようなシンプルなものから、Chiselのハードウェアタイプのものまであります。
\fi

\ifshoworiginal
\subsection{Simple Parameters}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Simple Parameters}
\fi
\ifshowtranssecond %(校正)
\subsection{シンプルなパラメータ (L9816 TODO)}
\fi

\ifshoworiginal
The basic way to parameterize a circuit is to define a bit width as a parameter.
Parameters can be passed as arguments to
the constructor of the Chisel module. Following example is a toy example of
a module that implements an adder with a configurable bit width.
The bit width \code{n} is a parameter (of Scala type \code{Int}) of the component
passed into the constructor that can be used in the IO bundle.
\fi

\ifshowtransfirst %(自動翻訳)
回路をパラメータ化するための基本的な方法は、パラメータとしてビット幅を定義することです。
パラメータは、Chiselモジュールのコンストラクタの引数として渡すことができます。
例に続いて、設定ビット幅の加算器を実装モジュールのおもちゃの一例です。
\code{n}幅ビットがIOバンドルに使用することができるコンストラクタに渡された成分の（スカラ型\code{Int}の）パラメータです。
\fi

\ifshowtranssecond %(校正 TODO)
回路をパラメータ化するための基本的な方法は、パラメータとしてビット幅を定義することです。
パラメータは、Chiselモジュールのコンストラクタの引数として渡すことができます。
例に続いて、設定ビット幅の加算器を実装モジュールのおもちゃの一例です。
\code{n}幅ビットがIOバンドルに使用することができるコンストラクタに渡された成分の（スカラ型\code{Int}の）パラメータです。
\fi

\shortlist{code/param_adder.txt}

\ifshoworiginal
\noindent Parameterized versions of the adder can be created as follows:
\fi

\ifshowtransfirst %(自動翻訳)
次のように加算器のパラメータ化されたバージョンを作成することができます。
\fi

\ifshowtranssecond %(校正 TODO)
次のように加算器のパラメータ化されたバージョンを作成することができます。
\fi

\shortlist{code/use_param_adder.txt}

\ifshoworiginal
\subsection{Functions with Type Parameters}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Functions with Type Parameters}
\fi
\ifshowtranssecond %(校正)
\subsection{型パラメータを持つ関数 (L9865 TODO)}
\fi

\index{Type parameters}

\ifshoworiginal
Having the bit width as a configuration parameter is just the starting point for
hardware generators. A very flexible configuration is the usage of types.
That feature allows for Chisel to provide a multiplexer (\code{Mux}) that
can accept any types for the multiplexing.
To show how to use types for the configuration, we build a multiplexer
that accepts arbitrary types. Following function defines the multiplexer:
\fi

\ifshowtransfirst %(自動翻訳)
設定パラメータとしてビット幅を有するハードウェア発生のためだけの出発点です。
非常に柔軟な構成は、型の使用です。
Chiselは、多重化のための任意のタイプを受け入れることができ、マルチプレクサ（\code{Mux}）を提供するためにその機能が可能となります。
コンフィギュレーションのための型を使用する方法を示すために、我々は、任意のタイプを受け入れるマルチプレクサを構築します。
次の関数は、マルチプレクサを定義します。
\fi

\ifshowtranssecond %(校正 TODO)
設定パラメータとしてビット幅を有するハードウェア発生のためだけの出発点です。
非常に柔軟な構成は、型の使用です。
Chiselは、多重化のための任意のタイプを受け入れることができ、マルチプレクサ（\code{Mux}）を提供するためにその機能が可能となります。
コンフィギュレーションのための型を使用する方法を示すために、我々は、任意のタイプを受け入れるマルチプレクサを構築します。
次の関数は、マルチプレクサを定義します。
\fi

\shortlist{code/param_func.txt}


\ifshoworiginal
Chisel allows parameterizing functions with types, in our case with Chisel
types. The expression in the square brackets \code{[T <: Data]} defines
a type parameter \code{T} set is \code{Data} or a subclass of \code{Data}.
\code{Data} is the root of the Chisel type system.
\fi

\ifshowtransfirst %(自動翻訳)
ChiselはChiselタイプと我々の場合には、型をパラメータ化機能を可能にします。
角括弧内の式\code{[T <: Data]}定義型\code{T}セットパラメータは\code{Data}又は\code{Data}のサブクラスです。
\code{Data}はChisel型システムのルートです。
\fi

\ifshowtranssecond %(校正 TODO)
ChiselはChiselタイプと我々の場合には、型をパラメータ化機能を可能にします。
角括弧内の式\code{[T <: Data]}定義型\code{T}セットパラメータは\code{Data}又は\code{Data}のサブクラスです。
\code{Data}はChisel型システムのルートです。
\fi

\ifshoworiginal
Our multiplexer function has three parameters: the boolean condition,
one parameter for the true path, and one parameter for the false path.
Both path parameters are of type \code{T}, an information that is
provided at function call. The function itself is straight forward:
we define a wire with the default value of \code{fPath} and
change the value if the condition is true to the \code{tPath}.
This condition is a classic multiplexer function.
At the end of the function, we return the multiplexer hardware.
\fi

\ifshowtransfirst %(自動翻訳)
ブール条件、真のパスに1つのパラメータ、および偽のパスのための一つのパラメータ：当社のマルチプレクサ機能は、次の3つのパラメータがあります。
両方のパスパラメータがタイプ\code{T}、関数呼び出しで提供される情報です。
機能自体は単純です：私たちは\code{fPath}のデフォルト値を持つ線を定義し、条件が\code{tPath}に真である場合には、値を変更します。
この条件は、古典的なマルチプレクサ機能です。
関数の最後に、我々は、マルチプレクサのハードウェアを返します。
\fi

\ifshowtranssecond %(校正 TODO)
ブール条件、真のパスに1つのパラメータ、および偽のパスのための一つのパラメータ：当社のマルチプレクサ機能は、次の3つのパラメータがあります。
両方のパスパラメータがタイプ\code{T}、関数呼び出しで提供される情報です。
機能自体は単純です：私たちは\code{fPath}のデフォルト値を持つ線を定義し、条件が\code{tPath}に真である場合には、値を変更します。
この条件は、古典的なマルチプレクサ機能です。
関数の最後に、我々は、マルチプレクサのハードウェアを返します。
\fi

\ifshoworiginal
We can use our multiplexer function with simple types such as
\code{UInt}:
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、このような\code{UInt}ような単純なタイプで、当社のマルチプレクサ機能を使用することができます。
\fi

\ifshowtranssecond %(校正 TODO)
私たちは、このような\code{UInt}ような単純なタイプで、当社のマルチプレクサ機能を使用することができます。
\fi

\shortlist{code/param_func_simple.txt}

\ifshoworiginal
\noindent The types of the two multiplexer paths need to be the same.
Following wrong usage of the multiplexer results in a runtime error:
\fi

\ifshowtransfirst %(自動翻訳)
2つのマルチプレクサのパスの種類は同じである必要があります。
ランタイムエラーでマルチプレクサ結果の誤った使用方法を以下に示します。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
2 つのマルチプレクサパスのタイプは同じである必要があります。
以下のように、マルチプレクサの使用法を間違えるとランタイムエラーになります。
\fi

\shortlist{code/param_func_wrong.txt}

\ifshoworiginal
\noindent We define our type as a \code{Bundle} with two fields:
\fi

\ifshowtransfirst %(自動翻訳)
我々は2つのフィールドを持つ\code{Bundle}として私たちのタイプを定義します。
\fi

\ifshowtranssecond %(校正 TODO)
我々は2つのフィールドを持つ\code{Bundle}として私たちのタイプを定義します。
\fi

\shortlist{code/param_func_type.txt}

\ifshoworiginal
\noindent We can define \code{Bundle} constants by first creating
a \code{Wire} and then setting the subfields.
Then we can use our parameterized multiplexer with this complex type.
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、最初の\code{Wire}を作成し、サブフィールドを設定することにより、\code{Bundle}定数を定義することができます。
その後、我々は、この複合型で、当社のパラメータ化マルチプレクサを使用することができます。
\fi

\ifshowtranssecond %(校正 TODO)
私たちは、最初の\code{Wire}を作成し、サブフィールドを設定することにより、\code{Bundle}定数を定義することができます。
その後、我々は、この複合型で、当社のパラメータ化マルチプレクサを使用することができます。
\fi

\shortlist{code/param_func_complex.txt}

\ifshoworiginal
In our initial design of the function, we used \code{WireDefault}
to create a wire with the type \code{T} with a default value.
If we need to create a wire just of the Chisel type without using a default
value, we can use \code{fPath.cloneType} to get the Chisel type.
Following function shows the alternative way to code the multiplexer.
\fi

\ifshowtransfirst %(自動翻訳)
機能の私たちの最初の設計では、デフォルト値を持つタイプ\code{T}と線を作成するために\code{WireDefault}を使用しました。
私たちは、デフォルト値を使用せずに、単にChisel型のワイヤーを作成する必要がある場合、我々はChiselタイプを取得するために\code{fPath.cloneType}を使用することができます。
機能ショー、次のマルチプレクサをコーディングする別の方法。
\fi

\ifshowtranssecond %(校正 TODO)
機能の私たちの最初の設計では、デフォルト値を持つタイプ\code{T}と線を作成するために\code{WireDefault}を使用しました。
私たちは、デフォルト値を使用せずに、単にChisel型のワイヤーを作成する必要がある場合、我々はChiselタイプを取得するために\code{fPath.cloneType}を使用することができます。
機能ショー、次のマルチプレクサをコーディングする別の方法。
\fi

\shortlist{code/param_func_alt.txt}

\ifshoworiginal
\subsection{Modules with Type Parameters}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Modules with Type Parameters}
\fi
\ifshowtranssecond %(校正)
\subsection{タイプパラメータを持つモジュール (10036 TODO)}
\fi

\ifshoworiginal
We can also parameterize modules with Chisel types.
Let us assume we want to design a network-on-chip to move data between
different processing cores. However, we do not want to hardcode the
data format in the router interface; we want to \emph{parameterize} it.
Similar to the type parameter for a function, we add a type parameter \code{T}
to the Module constructor. Furthermore, we need to have one constructor
parameter of that type. Additionally, in this example, we also make the number
of router ports configurable.
\fi

\ifshowtransfirst %(自動翻訳)
また、Chiselタイプとモジュールのパラメータを設定することができます。
私たちは別の処理コアの間でデータを移動するために、ネットワーク・オン・チップを設計したいと仮定しましょう。
しかし、我々は、ルータインターフェイスでのデータ形式をハードコーディングする必要はありません。我々は\emph{parameterize}それにしたいです。
関数の型パラメータと同様に、我々は、モジュールのコンストラクタに\code{T}パラメータタイプを追加します。
さらに、我々はそのタイプの1つのコンストラクタのパラメータを持っている必要があります。
また、この例では、我々はまた、ルータのポート数を設定可能にします。
\fi

\ifshowtranssecond %(校正 TODO)
また、Chiselタイプとモジュールのパラメータを設定することができます。
私たちは別の処理コアの間でデータを移動するために、ネットワーク・オン・チップを設計したいと仮定しましょう。
しかし、我々は、ルータインターフェイスでのデータ形式をハードコーディングする必要はありません。我々は\emph{parameterize}それにしたいです。
関数の型パラメータと同様に、我々は、モジュールのコンストラクタに\code{T}パラメータタイプを追加します。
さらに、我々はそのタイプの1つのコンストラクタのパラメータを持っている必要があります。
また、この例では、我々はまた、ルータのポート数を設定可能にします。
\fi

\shortlist{code/param_mod.txt}

\ifshoworiginal
\noindent To use our router, we first need to define the data type we want to route, e.g.,
as a Chisel \code{Bundle}:
\fi

\ifshowtransfirst %(自動翻訳)
私たちのルータ、ルートに私たちが望むデータ型を定義するために、私たち最初の必要性、電子を使用します。
グラム。
、Chisel\code{Bundle}として：
\fi

\ifshowtranssecond %(校正 TODO)
私たちのルータ、ルートに私たちが望むデータ型を定義するために、私たち最初の必要性、電子を使用します。
グラム。
、Chisel\code{Bundle}として：
\fi

\shortlist{code/param_mod_type.txt}

\ifshoworiginal
\noindent We create a router by passing an instance of the user-defined Bundle and
the number of ports to the constructor of the router:
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、ルータのコンストラクタに、ユーザー定義のバンドルやポートの数のインスタンスを渡すことによって、ルータを作成します。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
\noindent ルータのコンストラクタにユーザ定義のBundleのインスタンスとポート数を渡してルータを作成します。
\fi

\shortlist{code/param_mod_use.txt}

\ifshoworiginal
\subsection{Parameterized Bundles}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Parameterized Bundles}
\fi
\ifshowtranssecond %(校正)
\subsection{パラメータ化されたバンドル (L9225 TODO)}
\fi

\ifshoworiginal
In the router example, we used two different vectors of fields for the input
of the router: one for the address and one for the data, which was parameterized.
A more elegant solution would be to have a \code{Bundle} that itself
is parametrized. Something like:
\fi

\ifshowtransfirst %(自動翻訳)
アドレスのための1つおよびパラメータ化されたデータのためのいずれかのルータの例では、ルータの入力用フィールドの二つの異なるベクターを使用します。
よりエレガントな解決策は、それ自体がパラメータ化されていることを\code{Bundle}を持っていることであろう。
何かのようなもの：
\fi

\ifshowtranssecond %(校正 TODO)
アドレスのための1つおよびパラメータ化されたデータのためのいずれかのルータの例では、ルータの入力用フィールドの二つの異なるベクターを使用します。
よりエレガントな解決策は、それ自体がパラメータ化されていることを\code{Bundle}を持っていることであろう。
何かのようなもの：
\fi

\shortlist{code/param_bundle_issue.txt}

\ifshoworiginal
The \code{Bundle} has a parameter of type \code{T}, which is a subtype
of Chisel's \code{Data} type.
Within the bundle, we define a field \code{data} by invoking \code{cloneType}
on the parameter.
However, when we use a constructor parameter, this parameter becomes a
public field of the class. When Chisel needs to clone the type of the \code{Bundle},
e.g., when it is used in a \code{Vec}, this public field is in the way.
A solution (workaround) to this issue is to make the parameter field private:
\fi

\ifshowtransfirst %(自動翻訳)
\code{Bundle}はChiselの\code{Data}型のサブタイプであるタイプ\code{T}のパラメータを持っています。
バンドル内では、我々はパラメータに\code{cloneType}を呼び出すことによって、フィールド\code{data}を定義します。
私たちは、コンストラクタのパラメータを使用する場合ただし、このパラメータは、クラスのパブリックフィールドになります。
Chiselは\code{Bundle}、Eのタイプのクローンを作成する必要がある場合。
グラム。
それは\code{Vec}で使用されている場合、このパブリックフィールドが道です。
この問題の解決策（回避策）は、パラメータフィールドをプライベートにすることです。
\fi

\ifshowtranssecond %(校正 TODO)
\code{Bundle}はChiselの\code{Data}型のサブタイプであるタイプ\code{T}のパラメータを持っています。
バンドル内では、我々はパラメータに\code{cloneType}を呼び出すことによって、フィールド\code{data}を定義します。
私たちは、コンストラクタのパラメータを使用する場合ただし、このパラメータは、クラスのパブリックフィールドになります。
Chiselは\code{Bundle}、Eのタイプのクローンを作成する必要がある場合。
グラム。
それは\code{Vec}で使用されている場合、このパブリックフィールドが道です。
この問題の解決策（回避策）は、パラメータフィールドをプライベートにすることです。
\fi

\shortlist{code/param_bundle.txt}

\ifshoworiginal
\noindent With that new \code{Bundle}, we can define our router ports
\fi

\ifshowtransfirst %(自動翻訳)
その新しい\code{Bundle}では、我々は、ルータのポートを定義することができます
\fi

\ifshowtranssecond %(校正 TODO)
その新しい\code{Bundle}では、我々は、ルータのポートを定義することができます
\fi

\shortlist{code/param_mod2.txt}

\ifshoworiginal
\noindent and instantiate that router with a \code{Port} that takes
a \code{Payload} as a parameter:
\fi

\ifshowtransfirst %(自動翻訳)
パラメータとして\code{Payload}を取る\code{Port}でそのルータをインスタンス化します。
\fi

\ifshowtranssecond %(校正 TODO)
パラメータとして\code{Payload}を取る\code{Port}でそのルータをインスタンス化します。
\fi

\shortlist{code/param_mod_use2.txt}

\ifshoworiginal
\section{Generate Combinational Logic}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Generate Combinational Logic}
\fi
\ifshowtranssecond %(校正)
\section{組合せ論理回路の生成 (L10203 TODO)}
\fi

\index{Logic generation}
\index{Logic table generation}
\label{sec:gen:comb:logic}

\ifshoworiginal
In Chisel, we can easily generate logic by creating a logic table with
a Chisel \code{Vec} from a Scala \code{Array}.
We might have data in a file, that we can read in during hardware generation
time for the logic table.
Listing~\ref{lst:file:reader} shows how to use the Scala \code{Source}
class form the Scala standard library to read the file ``data.txt'', which
contains integer constants in a textual representation.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselでは、我々は簡単にScalaの\code{Array}からChisel\code{Vec}との論理表を作成することにより、ロジックを生成することができます。
我々は、論理テーブルのためのハードウェア生成時間の間で読むことができることを、ファイル内のデータを持っているかもしれません。
一覧〜\ref{lst:file:reader}ショーどのようにファイル ``データを読み込むためのScala標準ライブラリのフォームのScala \code{Source}クラスを使用します。
テキスト表現の定数整数含まTXT「」、。
\fi

\ifshowtranssecond %(校正 TODO)
Chiselでは、我々は簡単にScalaの\code{Array}からChisel\code{Vec}との論理表を作成することにより、ロジックを生成することができます。
我々は、論理テーブルのためのハードウェア生成時間の間で読むことができることを、ファイル内のデータを持っているかもしれません。
一覧〜\ref{lst:file:reader}ショーどのようにファイル ``データを読み込むためのScala標準ライブラリのフォームのScala \code{Source}クラスを使用します。
テキスト表現の定数整数含まTXT「」、。
\fi

\ifshoworiginal
A few words on the maybe a bit intimidating expression:
\fi

\ifshowtransfirst %(自動翻訳)
多分少し威圧的な表現上のいくつかの単語：RRR000DfcAcbmE
\fi

\ifshowtranssecond %(校正 TODO)
多分少し威圧的な表現上のいくつかの単語：RRR000DfcAcbmE
\fi

\begin{chisel}
  val table = VecInit(array.map(_.U(8.W)))
\end{chisel}

\ifshoworiginal
\noindent A Scala \code{Array} can be implicitly converted to a sequence (\code{Seq}),
which supports the mapping function \code{map}.
\code{map} invokes a function on each element of the sequence and returns
a sequence of the return value of the function. Our function \code{\_.U(8.W)} represents
each \code{Int} value from the Scala array as a \code{\_} and performs the conversion
from a Scala \code{Int} value to a Chisel \code{UInt} literal, with a size of 8-bits.
The Chisel object \code{VecInit} creates a Chisel \code{Vec} from a sequence \code{Seq}
of Chisel types.
\fi

\ifshowtransfirst %(自動翻訳)
Aスカラ\code{Array}は、暗黙的に写像関数\code{map}をサポートしている配列（\code{Seq}）に変換することができます。
\code{map}は、配列の各要素に対して関数を呼び出し、関数の戻り値のシーケンスを返します。
我々の機能\code{\_.U(8.W)}は\code{\_}としてScalaのアレイからの各\code{Int}値を表し、8ビットのサイズで、Chisel\code{UInt}のリテラルへスカラRRR011o9mPLVVq値から変換を行います。
Chiselオブジェクト\code{VecInit}は、Chiselタイプのシーケンス\code{Seq}からChisel\code{Vec}を作成します。
\fi

\ifshowtranssecond %(校正 TODO)
Aスカラ\code{Array}は、暗黙的に写像関数\code{map}をサポートしている配列（\code{Seq}）に変換することができます。
\code{map}は、配列の各要素に対して関数を呼び出し、関数の戻り値のシーケンスを返します。
我々の機能\code{\_.U(8.W)}は\code{\_}としてScalaのアレイからの各\code{Int}値を表し、8ビットのサイズで、Chisel\code{UInt}のリテラルへスカラRRR011o9mPLVVq値から変換を行います。
Chiselオブジェクト\code{VecInit}は、Chiselタイプのシーケンス\code{Seq}からChisel\code{Vec}を作成します。
\fi

\index{File reading}

\longlist{code/file_reader.txt}{Reading a text file to generate a logic table.}{lst:file:reader}

\ifshoworiginal
We can use the full power of Scala to generate our logic (tables).
E.g., generate a table of fixpoint constants to represent a trigonometric function,
compute constants for digital filters, or writing a small assembler in Scala
to generate code for a microprocessor written in Chisel. All those functions
are in the same code base (same language) and can be executed during
hardware generation.
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、ロジック（テーブル）を生成するためのScalaのフルパワーを使用することができます。
え。
グラム。
、デジタルフィルタのための三角関数、計算定数を表すために、固定点定数のテーブルを生成、またはChiselで記述されたマイクロプロセッサ用のコードを生成するために、Scalaで小さなアセンブラを書き込みます。
これらすべての機能は、同じコードベース（同じ言語）であり、ハードウェア生成中に実行することができます。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
Scalaのパワーをフルに使って、ロジック（テーブル）を生成することができます。
例えば、三角関数を表現するための指数定数の表を生成したり、デジタルフィルタの定数を計算したり、Chiselで書かれたマイクロプロセッサ用のコードを生成するためにScalaの小さなアセンブラを書いたりすることができます。
これらの関数はすべて同じコードベース（同じ言語）であり、ハードウェア生成中に実行することができます。
\fi

\index{Binary-coded decimal}
\index{BCD}

\ifshoworiginal
A classic example is the conversion of a binary number
into a \myref{https://en.wikipedia.org/wiki/Binary-coded_decimal}{binary-coded decimal}
(BCD) representation. BCD is used to represent a number in a decimal
format using 4 bits fo each decimal digit. For example, decimal \code{13} is in binary
\code{1101} and BCD encoded as 1 and 3 in binary: \code{00010011}.
BCD allows displaying numbers in decimal, a more user-friendly number
representation than hexadecimal.
\fi

\ifshowtransfirst %(自動翻訳)
古典的な例は、\myref{https://en.wikipedia.org/wiki/Binary-coded_decimal}{binary-coded decimal}（BCD）表現に進数の変換です。
BCDは、各進数字の4ビットを使用して10進形式で番号を表すために使用されます。
例えば、小数\code{13}バイナリ\code{1101}であり、BCDはバイナリ1及び3としてエンコード：\code{00010011}。
BCDは小数で表示数、進よりユーザーフレンドリーな数の表現を可能にします。
\fi

\ifshowtranssecond %(校正 TODO)
古典的な例は、\myref{https://en.wikipedia.org/wiki/Binary-coded_decimal}{binary-coded decimal}（BCD）表現に進数の変換です。
BCDは、各進数字の4ビットを使用して10進形式で番号を表すために使用されます。
例えば、小数\code{13}バイナリ\code{1101}であり、BCDはバイナリ1及び3としてエンコード：\code{00010011}。
BCDは小数で表示数、進よりユーザーフレンドリーな数の表現を可能にします。
\fi

\ifshoworiginal
We can write a Java program that computes the table to convert binary to BCD.
That Java program prints out VHDL code that can be included in a project.
The Java program is about 100 lines of code; most of the code generating
VHDL strings. The key part of the conversion is just two lines.
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、BCDに変換バイナリにテーブルを計算するJavaプログラムを書くことができます。
そのJavaプログラムは、プロジェクトに含めることができますVHDLコードを出力します。
Javaプログラムは、コードの100行程度です。コード生成VHDLの文字列のほとんど。
変換の重要な部分は、わずか2行です。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
バイナリをBCDに変換するための表を計算するJavaプログラムを書けます。
そのJavaプログラムは、プロジェクトに含めることができるVHDLコードを出力します。
Javaプログラムは約100行のコードで、コードのほとんどがVHDL文字列を生成します。
変換の重要な部分はわずか2行です。
\fi

\ifshoworiginal
With Chisel, we can compute this table directly as part of the hardware generation.
Listing~\ref{lst:bcd} shows the table generation for the binary to BCD conversion.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselで、我々はハードウェアの世代の一部として直接この表を計算することができます。
一覧〜\ref{lst:bcd}はBCDへの変換バイナリ用テーブルの生成を示しています。
\fi

\ifshowtranssecond %(校正 TODO)
Chiselで、我々はハードウェアの世代の一部として直接この表を計算することができます。
一覧〜\ref{lst:bcd}はBCDへの変換バイナリ用テーブルの生成を示しています。
\fi

\longlist{code/bcd_table.txt}{Binary to binary-coded decimal conversion.}{lst:bcd}

\ifshoworiginal
\section{Use Inheritance}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Use Inheritance}
\fi
\ifshowtranssecond %(校正)
\section{継承を利用する (L10372 TODO)}
\fi

\label{sec:inheritance}

\index{Inheritance}
\index{Object-oriented}

\ifshoworiginal
Chisel is an object-oriented language. A hardware component, the Chisel \code{Module}
is a Scala class. Therefore, we can use inheritance to factor a common behavior
out into a parent class. We explore how to use inheritance with an example.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselは、オブジェクト指向言語です。
ハードウェアコンポーネントは、Chisel\code{Module}はScalaのクラスです。
したがって、我々は、親クラスに要因に共通の動作を継承して使用することができます。
ここでは、例と継承を使用する方法を探ります。
\fi

\ifshowtranssecond %(校正 TODO)
Chiselは、オブジェクト指向言語です。
ハードウェアコンポーネントは、Chisel\code{Module}はScalaのクラスです。
したがって、我々は、親クラスに要因に共通の動作を継承して使用することができます。
ここでは、例と継承を使用する方法を探ります。
\fi

\ifshoworiginal
In Section~\ref{sec:counter} we have explored different forms of counters,
which may be used for a low-frequency tick generation. Let us assume we want to
explore those different versions, e.g., to compare their resource requirement.
We start with an abstract class to define the ticking interface:
\fi

\ifshowtransfirst %(自動翻訳)
節〜\ref{sec:counter}では、低周波ダニの生成に使用することができるカウンターの異なる形態を模索しています。
私たちは、これらの異なるバージョン、電子を探検したいと仮定しましょう。
グラム。
、そのリソース要件を比較します。
私たちは、刻々と過ぎインタフェースを定義する抽象クラスで起動します。
\fi

\ifshowtranssecond %(校正 TODO)
節〜\ref{sec:counter}では、低周波ダニの生成に使用することができるカウンターの異なる形態を模索しています。
私たちは、これらの異なるバージョン、電子を探検したいと仮定しましょう。
グラム。
、そのリソース要件を比較します。
私たちは、刻々と過ぎインタフェースを定義する抽象クラスで起動します。
\fi

\shortlist{code/ticker.txt}

\ifshoworiginal
\noindent Listing~\ref{lst:ticker:up} shows a first implementation of that abstract class
with a counter, counting up, for the tick generation.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:ticker:up}は、ダニの発生のために、カウントアップ、カウンタとその抽象クラスの最初の実装を示しています。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:ticker:up}は、ダニの発生のために、カウントアップ、カウンタとその抽象クラスの最初の実装を示しています。
\fi

\longlist{code/up_ticker.txt}{Tick generation with a counter.}{lst:ticker:up}

\ifshoworiginal
We can test all different versions of our \emph{ticker} logic with a single test bench.
We \emph{just} need to define the test bench to accept subtypes of \code{Ticker}.
Listing~\ref{lst:ticker:test} shows the Chisel code for the tester.
The \code{TickerTester} has several parameters: (1) the type parameter
\code{[T <: Ticker]} to accept a \code{Ticker} or any class that inherits from \code{Ticker},
(2) the design under test, being of type \code{T} or a subtype thereof,
and (3) the number of clock cycles we expect for each tick.
The tester waits for the first occurrence of a tick (the start might be different for
different implementations) and then checks that \code{tick} repeats every $n$ clock cycles.
\fi

\ifshowtransfirst %(自動翻訳)
我々は、単一のテストベンチで私たちの\emph{ticker}ロジックのすべての異なるバージョンをテストすることができます。
我々\code{Ticker}のサブタイプを受け入れるようにテストベンチを定義する必要が\emph{just}。
〜\ref{lst:ticker:test}をリストテスター用Chiselコードを示します。
（1）\code{Ticker}又は\code{T}またはそのサブタイプタイプである\code{Ticker}から継承する任意のクラス、（2）テスト中の設計、およびクロックの（3）数を受け入れる\code{[T <: Ticker]}パラメータタイプ：\code{TickerTester}は、いくつかのパラメータを有しますサイクルは、我々はそれぞれの目盛りのために期待しています。
\code{tick}はすべて$ N $クロックサイクルを繰り返すことティック（開始は異なる実装のために異なるかもしれない）、次いで、チェックの最初の発生のためにテスターを待ちます。
\fi

\ifshowtranssecond %(校正 TODO)
我々は、単一のテストベンチで私たちの\emph{ticker}ロジックのすべての異なるバージョンをテストすることができます。
我々\code{Ticker}のサブタイプを受け入れるようにテストベンチを定義する必要が\emph{just}。
〜\ref{lst:ticker:test}をリストテスター用Chiselコードを示します。
（1）\code{Ticker}又は\code{T}またはそのサブタイプタイプである\code{Ticker}から継承する任意のクラス、（2）テスト中の設計、およびクロックの（3）数を受け入れる\code{[T <: Ticker]}パラメータタイプ：\code{TickerTester}は、いくつかのパラメータを有しますサイクルは、我々はそれぞれの目盛りのために期待しています。
\code{tick}はすべて$ N $クロックサイクルを繰り返すことティック（開始は異なる実装のために異なるかもしれない）、次いで、チェックの最初の発生のためにテスターを待ちます。
\fi

\longlist{code/ticker_tester.txt}{A tester for different versions of the ticker.}{lst:ticker:test}

\ifshoworiginal
With a first, easy implementation of the ticker, we can test the tester
itself, probably with some \code{println} debugging. When we are confident that
the simple ticker and the tester are correct, we can proceed and explore
two more versions of the ticker. Listing~\ref{lst:ticker:down} shows the tick
generation with a counter counting down to 0.
Listing~\ref{lst:ticker:nerd} shows the nerd version of counting down to -1 to use
less hardware by avoiding the comparator.
\fi

\ifshowtransfirst %(自動翻訳)
ティッカーの最初の、簡単な実装では、我々は、おそらくいくつかの\code{println}のデバッグで、テスター自体をテストすることができます。
私たちは、単純なティッカーやテスターが正しいことを確信しているとき、私たちは、ティッカーの2つのバージョンを続行して探索することができます。
一覧〜\ref{lst:ticker:down}は0までカウントダウンカウンタでダニの生成を示しています。
一覧〜\ref{lst:ticker:nerd}は、コンパレータを回避することにより、より少ないハードウェアを使用することに-1カウント・ダウンのオタクのバージョンを示しています。
\fi

\ifshowtranssecond %(校正 TODO)
ティッカーの最初の、簡単な実装では、我々は、おそらくいくつかの\code{println}のデバッグで、テスター自体をテストすることができます。
私たちは、単純なティッカーやテスターが正しいことを確信しているとき、私たちは、ティッカーの2つのバージョンを続行して探索することができます。
一覧〜\ref{lst:ticker:down}は0までカウントダウンカウンタでダニの生成を示しています。
一覧〜\ref{lst:ticker:nerd}は、コンパレータを回避することにより、より少ないハードウェアを使用することに-1カウント・ダウンのオタクのバージョンを示しています。
\fi

\longlist{code/down_ticker.txt}{Tick generation with a down counter.}{lst:ticker:down}

\longlist{code/nerd_ticker.txt}{Tick generation by counting down to -1.}{lst:ticker:nerd}

\ifshoworiginal
We can test all three versions of the ticker by using ScalaTest specifications,
creating instances of the different versions of the ticker and passing them
to the generic test bench. Listing~\ref{lst:ticker:spec} shows the specification.
We run only the ticker tests with:
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、ScalaTest仕様を使用してティッカーの異なるバージョンのインスタンスを作成し、一般的なテストベンチに渡すことでティッカーのすべての3つのバージョンをテストすることができます。
〜\ref{lst:ticker:spec}のリストの仕様を示しています。
\fi

\ifshowtranssecond %(校正 TODO)
私たちは、ScalaTest仕様を使用してティッカーの異なるバージョンのインスタンスを作成し、一般的なテストベンチに渡すことでティッカーのすべての3つのバージョンをテストすることができます。
〜\ref{lst:ticker:spec}のリストの仕様を示しています。
\fi

\begin{chisel}
sbt "testOnly TickerSpec"
\end{chisel}

\longlist{code/ticker_spec.txt}{ScalaTest specifications for the ticker tests.}{lst:ticker:spec}

\ifshoworiginal
\section{Hardware Generation with Functional Programming}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Hardware Generation with Functional Programming}
\fi
\ifshowtranssecond %(校正)
\section{関数型プログラミングによるハードウェア生成 (L19523 TODO)}
\fi

\label{sec:functional}
\index{Functional programming}

\ifshoworiginal
Scala supports functional programming, so does Chisel then.
We can use functions to represent hardware and combine those hardware components
with functional programming (by using a so-called ``higher-order function'').
Let us start with a simple example, the sum of a vector:
\fi

\ifshowtransfirst %(自動翻訳)
Scalaは関数型プログラミングをサポートしていますので、Chiselは、ありません。
我々は、ハードウェアを表現する関数を使用して（「」いわゆる ``高次関数を用いて）、機能プログラミングと、これらのハードウェアコンポーネントを組み合わせることができます。
私たちは、簡単な例で、ベクトルの総和を始めましょう：
\fi

\ifshowtranssecond %(校正 TODO)
Scalaは関数型プログラミングをサポートしていますので、Chiselは、ありません。
我々は、ハードウェアを表現する関数を使用して（「」いわゆる ``高次関数を用いて）、機能プログラミングと、これらのハードウェアコンポーネントを組み合わせることができます。
私たちは、簡単な例で、ベクトルの総和を始めましょう：
\fi

\shortlist{code/fun_first.txt}

\ifshoworiginal
\noindent First we define the hardware for the adder in function \code{add}.
The vector is located in \code{vec}. The Scala \code{reduce()} method combines
all elements of a collection with a binary operation, producing a single value.
The \code{reduce()} method reduces the sequence starting from the left.
It takes the first two elements and performs the operation. The result is then combined
with the next element, until a single result is left.
\fi

\ifshowtransfirst %(自動翻訳)
まず、機能\code{add}における加算器のハードウェアを定義します。
ベクトルは\code{vec}に位置しています。
スカラ\code{reduce()}方法は、単一の値を生成する、バイナリ操作でコレクションのすべての要素を組み合わせました。
\code{reduce()}方法は、左から順に減少します。
これは、最初の2つの要素とを行う操作を要します。
単一の結果が残されるまで結果は、その後、次の要素と組み合わされます。
\fi

\ifshowtranssecond %(校正 TODO)
まず、機能\code{add}における加算器のハードウェアを定義します。
ベクトルは\code{vec}に位置しています。
スカラ\code{reduce()}方法は、単一の値を生成する、バイナリ操作でコレクションのすべての要素を組み合わせました。
\code{reduce()}方法は、左から順に減少します。
これは、最初の2つの要素とを行う操作を要します。
単一の結果が残されるまで結果は、その後、次の要素と組み合わされます。
\fi

\ifshoworiginal
The function to combine to elements is provided as parameter to \code{reduce}, in our case \code{add},
which returns an adder. The resulting hardware is a chain of adders computing
the sum of the elements of vector \code{vec}.
\fi

\ifshowtransfirst %(自動翻訳)
要素に結合する機能は、我々の場合、加算器を返し\code{add}に、\code{reduce}にパラメータとして提供されます。
得られたハードウェアは、ベクトル\code{vec}の要素の和を計算する加算器のチェーンです。
\fi

\ifshowtranssecond %(校正 TODO)
要素に結合する機能は、我々の場合、加算器を返し\code{add}に、\code{reduce}にパラメータとして提供されます。
得られたハードウェアは、ベクトル\code{vec}の要素の和を計算する加算器のチェーンです。
\fi

\ifshoworiginal
Instead of defining the (simple) \code{add} function, we can provide the addition
as anonymous function and use the Scala wildcard ``\code{\_}'' to represent the
two operands.
\fi

\ifshowtransfirst %(自動翻訳)
代わりに（簡単な）\code{add}関数を定義するので、私たちは、無名関数として加算を提供し、2つのオペランドを表すために、Scalaのワイルドカード `` \code{\_}「」を使用することができます。
\fi

\ifshowtranssecond %(校正 TODO)
代わりに（簡単な）\code{add}関数を定義するので、私たちは、無名関数として加算を提供し、2つのオペランドを表すために、Scalaのワイルドカード `` \code{\_}「」を使用することができます。
\fi

\shortlist{code/fun_func_lit.txt}

\ifshoworiginal
\noindent With this one liner we have generated the chain of adders. For the sum function
a chain is not the ideal configuration, a tree will have a shorter combinational delay.
If we do not trust the synthesize tool to rearrange our adder chain, we can use Chisel's
\code{reduceTree} method to generated a tree of adders:
\fi

\ifshowtransfirst %(自動翻訳)
この1つのライナーで、私たちは、加算器のチェーンを生成しました。
チェーンは、理想的な構成ではありませんSUM関数の場合は、ツリーが短い組み合わせ遅延を持つことになります。
我々は、加算器チェーンを再配置するのsynthesizeツールを信用しない場合、我々は、加算器のツリー生成にChiselの\code{reduceTree}メソッドを使用することができます。
\fi

\ifshowtranssecond %(校正 TODO)
この1つのライナーで、私たちは、加算器のチェーンを生成しました。
チェーンは、理想的な構成ではありませんSUM関数の場合は、ツリーが短い組み合わせ遅延を持つことになります。
我々は、加算器チェーンを再配置するのsynthesizeツールを信用しない場合、我々は、加算器のツリー生成にChiselの\code{reduceTree}メソッドを使用することができます。
\fi

\shortlist{code/fun_reduce_tree.txt}

\ifshoworiginal
\chapter{Example Designs}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Example Designs}
\fi
\ifshowtranssecond %(校正)
\chapter{デザイン例 (L10642 TODO)} %(校正  11章 ========================================================================)
\fi

\ifshoworiginal
In this section, we explore some small size digital designs, such as
a FIFO buffer, which are used as building blocks for a larger design.
As another example, we design a serial interface (also called UART),
which itself may use the FIFO buffer.
\fi

\ifshowtransfirst %(自動翻訳)
このセクションでは、我々は、このような大規模な設計のためのビルディングブロックとして使用されているFIFOバッファ、などいくつかの小さなサイズのデジタル設計を、探ります。
別の例として、我々は、それ自体がFIFOバッファを使用することができる（また、UARTと呼ばれる）シリアルインタフェースを設計します。
\fi
\ifshowtranssecond %(校正 6/20 mune10)
このセクションでは、以下のようないくつかの小さなサイズのデジタルデザインを探索します。
これらは、より大きな設計のためのビルディングブロックとして使用されます。
別の例として、シリアル・インターフェース（UARTとも呼ばれます）を設計しますが、これ自体はFIFOバッファを使用します。
\fi

\ifshoworiginal
\section{FIFO Buffer}
\fi
\ifshowtransfirst %(自動翻訳)
\section{FIFO Buffer}
\fi
\ifshowtranssecond %(校正)
\section{FIFO バッファ (L10098 TODO)}
\fi

\label{sec:fifo}
\index{FIFO}
\index{FIFO buffer}
\index{First-in, first-out buffer}

\ifshoworiginal
We can decouple a write (sender) and a reader (receiver) by a buffer
between the writer and reader.
A common buffer is a first-in, first-out
(\href{https://en.wikipedia.org/wiki/FIFO_%28computing_and_electronics%29}{FIFO})
buffer. Figure~\ref{fig:fifo} shows a writer, the FIFO, and a reader.
Data is put into the FIFO by the writer on \code{din} with an active
\code{write} signal. Data is read from the the FIFO by the reader on
\code{dout} with an active \code{read} signal.}
\fi

\ifshowtransfirst %(自動翻訳)
我々は、ライターとリーダーとの間のバッファによるライト（送信者）とリーダ（受信機）を切り離すことができます。
EN：共通バッファは、（\ HREF {HTTPS先入れ先出しです。
ウィキペディア。}
ERROR-TBD
%ORG /ウィキ/ FIFO_％28computing_and_electronics％29} {} FIFO）バッファ。
図〜\ref{fig:fifo}は作家、FIFO、およびリーダーを示しています。
データは、アクティブ\code{write}信号と\code{din}の作家によってFIFOに入れられます。
データは、アクティブ\code{read}信号に\code{dout}にリーダによってFIFOから読み出されます。
\fi

\ifshowtranssecond %(校正 TODO)
我々は、ライターとリーダーとの間のバッファによるライト（送信者）とリーダ（受信機）を切り離すことができます。
EN：共通バッファは、（\ HREF {HTTPS先入れ先出しです。
ウィキペディア。}
ERROR-TBD
%ORG /ウィキ/ FIFO_％28computing_and_electronics％29} {} FIFO）バッファ。
図〜\ref{fig:fifo}は作家、FIFO、およびリーダーを示しています。
データは、アクティブ\code{write}信号と\code{din}の作家によってFIFOに入れられます。
データは、アクティブ\code{read}信号に\code{dout}にリーダによってFIFOから読み出されます。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=\scale]{figures/fifo}
  \caption{A writer, a FIFO buffer, and a reader.}
  \label{fig:fifo}
\end{figure}

\ifshoworiginal
A FIFO is initially empty, singled by the \code{empty} signal. Reading
from an empty FIFO is usually undefined. When data is written and never
read a FIFO will become \code{full}. Writing to a full FIFO is usually ignored
and the data are lost. In other words, the signals \code{empty} and \code{full}
serve as handshake signals
\fi

\ifshowtransfirst %(自動翻訳)
A FIFOは\code{empty}信号によって選抜、最初は空です。
空のFIFOからの読み取りは、通常は定義されていません。
データが書き込まれたときと\code{full}なりFIFOを読んだことがありません。
フルFIFOへの書き込みは、通常は無視され、データが失われます。
換言すれば、信号\code{empty}と\code{full}はハンドシェーク信号として働きます
\fi

\ifshowtranssecond %(校正 TODO)
A FIFOは\code{empty}信号によって選抜、最初は空です。
空のFIFOからの読み取りは、通常は定義されていません。
データが書き込まれたときと\code{full}なりFIFOを読んだことがありません。
フルFIFOへの書き込みは、通常は無視され、データが失われます。
換言すれば、信号\code{empty}と\code{full}はハンドシェーク信号として働きます
\fi

\ifshoworiginal
Several different implementations of a FIFO are possible: E.g., using on-chip
memory and read and write pointers or simply a chain of registers with a
tiny state machine. For small buffers (up to tens of elements) a FIFO organized
with individual registers connected into a chain of buffers is a simple
implementation with a low resource requirement.
The code of the bubble FIFO is available in the
\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}
repository.\footnote{For completeness, the Chisel book repository contains
a copy of the FIFO code as well.}
\fi

\ifshowtransfirst %(自動翻訳)
FIFOの幾つかの異なる実装が可能である：E.
グラム。
、オンチップ・メモリを使用してポインタまたは単に小さなステートマシンを有するレジスタのチェーンを読み書きします。
小さなバッファ（要素の数十まで）のためのFIFOは、低リソース要件を持つ単純な実装であるバッファのチェーンに接続された個々のレジスタを整理しました。
バブルFIFOのコードは\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}リポジトリに入手可能です。
ERROR-TBD
%完全のために\脚注は{、Chiselの本リポジトリは、同様にFIFOコードのコピーが含まれています。
%｝
\fi

\ifshowtranssecond %(校正 TODO)
FIFOの幾つかの異なる実装が可能である：E.
グラム。
、オンチップ・メモリを使用してポインタまたは単に小さなステートマシンを有するレジスタのチェーンを読み書きします。
小さなバッファ（要素の数十まで）のためのFIFOは、低リソース要件を持つ単純な実装であるバッファのチェーンに接続された個々のレジスタを整理しました。
バブルFIFOのコードは\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}リポジトリに入手可能です。
ERROR-TBD
%完全のために\脚注は{、Chiselの本リポジトリは、同様にFIFOコードのコピーが含まれています。
%｝
\fi

\ifshoworiginalh
We start by defining the IO signals for the writer and the reader side.
The size of the data is configurable with \code{size}.
The write data are \code{din} and a write is signaled by \code{write}.
The signal \code{full} performs the
\myref{https://en.wikipedia.org/wiki/Flow_control_(data)}{flow control}
at the writer side.
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、作家と読者側のためのIO信号を定義することから始めます。
データのサイズが\code{size}で設定可能です。
書き込みデータは\code{din}あると書き込みが\code{write}によって通知されます。
信号\code{full}ライター側に\myref{https://en.wikipedia.org/wiki/Flow_control_(data)}{flow control}を行います。
\fi

\ifshowtranssecond %(校正 TODO)
私たちは、作家と読者側のためのIO信号を定義することから始めます。
データのサイズが\code{size}で設定可能です。
書き込みデータは\code{din}あると書き込みが\code{write}によって通知されます。
信号\code{full}ライター側に\myref{https://en.wikipedia.org/wiki/Flow_control_(data)}{flow control}を行います。
\fi

\shortlist{code/bubble_fifo_writer_io.txt}

\ifshoworiginal
The reader side provides data with \code{dout} and the read is initiated
with \code{read}. The \code{empty} signal is responsible for the flow control
at the reader side.
\fi

\ifshowtransfirst %(自動翻訳)
読者側は\code{dout}とデータを提供し、リード\code{read}で開始されます。
\code{empty}信号は、リーダ側でフロー制御を担当します。
\fi

\ifshowtranssecond %(校正 TODO)
読者側は\code{dout}とデータを提供し、リード\code{read}で開始されます。
\code{empty}信号は、リーダ側でフロー制御を担当します。
\fi

\shortlist{code/bubble_fifo_reader_io.txt}

\ifshoworiginal
Listing~\ref{lst:fifo:stage} shows a single buffer. The buffer has a enqueueing port
\code{enq} of type \code{WriterIO} and a dequeueing port \code{deq} of type
\code{ReaderIO}. The state elements of the buffer is one register that holds the
data (\code{dataReg} and one state register for the simple FSM (\code{stateReg}).
The FSM has only two states: either the buffer is \code{empty} or \code{full}.
If the buffer is \code{empty}, a write will register the input data and change
to the \code{full} state.
If the buffer is \code{full}, a read will consume the data and change to the
\code{empty} state.
The IO ports \code{full} and \code{empty} represent the buffer state for
the writer and the reader.
\fi

\ifshowtransfirst %(自動翻訳)
〜\ref{lst:fifo:stage}リストは、単一のバッファを示しています。
バッファは、エンキューポートタイプ\code{WriterIO}の\code{enq}及びタイプ\code{ReaderIO}のデキューポート\code{deq}を有しています。
バッファの状態要素は、データを保持する一つのレジスタ（\code{dataReg}及び単純FSM（\code{stateReg}）に対して1つの状態レジスタです。
FSMは、2つの状態しかあり：バッファのいずれかが\code{empty}か\code{full}です。
バッファが\code{empty}であれば、書き込みが\code{full}状態への入力データと変更を登録します。
バッファが\code{full}ある場合は、読み取りは\code{empty}状態へのデータおよび変更を消費します。
IOポート\code{full}と\code{empty}ライターとリーダーのためのバッファの状態を表します。
\fi

\ifshowtranssecond %(校正 TODO)
〜\ref{lst:fifo:stage}リストは、単一のバッファを示しています。
バッファは、エンキューポートタイプ\code{WriterIO}の\code{enq}及びタイプ\code{ReaderIO}のデキューポート\code{deq}を有しています。
バッファの状態要素は、データを保持する一つのレジスタ（\code{dataReg}及び単純FSM（\code{stateReg}）に対して1つの状態レジスタです。
FSMは、2つの状態しかあり：バッファのいずれかが\code{empty}か\code{full}です。
バッファが\code{empty}であれば、書き込みが\code{full}状態への入力データと変更を登録します。
バッファが\code{full}ある場合は、読み取りは\code{empty}状態へのデータおよび変更を消費します。
IOポート\code{full}と\code{empty}ライターとリーダーのためのバッファの状態を表します。
\fi


\longlist{code/bubble_fifo_register.txt}{A single stage of the bubble FIFO.}{lst:fifo:stage}

\index{Bubble FIFO}

\ifshoworiginal
Listing~\ref{lst:fifo} shows the complete FIFO. The complete FIFO has
the same IO interface as the individual FIFO buffers.
\code{BubbleFifo} has as parameters the \code{size} of the data
word and \code{depth} for the number of buffer stages.
We can build a \code{depth} stages bubble FIFO out of \code{depth}
\code{FifoRegister}s. We crate the stages by filling them into a Scala \code{Array}.
The Scala array has no hardware meaning, it \emph{just} provides us with
a container to have references to the created buffers.
In a Scala \code{for} loop we connect the individual buffers.
The first buffer's enqueueing side is connected to the enqueueing IO of
the complete FIFO and the last buffer's dequeueing side to the
dequeueing side of the complete FIFO.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:fifo}は、完全なFIFOを示します。
完全なFIFOは、個々のFIFOバッファと同じIOインターフェースを持っています。
\code{BubbleFifo}バッファ段数のパラメータデータワードと\code{depth}の\code{size}として有しています。
私たちは、\code{depth} \code{depth} \code{FifoRegister}sのうち、バブルFIFOステージを構築することができます。
私たちは、クレートScalaの\code{Array}にそれらを充填することによりステージを。
Scalaの配列は何もハードウェアの意味を持っていない、それが作成したバッファへの参照を持っているコンテナを提供してくれます\emph{just}。
Scalaの\code{for}ループでは、個々のバッファを接続してください。
最初のバッファのエンキュー側は、完全なFIFOのデキュー側に完全なFIFOのエンキューIOと最後のバッファのデキュー側に接続されています。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:fifo}は、完全なFIFOを示します。
完全なFIFOは、個々のFIFOバッファと同じIOインターフェースを持っています。
\code{BubbleFifo}バッファ段数のパラメータデータワードと\code{depth}の\code{size}として有しています。
私たちは、\code{depth} \code{depth} \code{FifoRegister}sのうち、バブルFIFOステージを構築することができます。
私たちは、クレートScalaの\code{Array}にそれらを充填することによりステージを。
Scalaの配列は何もハードウェアの意味を持っていない、それが作成したバッファへの参照を持っているコンテナを提供してくれます\emph{just}。
Scalaの\code{for}ループでは、個々のバッファを接続してください。
最初のバッファのエンキュー側は、完全なFIFOのデキュー側に完全なFIFOのエンキューIOと最後のバッファのデキュー側に接続されています。
\fi

\longlist{code/bubble_fifo.txt}{A FIFO is composed of an array of FIFO bubble stages.}{lst:fifo}

\ifshoworiginal
The presented idea of connecting individual buffers to implement a FIFO
queue is called a bubble FIFO, as the data bubbles through the queue.
This is simple, and a good solution when the data rate is considerable slower
than the clock rate, e.g., as a decouple buffer for a serial port, which is presented
in the next section.
\fi

\ifshowtransfirst %(自動翻訳)
データがキューを介して気泡としてFIFOキューを実装するために、個々のバッファを接続の提示アイデアは、バブルFIFOと呼ばれています。
これは簡単で、優れたソリューションは、データ・レートは遅いクロック・レート、電子よりもかなりあるとき。
グラム。
、次のセクションで提示されているシリアルポート用デカップルバッファとして。
\fi

\ifshowtranssecond %(校正 TODO)
データがキューを介して気泡としてFIFOキューを実装するために、個々のバッファを接続の提示アイデアは、バブルFIFOと呼ばれています。
これは簡単で、優れたソリューションは、データ・レートは遅いクロック・レート、電子よりもかなりあるとき。
グラム。
、次のセクションで提示されているシリアルポート用デカップルバッファとして。
\fi

\ifshoworiginal
However, when the data rate approaches the clock frequency, the bubble FIFO
has two limitations: (1) As each buffer's state has to toggle between \emph{empty} and
\emph{full}, which means the maximum throughput of the FIFO is 2 clock cycles
per word. (2) The data needs to bubble through the complete FIFO, therefore,
the latency from the input to the output is at least the number of buffers.
I will present other possible implementations of FIFOs in Section~\ref{sec:more:fifo}.
\fi

\ifshowtransfirst %(自動翻訳)
各バッファの状態がFIFOの最大スループットは、ワード当たり2回のクロックサイクルであることを意味する、\emph{empty}と\emph{full}を切り替えなければならないように（1）：データレートはクロック周波数に近づくとしかしながら、気泡FIFOは2つの制限を有します。
（2）完全なFIFOを介してバブルへのデータの必要性は、従って、入力から出力までの待ち時間は、少なくともバッファの数です。
私は節〜\ref{sec:more:fifo}にFIFOの他の可能な実装を紹介します。
\fi

\ifshowtranssecond %(校正 TODO)
各バッファの状態がFIFOの最大スループットは、ワード当たり2回のクロックサイクルであることを意味する、\emph{empty}と\emph{full}を切り替えなければならないように（1）：データレートはクロック周波数に近づくとしかしながら、気泡FIFOは2つの制限を有します。
（2）完全なFIFOを介してバブルへのデータの必要性は、従って、入力から出力までの待ち時間は、少なくともバッファの数です。
私は節〜\ref{sec:more:fifo}にFIFOの他の可能な実装を紹介します。
\fi

\ifshoworiginal
\section{A Serial Port}
\fi
\ifshowtransfirst %(自動翻訳)
\section{A Serial Port}
\fi
\ifshowtranssecond %(校正)
\section{シリアルポート (L10368 TODO)}
\fi

\label{sec:uart}
\index{Serial port}
\index{UART}

\ifshoworiginal
A serial port (also called
\myref{https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter}{UART}
or \myref{https://en.wikipedia.org/wiki/RS-232}{RS-232}) is one of the easiest options
to communicate between your laptop and an FPGA board.
As the name implies, data is transmitted serially. An 8-bit byte is transmitted as follows:
one start bit (0), the 8-bit data, least significant bit first, and then one or two stop
bits (1). When no data is transmitted, the output is 1.
Figure~\ref{fig:uart:wave} shows the timing diagram of one byte transmitted.
\fi

\ifshowtransfirst %(自動翻訳)
（また\myref{https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter}{UART}または\myref{https://en.wikipedia.org/wiki/RS-232}{RS-232}と呼ばれる）のシリアルポートは、ノートパソコンとFPGAボードの間で通信するための最も簡単な選択肢の一つです。
名前が示すように、データがシリアル伝送されます。
8ビットのバイトは次のように送信される：1スタートビット（0）は、最初の8ビットのデータ、最下位ビット、および1つのまたは2つのストップビット（1）。
何もデータが送信されない場合、出力は1です。
図〜\ref{fig:uart:wave}は、送信された1バイトのタイミング図を示します。
\fi

\ifshowtranssecond %(校正 TODO)
（また\myref{https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter}{UART}または\myref{https://en.wikipedia.org/wiki/RS-232}{RS-232}と呼ばれる）のシリアルポートは、ノートパソコンとFPGAボードの間で通信するための最も簡単な選択肢の一つです。
名前が示すように、データがシリアル伝送されます。
8ビットのバイトは次のように送信される：1スタートビット（0）は、最初の8ビットのデータ、最下位ビット、および1つのまたは2つのストップビット（1）。
何もデータが送信されない場合、出力は1です。
図〜\ref{fig:uart:wave}は、送信された1バイトのタイミング図を示します。
\fi

\begin{figure}
  \centering
  \includegraphics[scale=1]{figures/uart_wave}
  \caption{One byte transmitted by a UART.}
  \label{fig:uart:wave}
\end{figure}

\ifshoworiginal
We design our UART in a modular way with minimal functionality
per module. We present a transmitter (TX), a receiver (RX),
a buffer, and then usage of those base components.
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、モジュールごとに、最小限の機能を備えたモジュール式の方法で私たちのUARTを設計します。
我々は、送信機（TX）、受信機（RX）、緩衝液、及びそれらのベースコンポーネントの使用を提示します。
\fi

\ifshowtranssecond %(校正 TODO)
私たちは、モジュールごとに、最小限の機能を備えたモジュール式の方法で私たちのUARTを設計します。
我々は、送信機（TX）、受信機（RX）、緩衝液、及びそれらのベースコンポーネントの使用を提示します。
\fi

\ifshoworiginal
First, we need an interface, a port definition.
For the UART design, we use a ready/valid handshake interface,
with the direction as seen from the transmitter.
\shortlist{code/uart_channel.txt}
The convention of a ready/valid interface is that the data is transferred
when both \code{ready} and \code{valid} are asserted.
\fi

\ifshowtransfirst %(自動翻訳)
まず、我々はインターフェイス、ポート定義を必要としています。
UARTの設計のために、我々は送信機から見られるように方向で、準備/有効なハンドシェイク・インタフェースを使用しています。
準備/有効なインターフェイスの大会は\code{ready}と\code{valid}の両方がアサートされたときにデータが転送されていることです。
\fi

\ifshowtranssecond %(校正 TODO)
まず、我々はインターフェイス、ポート定義を必要としています。
UARTの設計のために、我々は送信機から見られるように方向で、準備/有効なハンドシェイク・インタフェースを使用しています。
準備/有効なインターフェイスの大会は\code{ready}と\code{valid}の両方がアサートされたときにデータが転送されていることです。
\fi

\longlist{code/uart_tx.txt}{A transmitter for a serial port.}{lst:uart:tx}

\ifshoworiginal
Listing~\ref{lst:uart:tx} shows a bare-bone serial transmitter (\code{Tx}).
The IO ports are the \code{txd} port, where the serial data is sent and
a \code{Channel} where the transmitter can receive the characters to serialize
and send.
To generate the correct timing, we compute a constant for by computing
the time in clock cycles for one serial bit.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:uart:tx}は、ベアボーンシリアル送信（\code{Tx}）を示しています。
IOポートは、シリアルデータが送信される\code{txd}ポート、および送信機がシリアル化し送信するために文字を受信することができる\code{Channel}あります。
正しいタイミングを生成するために、我々は1つのシリアルビットのためのクロック・サイクルの時間を計算することによってための定数を計算します。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:uart:tx}は、ベアボーンシリアル送信（\code{Tx}）を示しています。
IOポートは、シリアルデータが送信される\code{txd}ポート、および送信機がシリアル化し送信するために文字を受信することができる\code{Channel}あります。
正しいタイミングを生成するために、我々は1つのシリアルビットのためのクロック・サイクルの時間を計算することによってための定数を計算します。
\fi

\ifshoworiginal
We use three registers:
(1) register to shift the data (serialize them) (\code{shiftReg}),
(2) a counter to generate the correct baud rate (\code{cntReg}), and
(3) a counter for the number of bits that still need to be shifted out.
No additional state register of FSM is needed, all state is encoded in
those three registers.
\fi

\ifshowtransfirst %(自動翻訳)
我々は、3つのレジスタを使用する：（1）（シリアライズして）（\code{shiftReg}）、（2）正しいボーレート（\code{cntReg}）を生成するカウンタ、及びビット数依然として必要（3）カウンタデータをシフトするレジスタシフトアウトされます。
FSMの追加の状態レジスタを必要としない、すべての状態は、これらの3つのレジスタでエンコードされています。
\fi

\ifshowtranssecond %(校正 TODO)
我々は、3つのレジスタを使用する：（1）（シリアライズして）（\code{shiftReg}）、（2）正しいボーレート（\code{cntReg}）を生成するカウンタ、及びビット数依然として必要（3）カウンタデータをシフトするレジスタシフトアウトされます。
FSMの追加の状態レジスタを必要としない、すべての状態は、これらの3つのレジスタでエンコードされています。
\fi

\ifshoworiginal
Counter \code{cntReg} is continuously running (counting down to 0
and reset to the start value when 0). All action is only done when
\code{cntReg} is 0. As we build a minimal transmitter, we have only
the shift register to store the data. Therefore, the channel is only ready
when \code{cntReg} is 0 and no bits are left to shift out.
\fi

\ifshowtransfirst %(自動翻訳)
カウンタ\code{cntReg}が連続的に実行されている（開始値0に0、リセットにカウントダウン）。
\code{cntReg}が0である場合、すべてのアクションにのみ行われます。
私たちは、最小限の送信機を構築するように、我々は、データを格納するための唯一のシフトレジスタを持っています。
\code{cntReg}が0でないビットがシフトアウトするために残っていない場合したがって、チャネルのみ準備ができています。
\fi

\ifshowtranssecond %(校正 TODO)
カウンタ\code{cntReg}が連続的に実行されている（開始値0に0、リセットにカウントダウン）。
\code{cntReg}が0である場合、すべてのアクションにのみ行われます。
私たちは、最小限の送信機を構築するように、我々は、データを格納するための唯一のシフトレジスタを持っています。
\code{cntReg}が0でないビットがシフトアウトするために残っていない場合したがって、チャネルのみ準備ができています。
\fi

\ifshoworiginal
The IO port \code{txd} is directly connected to the least significant bit
of the shift register.
\fi

\ifshowtransfirst %(自動翻訳)
IOポート\code{txd}直接シフトレジスタの最下位ビットに接続されています。
\fi

\ifshowtranssecond %(校正 TODO)
IOポート\code{txd}直接シフトレジスタの最下位ビットに接続されています。
\fi

\ifshoworiginal
When there are more bits to shift out (\code{bitsReg =/= 0.U}),
we shift the bits to the right and fill with 1 from the top (the idle level
of a transmitter).
If no more bits need to be shifted out, we check if the channel contains
data (signaled with the \code{valid} port). If so, the bit string to
be shifted out is constructed with one start bit (0), the 8-bit data, and
two stop bits (1). Therefore, the bit count is set to 11.
\fi

\ifshowtransfirst %(自動翻訳)
（\code{bitsReg =/= 0.U}）をシフトアウトするためのより多くのビットがある場合、我々は、トップ（送信機のアイドルレベル）から1と右と充填ビットをシフトします。
これ以上のビットがシフトアウトする必要がない場合は、チャネルが（\code{valid}ポートで合図）のデータが含まれている場合、我々は確認してください。
もしそうであれば、シフトアウトされるビット列は、1スタートビット（0）、8ビットのデータ、及び2つのストップビット（1）を用いて構成されています。
したがって、ビット数は11に設定されています。
\fi

\ifshowtranssecond %(校正 TODO)
（\code{bitsReg =/= 0.U}）をシフトアウトするためのより多くのビットがある場合、我々は、トップ（送信機のアイドルレベル）から1と右と充填ビットをシフトします。
これ以上のビットがシフトアウトする必要がない場合は、チャネルが（\code{valid}ポートで合図）のデータが含まれている場合、我々は確認してください。
もしそうであれば、シフトアウトされるビット列は、1スタートビット（0）、8ビットのデータ、及び2つのストップビット（1）を用いて構成されています。
したがって、ビット数は11に設定されています。
\fi

\ifshoworiginal
This very minimal transmitter has no additional buffer and can
accept a new character only when the shift register is empty
and at the clock cycle when \code{cntReg} is 0.
Accepting new data only when \code{cntReg} is 0 also means
that the ready flag is also de-asserted when there would be
space in the shift register. However, we do not want to add this
``complexity'' to the transmitter but delegate it to a buffer.
\fi

\ifshowtransfirst %(自動翻訳)
この非常に最小限の送信には、追加のバッファを持っていないと\code{cntReg}が0であるとき、シフトレジスタが空とクロック・サイクルである場合にのみ、新しいキャラクターを受け入れることができます。
\code{cntReg}が0である場合にのみ、新しいデータを受け入れると、シフトレジスタにスペースが存在することになる準備ができたらフラグもデアサートであることを意味します。
しかし、我々は、送信機に、この ``複雑「」を追加しますが、バッファにそれを委任する必要はありません。
\fi

\ifshowtranssecond %(校正 TODO)
この非常に最小限の送信には、追加のバッファを持っていないと\code{cntReg}が0であるとき、シフトレジスタが空とクロック・サイクルである場合にのみ、新しいキャラクターを受け入れることができます。
\code{cntReg}が0である場合にのみ、新しいデータを受け入れると、シフトレジスタにスペースが存在することになる準備ができたらフラグもデアサートであることを意味します。
しかし、我々は、送信機に、この ``複雑「」を追加しますが、バッファにそれを委任する必要はありません。
\fi

\ifshoworiginal
\longlist{code/uart_buffer.txt}{A single-byte buffer with a ready/valid interface.}{lst:uart:buffer}
Listing~\ref{lst:uart:buffer} shows a single byte buffer, similar to
the FIFO register for the bubble FIFO. The input port is a \code{Channel}
interface, and the output is the \code{Channel} interface with
flipped directions. The buffer contains the minimal state machine
to indicate \code{empty} or \code{full}. The buffer driven handshake
signals (\code{in.ready} and \code{out.valid} depend on the state
register.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:uart:buffer}はバブルFIFOのためのFIFOレジスタに似た単一バイトバッファを示しています。
入力ポートは\code{Channel}インタフェースであり、出力が反転方向と\code{Channel}インタフェースです。
バッファは\code{empty}または\code{full}を示すために、最小限のステートマシンが含まれています。
バッファ駆動ハンドシェーク信号（\code{in.ready}と\code{out.valid}は、状態レジスタに依存します。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:uart:buffer}はバブルFIFOのためのFIFOレジスタに似た単一バイトバッファを示しています。
入力ポートは\code{Channel}インタフェースであり、出力が反転方向と\code{Channel}インタフェースです。
バッファは\code{empty}または\code{full}を示すために、最小限のステートマシンが含まれています。
バッファ駆動ハンドシェーク信号（\code{in.ready}と\code{out.valid}は、状態レジスタに依存します。
\fi

\ifshoworiginal
When the state is \code{empty}, and data on the input is \code{valid},
we register the data and switch to state \code{full}.
When the state is \code{full}, and the downstream receiver is
\code{ready}, the downstream data transfer happens, and we switch
back to state \code{empty}.
\fi

\ifshowtransfirst %(自動翻訳)
状態は\code{empty}で、入力上のデータが\code{valid}で、我々は状態\code{full}にデータとスイッチを登録するとき。
状態が\code{full}であり、そして下流受信機は\code{ready}である場合、ダウンストリームのデータ転送が発生し、そして我々は、状態\code{empty}に戻します。
\fi

\ifshowtranssecond %(校正 TODO)
状態は\code{empty}で、入力上のデータが\code{valid}で、我々は状態\code{full}にデータとスイッチを登録するとき。
状態が\code{full}であり、そして下流受信機は\code{ready}である場合、ダウンストリームのデータ転送が発生し、そして我々は、状態\code{empty}に戻します。
\fi

\ifshoworiginal
\longlist{code/uart_buffered_tx.txt}{A transmitter with an additional buffer.}{lst:uart:buffered:tx}
With that buffer we can extend our bare-bone transmitter.
Listing~\ref{lst:uart:buffered:tx} shows the combination of the transmitter \code{Tx}
with a single-buffer in front. This buffer now relaxes the issue that \code{Tx}
was \code{ready} only for single clock cycles. We delegated the solution of
this issue to the buffer module.
An extension of the single word buffer to a real FIFO can easily be done
and needs no change in the transmitter or the single byte buffer.
\fi

\ifshowtransfirst %(自動翻訳)
そのバッファで、私たちは私たちの裸の骨の送信機を拡張することができます。
リスティング〜\ref{lst:uart:buffered:tx}は前に単一のバッファと送信\code{Tx}の組み合わせを示します。
このバッファは、今\code{Tx}は、単一のクロック・サイクルのために\code{ready}だったという問題を緩和します。
私たちは、バッファモジュールに、この問題の解決策を委任しました。
実際のFIFOへの単一ワードバッファの拡張が簡単に行われ、送信または単一バイトのバッファには変化を必要としないことができます。
\fi

\ifshowtranssecond %(校正 TODO)
そのバッファで、私たちは私たちの裸の骨の送信機を拡張することができます。
リスティング〜\ref{lst:uart:buffered:tx}は前に単一のバッファと送信\code{Tx}の組み合わせを示します。
このバッファは、今\code{Tx}は、単一のクロック・サイクルのために\code{ready}だったという問題を緩和します。
私たちは、バッファモジュールに、この問題の解決策を委任しました。
実際のFIFOへの単一ワードバッファの拡張が簡単に行われ、送信または単一バイトのバッファには変化を必要としないことができます。
\fi

\ifshoworiginal
\longlist{code/uart_rx.txt}{A receiver for a serial port.}{lst:uart:rx}
Listing~\ref{lst:uart:rx} shows the code for the receiver (\code{Rx}).
A receiver is a little bit tricky, as it needs to reconstruct the timing of
the serial data. The receiver waits for the falling edge of the start bit.
From that event, the receiver waits 1.5 bit times to position itself into the middle
of bit 0. Then it shifts in the bits every bit time. You can observe these
two waiting times as \code{START\_CNT} and \code{BIT\_CNT}.
For both times, the same counter (\code{cntReg}) is used.
After 8 bits are shifted in, \code{valReg} signals an available byte
\fi

\ifshowtransfirst %(自動翻訳)
〜\ref{lst:uart:rx}をリストレシーバー（\code{Rx}）のコードを示します。
それは、シリアルデータのタイミングを再構成する必要があるように、受信機は、少しトリッキーです。
受信機は、スタートビットの立ち下がりエッジを待ちます。
そのイベントから、受信機は、1を待ちます。
5ビット時間は、ビット0の中央に自身を位置決めします。
そして、それはビットのすべてのビット時間をシフト。
あなたは\code{START\_CNT}と\code{BIT\_CNT}ように、これらの2つの待ち時間を観察することができます。
両方回、同じカウンタ（\code{cntReg}）が使用されます。
8ビットがシフトインされた後、\code{valReg}は、利用可能なバイトを通知します
\fi

\ifshowtranssecond %(校正 TODO)
〜\ref{lst:uart:rx}をリストレシーバー（\code{Rx}）のコードを示します。
それは、シリアルデータのタイミングを再構成する必要があるように、受信機は、少しトリッキーです。
受信機は、スタートビットの立ち下がりエッジを待ちます。
そのイベントから、受信機は、1を待ちます。
5ビット時間は、ビット0の中央に自身を位置決めします。
そして、それはビットのすべてのビット時間をシフト。
あなたは\code{START\_CNT}と\code{BIT\_CNT}ように、これらの2つの待ち時間を観察することができます。
両方回、同じカウンタ（\code{cntReg}）が使用されます。
8ビットがシフトインされた後、\code{valReg}は、利用可能なバイトを通知します
\fi

\ifshoworiginal
\longlist{code/uart_sender.txt}{Sending ``Hello World!" via the serial port.}{lst:uart:sender}
Listing~\ref{lst:uart:sender} shows the usage of the serial port transmitter
by sending a friendly message out. We define the message in a Scala
string (\code{msg}) and converting it to a Chisel \code{Vec} of \code{UInt}.
A Scala string is a sequence that supports the \code{map} method.
The \code{map} method takes as argument a function literal, applies this function to
each element, and builds a sequence of the function's return values.
If the function literal shall have only one argument, as it is in this case, the
argument can be represented by \code{\_}. Our function literal calls
the Chisel method \code{.U} to convert the Scala \code{Char} to a Chisel
\code{UInt}. The sequence is then passed to \code{VecInit} to construct
a Chisel \code{Vec}. We index into the vector \code{text} with the counter
\code{cntReg} to provide the individual characters to the buffered transmitter.
With each \code{ready} signal we increase the counter until the full string
is sent out. The sender keeps \code{valid} asserted until the last character
has been sent out.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:uart:sender}はフレンドリーメッセージアウトを送信することにより、シリアルポートの送信機の使い方を示しています。
我々は、Scalaの列（\code{msg}）にメッセージを定義し、\code{UInt}のChisel\code{Vec}に変換します。
Scalaの文字列は\code{map}メソッドをサポートしていシーケンスです。
\code{map}メソッドは、引数として関数リテラルを取り、各要素に、この機能を適用し、関数の戻り値のシーケンスを構築します。
関数リテラルは引数を1つしか持たなければならない場合は、このケースであるように、引数が\code{\_}で表すことができます。
私たちの関数リテラルはChisel\code{UInt}にScalaの\code{Char}を変換するために、掘削方法\code{.U}を呼び出します。
シーケンスは、その後Chisel\code{Vec}を構築するために\code{VecInit}に渡されます。
バッファリング送信機に個々の文字を提供するために、カウンターとベクトル\code{text} \code{cntReg}に私たちはインデックス。
完全な文字列が送信されるまで、各\code{ready}信号によって、我々は、カウンタを増加させます。
送信者は、最後の文字が送信されるまで\code{valid}がアサートし続けます。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:uart:sender}はフレンドリーメッセージアウトを送信することにより、シリアルポートの送信機の使い方を示しています。
我々は、Scalaの列（\code{msg}）にメッセージを定義し、\code{UInt}のChisel\code{Vec}に変換します。
Scalaの文字列は\code{map}メソッドをサポートしていシーケンスです。
\code{map}メソッドは、引数として関数リテラルを取り、各要素に、この機能を適用し、関数の戻り値のシーケンスを構築します。
関数リテラルは引数を1つしか持たなければならない場合は、このケースであるように、引数が\code{\_}で表すことができます。
私たちの関数リテラルはChisel\code{UInt}にScalaの\code{Char}を変換するために、掘削方法\code{.U}を呼び出します。
シーケンスは、その後Chisel\code{Vec}を構築するために\code{VecInit}に渡されます。
バッファリング送信機に個々の文字を提供するために、カウンターとベクトル\code{text} \code{cntReg}に私たちはインデックス。
完全な文字列が送信されるまで、各\code{ready}信号によって、我々は、カウンタを増加させます。
送信者は、最後の文字が送信されるまで\code{valid}がアサートし続けます。
\fi

\ifshoworiginal
\longlist{code/uart_echo.txt}{Echoing data on the serial port.}{lst:uart:echo}
Listing~\ref{lst:uart:echo} shows the usage of the receiver and the transmitter
by connecting them together. This connection generates an \code{Echo} circuit where each
received character is sent back (echoed).
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:uart:echo}は、受信機と一緒にそれらを接続することにより、送信機の使い方を示しています。
この接続は、各受信された文字が送り返される\code{Echo}回路を生成する（エコー）。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:uart:echo}は、受信機と一緒にそれらを接続することにより、送信機の使い方を示しています。
この接続は、各受信された文字が送り返される\code{Echo}回路を生成する（エコー）。
\fi

\ifshoworiginal
\section{FIFO Design Variations}
\fi
\ifshowtransfirst %(自動翻訳)
\section{FIFO Design Variations}
\fi
\ifshowtranssecond %(校正)
\section{ FIFO設計のバリエーション (L11322 TODO)}
\fi

\label{sec:more:fifo}

\ifshoworiginal
In this section we will implement different variations of a FIFO queue.
To make these implementations interchangeable we will use inheritance,
as introduced in Section~\ref{sec:inheritance}.
\fi

\ifshowtransfirst %(自動翻訳)
このセクションでは、FIFOキューのさまざまなバリエーションを実装します。
節〜\ref{sec:inheritance}で導入され、これらの実装は、私たちが継承を使用する交換可能にします。
\fi

\ifshowtranssecond %(校正 TODO)
このセクションでは、FIFOキューのさまざまなバリエーションを実装します。
節〜\ref{sec:inheritance}で導入され、これらの実装は、私たちが継承を使用する交換可能にします。
\fi

\ifshoworiginal
\subsection{Parameterizing FIFOs}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Parameterizing FIFOs}
\fi
\ifshowtranssecond %(校正)
\subsection{FIFOのパラメータ化 (L1135 TODO)}
\fi

\ifshoworiginal
We define an \code{abstract}
FIFO class with a Chisel type as parameter to be able to buffer
any Chisel data type. In the abstract class we also test that the
parameter \code{depth} has a useful value.
\fi

\ifshowtransfirst %(自動翻訳)
我々は、任意のChiselデータタイプをバッファリングすることができるようにパラメータとしてChisel型と\code{abstract} FIFOクラスを定義します。
抽象クラスでは、我々はまた、パラメータ\code{depth}が有用価値を持っていることをテストします。
\fi

\ifshowtranssecond %(校正 TODO)
我々は、任意のChiselデータタイプをバッファリングすることができるようにパラメータとしてChisel型と\code{abstract} FIFOクラスを定義します。
抽象クラスでは、我々はまた、パラメータ\code{depth}が有用価値を持っていることをテストします。
\fi

\shortlist{code/fifo_abstract.txt}

\ifshoworiginal
In Section~\ref{sec:fifo} we defined our own types for the interface with common
names for signals, such as \code{write}, \code{full}, \code{din}, \code{read},
\code{empty}, and \code{dout}. The input and the output of such a buffer consists
of data and two signals for handshaking (e.g., we \code{write} into the FIFO when
it is not \code{full}.
\fi

\ifshowtransfirst %(自動翻訳)
節〜\ref{sec:fifo}では、我々は、このような\code{write}、\code{full}、\code{din}、\code{read}、RRR011dqUNBk4r、およびRRR011eBUalVC9などの信号のための一般的な名前、とのインタフェースのために私たち自身のタイプを定義しました。
入力などAバッファの出力は、（例えばハンドシェイクするためのデータと二つの信号から成ります。
グラム。
それは\code{full}ないとき、私たちは、FIFOに\code{write}。
\fi

\ifshowtranssecond %(校正 TODO)
節〜\ref{sec:fifo}では、我々は、このような\code{write}、\code{full}、\code{din}、\code{read}、RRR011dqUNBk4r、およびRRR011eBUalVC9などの信号のための一般的な名前、とのインタフェースのために私たち自身のタイプを定義しました。
入力などAバッファの出力は、（例えばハンドシェイクするためのデータと二つの信号から成ります。
グラム。
それは\code{full}ないとき、私たちは、FIFOに\code{write}。
\fi

\ifshoworiginal
However, we can generalize this handshaking to the so called ready-valid interface.
E.g, we can enqueue an element (write into the FIFO) when the FIFO is \code{ready}.
We signal this at the writer side with \code{valid}.
As this ready-valid interface is so common, Chisel provides a definition
of this interface in \code{DecoupledIO} as follows:\footnote{This is a simplification,
as \codefoot{DecoupledIO} actually extends an abstract class.}
\fi

\ifshowtransfirst %(自動翻訳)
しかし、我々は、いわゆる既製有効なインターフェイスにこのハンドシェイクを一般化することができます。
え。
G FIFOが\code{ready}ある場合、我々は、要素（FIFOへの書き込み）をエンキューすることができます。
私たちは、\code{valid}とライタ側でこれを合図します。
この既製有効なインターフェイスは非常に一般的であるように、以下のように、Chiselは\code{DecoupledIO}で、このインタフェースの定義を提供する：
ERROR-TBD
%\footnote{\codefoot{DecoupledIO}が実際に抽象クラスを拡張するように、これは、単純化です。｝
\fi

\ifshowtranssecond %(校正 TODO)
しかし、我々は、いわゆる既製有効なインターフェイスにこのハンドシェイクを一般化することができます。
え。
G FIFOが\code{ready}ある場合、我々は、要素（FIFOへの書き込み）をエンキューすることができます。
私たちは、\code{valid}とライタ側でこれを合図します。
この既製有効なインターフェイスは非常に一般的であるように、以下のように、Chiselは\code{DecoupledIO}で、このインタフェースの定義を提供する：
ERROR-TBD
%\footnote{\codefoot{DecoupledIO}が実際に抽象クラスを拡張するように、これは、単純化です。｝
\fi

\shortlist{code/fifo_decoupled.txt}

\ifshoworiginal
\noindent With the \code{DecoupledIO} interface we define the interface for our FIFOs:
a \code{FifoIO} with an \code{enq} enqueue and a \code{deq} dequeue port consisting
of read-valid interfaces.
 The \code{DecoupledIO} interface is defined from the writer's (producer's) view point.
Therefore, enqueue port of the FIFO needs to flip the signal directions.
\fi

\ifshowtransfirst %(自動翻訳)
\code{enq}エンキューと\code{FifoIO}し、読み取り有効なインタフェースからなる\code{deq}デキュー・ポート：\code{DecoupledIO}で、私たちは私たちのFIFOのためのインタフェースを定義しますインターフェイス。
\code{DecoupledIO}インタフェースは、作家の（生産者）の視点から定義されます。
したがって、FIFOのエンキューポート信号方向を反転する必要があります。
\fi

\ifshowtranssecond %(校正 TODO)
\code{enq}エンキューと\code{FifoIO}し、読み取り有効なインタフェースからなる\code{deq}デキュー・ポート：\code{DecoupledIO}で、私たちは私たちのFIFOのためのインタフェースを定義しますインターフェイス。
\code{DecoupledIO}インタフェースは、作家の（生産者）の視点から定義されます。
したがって、FIFOのエンキューポート信号方向を反転する必要があります。
\fi

\index{DecoupledIO}
\index{Ready-valid interface}

\shortlist{code/fifo_io.txt}

\ifshoworiginal
With the abstract base class and an interface we can specialize for different
FIFO implementations optimized for different parameters (speed, area, power,
or just simplicity).
\fi

\ifshowtransfirst %(自動翻訳)
抽象基底クラスとインタフェースで、私たちは、異なるパラメータ（速度、面積、消費電力、または単にシンプル）用に最適化された別のFIFOの実装のために特化することができます。
\fi

\ifshowtranssecond %(校正 TODO)
抽象基底クラスとインタフェースで、私たちは、異なるパラメータ（速度、面積、消費電力、または単にシンプル）用に最適化された別のFIFOの実装のために特化することができます。
\fi

\ifshoworiginal
\subsection{Redesigning the Bubble FIFO}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Redesigning the Bubble FIFO}
\fi
\ifshowtranssecond %(校正)
\subsection{バブルFIFOの再設計 (L11471 TODO)}
\fi

\ifshoworiginal
We can redefine our bubble FIFO from Section~\ref{sec:fifo} using standard
ready-valid interfaces and being parametrizable with a Chisel data type.
\fi

\ifshowtransfirst %(自動翻訳)
我々は、標準的な既製の有効なインターフェースを使用してChiselデータ型でパラメータ化され、セクション〜\ref{sec:fifo}から私たちのバブルFIFOを再定義することができます。
\fi

\ifshowtranssecond %(校正 TODO)
我々は、標準的な既製の有効なインターフェースを使用してChiselデータ型でパラメータ化され、セクション〜\ref{sec:fifo}から私たちのバブルFIFOを再定義することができます。
\fi

\longlist{code/fifo_bubble.txt}{A bubble FIFO with a ready-valid interface.}{lst:fifo:bubble}

\ifshoworiginal
Listing~\ref{lst:fifo:bubble} shows the refactored bubble FIFO with ready-valid
interface. Note what we put the \code{Buffer} component inside from \code{BubbleFifo}
as private class. This helper class is only needed for this component and therefore
we hide it and avoid polluting the name space. The buffer class has also been
simplified. Instead of an FSM e use only a single bit, \code{fullReg}, to note
the state of the buffer: full or empty.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:fifo:bubble}は、すぐ有効なインターフェイスを持つリファクタリングバブルFIFOを示しています。
注私たちは、プライベートクラスとして\code{BubbleFifo}から\code{Buffer}部品の内部を置きます。
このヘルパークラスは、このコンポーネントのために必要とされているので、我々はそれを隠し、名前空間を汚染しないようにします。
バッファクラスも簡素化されました。
代わりFSM電子用途の単一ビット、\code{fullReg}は、バッファの状態注：フルまたは空。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:fifo:bubble}は、すぐ有効なインターフェイスを持つリファクタリングバブルFIFOを示しています。
注私たちは、プライベートクラスとして\code{BubbleFifo}から\code{Buffer}部品の内部を置きます。
このヘルパークラスは、このコンポーネントのために必要とされているので、我々はそれを隠し、名前空間を汚染しないようにします。
バッファクラスも簡素化されました。
代わりFSM電子用途の単一ビット、\code{fullReg}は、バッファの状態注：フルまたは空。
\fi

\ifshoworiginal
The bubble FIFO is simply, easy to understand, and uses minimal resources.
However, as each buffer stage has to toggle between empty and full, the maximum
bandwidth of this FIFO is two clock cycles per word.
\fi

\ifshowtransfirst %(自動翻訳)
バブルFIFOは、単純に理解しやすく、最小限のリソースを使用しています。
各バッファ段が空と満杯を切り替えなければならないしかし、このFIFOの最大帯域幅は、ワード当たり2回のクロックサイクルです。
\fi

\ifshowtranssecond %(校正 TODO)
バブルFIFOは、単純に理解しやすく、最小限のリソースを使用しています。
各バッファ段が空と満杯を切り替えなければならないしかし、このFIFOの最大帯域幅は、ワード当たり2回のクロックサイクルです。
\fi

\ifshoworiginal
One could consider to look at both interface sides in the buffer to be able to accept
a new word when the producer \code{valid} and the consumer is \code{ready}.
However, this introduces a combinational path from the consumer handshake
to the producer handshake, which violates the semantics of the ready-valid protocol.
\fi

\ifshowtransfirst %(自動翻訳)
一つはプロデューサー\code{valid}と消費者が\code{ready}ときに新しい単語を受け入れることができるように、バッファの両方のインターフェイス側を見て検討することができます。
しかし、これは、すぐ有効なプロトコルのセマンティクスに違反プロデューサーの握手に消費者の握手から組み合わせパスを導入しています。
\fi

\ifshowtranssecond %(校正 TODO)
一つはプロデューサー\code{valid}と消費者が\code{ready}ときに新しい単語を受け入れることができるように、バッファの両方のインターフェイス側を見て検討することができます。
しかし、これは、すぐ有効なプロトコルのセマンティクスに違反プロデューサーの握手に消費者の握手から組み合わせパスを導入しています。
\fi

\ifshoworiginal
\subsection{Double Buffer FIFO}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Double Buffer FIFO}
\fi
\ifshowtranssecond %(校正)
\subsection{ダブルバッファFIFO (L11554 TODO)}
\fi

\index{Double buffer FIFO}

\ifshoworiginal
One solution is stay \code{ready} even when the buffer register if full.
To be able to accept a data word from the producer, when the consumer is not
\code{ready} we need a second buffer, we call it the shadow register.
When the the buffer is full, new data is stored in the shadow register and \code{ready}
is de-asserted. When the consumer becomes \code{ready} again, data is transferred
from the data register to the consumer and from the shadow register into
the data register.
\fi

\ifshowtransfirst %(自動翻訳)
完全な場合は、バッファが登録しても一つの解決策は、滞在\code{ready}です。
消費者は、我々は第2のバッファを必要とし\code{ready}ない場合には、生産者からのデータワードを受け入れることができるようにするために、我々は、シャドウ・レジスタと呼んでいます。
バッファがいっぱいになると、新しいデータは、シャドウ・レジスタに格納され、\code{ready}はデアサートされます。
消費者が再び\code{ready}になるとデータレジスタにデータが消費者にシャドウレジスタからレジスタから、データが転送されます。
\fi

\ifshowtranssecond %(校正 TODO)
完全な場合は、バッファが登録しても一つの解決策は、滞在\code{ready}です。
消費者は、我々は第2のバッファを必要とし\code{ready}ない場合には、生産者からのデータワードを受け入れることができるようにするために、我々は、シャドウ・レジスタと呼んでいます。
バッファがいっぱいになると、新しいデータは、シャドウ・レジスタに格納され、\code{ready}はデアサートされます。
消費者が再び\code{ready}になるとデータレジスタにデータが消費者にシャドウレジスタからレジスタから、データが転送されます。
\fi

\verylonglist{code/fifo_double_buffer.txt}{A FIFO with double buffer elements.}{lst:fifo:double:buffer}

\ifshoworiginal
Listing~\ref{lst:fifo:double:buffer} shows the double buffer. As each buffer element
can store two entries we need only half of the buffer elements (\code{depth/2}).
The \code{DoubleBuffer} contains two registers,
\code{dataReg} and \code{shadowReg}. The consumer is served always from
\code{shadowReg}. The double buffer has three states: \code{empty}, \code{one},
and \code{two}, which signal the fill level of the double buffer.
The buffer is \code{ready} to accept new data when is it in state \code{empty}
or \code{one}. The has valid data when it is in state \code{one} or \code{two}.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:fifo:double:buffer}はダブルバッファを示しています。
各バッファ素子として、我々はバッファ素子（\code{depth/2}）の半分だけを必要とする2つのエントリを格納することができます。
\code{DoubleBuffer} 2つのレジスタ、\code{dataReg}と\code{shadowReg}が含まれています。
消費者は\code{shadowReg}から常に提供しています。
\code{empty}、\code{one}、及び\code{two}、ダブルバッファの充填レベルを信号：ダブルバッファの3つの状態を有しています。
バッファは、それが国家\code{empty}か\code{one}にあるときに、新しいデータを受け入れること\code{ready}です。
それは状態\code{one}か\code{two}であるときに有効なデータを持っています。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:fifo:double:buffer}はダブルバッファを示しています。
各バッファ素子として、我々はバッファ素子（\code{depth/2}）の半分だけを必要とする2つのエントリを格納することができます。
\code{DoubleBuffer} 2つのレジスタ、\code{dataReg}と\code{shadowReg}が含まれています。
消費者は\code{shadowReg}から常に提供しています。
\code{empty}、\code{one}、及び\code{two}、ダブルバッファの充填レベルを信号：ダブルバッファの3つの状態を有しています。
バッファは、それが国家\code{empty}か\code{one}にあるときに、新しいデータを受け入れること\code{ready}です。
それは状態\code{one}か\code{two}であるときに有効なデータを持っています。
\fi

\ifshoworiginal
If we run the FIFO at full speed and the consumer is always \code{ready}
the steady state of the double buffers are \code{one}. Only when the consumer
de-asserts \code{ready}, the queue fills up and the buffers enter state \code{two}.
However, compared to a single bubble FIFO, a restart of the queue takes
only half the number fo clock cycles for the same buffer capacity.
Similar the fall through latency is half of the bubble FIFO.
\fi

\ifshowtransfirst %(自動翻訳)
我々はフルスピードでFIFOを実行して、消費者は常にダブルバッファの\code{ready}定常状態である場合\code{one}です。
消費者の\code{ready}をデアサートた場合にのみ、キューがいっぱいになると、バッファは、状態\code{two}を入力してください。
しかし、単一のバブルFIFOに比べて、キューの再起動が同じバッファ容量のためのクロック・サイクルFOのみ半分の数になります。
レイテンシーによる同様の秋には、バブルFIFOの半分です。
\fi

\ifshowtranssecond %(校正 TODO)
我々はフルスピードでFIFOを実行して、消費者は常にダブルバッファの\code{ready}定常状態である場合\code{one}です。
消費者の\code{ready}をデアサートた場合にのみ、キューがいっぱいになると、バッファは、状態\code{two}を入力してください。
しかし、単一のバブルFIFOに比べて、キューの再起動が同じバッファ容量のためのクロック・サイクルFOのみ半分の数になります。
レイテンシーによる同様の秋には、バブルFIFOの半分です。
\fi

\ifshoworiginal
\subsection{FIFO with Register Memory}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{FIFO with Register Memory}
\fi
\ifshowtranssecond %(校正)
\subsection{レジスタメモリ付きFIFO (L11646 TODO)}
\fi

\ifshoworiginal
When you come with a software engineering background you may have been
wondering that we built hardware queues out of many small individual small buffer
elements, all executing in parallel and handshaking with upstream and downstream
elements. For small buffers this is probably the most efficient implementation.
\fi

\ifshowtransfirst %(自動翻訳)
あなたは、ソフトウェアエンジニアリングの背景に来るとき、あなたはすべてを並列に実行し、上流と下流の要素とハンドシェーク、我々は多くの小さな個々の小さなバッファ要素のうち、ハードウェアキューを構築していることを不思議に思っている可能性があります。
小さなバッファの場合、これはおそらく最も効率的な実装です。
\fi

\ifshowtranssecond %(校正 TODO)
あなたは、ソフトウェアエンジニアリングの背景に来るとき、あなたはすべてを並列に実行し、上流と下流の要素とハンドシェーク、我々は多くの小さな個々の小さなバッファ要素のうち、ハードウェアキューを構築していることを不思議に思っている可能性があります。
小さなバッファの場合、これはおそらく最も効率的な実装です。
\fi

\index{Circular buffer}
\index{Circular buffer!read pointer}
\index{Circular buffer!write pointer}

\ifshoworiginal
A queue in software is usually used by a sequential code in a single thread.
Or as a queue to decouple a producer and consumer thread.
In this setting a fixed size FIFO queue is usually implemented as a
\myref{https://en.wikipedia.org/wiki/Circular_buffer}{circular buffer}.
Two pointers point into read and write positions in a memory set aside
for the queue. When the pointers reach the end of the memory, the
are set back to the begin of that memory. The difference between the two
pointers is the number of elements in the queue. When the two pointers
point to the same address, the queue is either empty or full.
To distinguish between empty and full we need another flag.
\fi

\ifshowtransfirst %(自動翻訳)
ソフトウェアでのキューは通常、シングルスレッドでのシーケンシャルコードで使用されます。
またはキューとして生産者と消費者のスレッドを分離します。
この設定の固定サイズでFIFOキューは通常\myref{https://en.wikipedia.org/wiki/Circular_buffer}{circular buffer}として実装されています。
二つのポインタは、キュー用に確保したメモリ内の読み取りと書き込みの位置にポイントします。
ポインタはメモリの最後に到達すると、そのメモリの開始に背を設定されています。
2つのポインタの違いは、キュー内の要素の数です。
二つのポインタが同じアドレスをポイントすると、キューが空またはフルのいずれかです。
空とフル区別するために、我々は別のフラグが必要です。
\fi

\ifshowtranssecond %(校正 TODO)
ソフトウェアでのキューは通常、シングルスレッドでのシーケンシャルコードで使用されます。
またはキューとして生産者と消費者のスレッドを分離します。
この設定の固定サイズでFIFOキューは通常\myref{https://en.wikipedia.org/wiki/Circular_buffer}{circular buffer}として実装されています。
二つのポインタは、キュー用に確保したメモリ内の読み取りと書き込みの位置にポイントします。
ポインタはメモリの最後に到達すると、そのメモリの開始に背を設定されています。
2つのポインタの違いは、キュー内の要素の数です。
二つのポインタが同じアドレスをポイントすると、キューが空またはフルのいずれかです。
空とフル区別するために、我々は別のフラグが必要です。
\fi

\ifshoworiginal
We can implement such a memory based FIFO queue in hardware as
well. For small queues, we can use a register file (i.e., a \code{Reg(Vec())}).
Listing~\ref{lst:fifo:reg:mem} shows a FIFO queue implemented with  memory
and read and write pointers.
\fi

\ifshowtransfirst %(自動翻訳)
我々としても、ハードウェアでは、このようなAメモリベースのFIFOキューを実装することができます。
小さなキューの場合、我々は、（iをレジスタ・ファイルを使用することができます。
え。
\code{Reg(Vec())}）。
〜\ref{lst:fifo:reg:mem}ショーリストFIFOメモリを用いて実装し、読み取りと書き込みのポインタキュー。
\fi

\ifshowtranssecond %(校正 TODO)
我々としても、ハードウェアでは、このようなAメモリベースのFIFOキューを実装することができます。
小さなキューの場合、我々は、（iをレジスタ・ファイルを使用することができます。
え。
\code{Reg(Vec())}）。
〜\ref{lst:fifo:reg:mem}ショーリストFIFOメモリを用いて実装し、読み取りと書き込みのポインタキュー。
\fi

\verylonglist{code/fifo_reg_mem.txt}{A FIFO with a register based memory.}{lst:fifo:reg:mem}

\ifshoworiginal
As there are two pointers that behave the same, being incremented on an
action and wrap around at the end of the buffer, we define a function \code{counter}
that implements those wrapping counters. With \code{log2Ceil(depth).W} we
compute the bit length of the counter. The next value is either an increment by
1 or a wrap around to 0.
The counter is incremented only when the input \code{incr} is \code{true.B}.
\fi

\ifshowtransfirst %(自動翻訳)
同じように動作し、アクションにインクリメントされると、バッファの最後で折り返すことに二つのポインタがあるように、我々は実装し、それらのラッピングカウンターという関数\code{counter}を定義します。
\code{log2Ceil(depth).W}で、私たちは、カウンタのビット長を計算します。
次の値のいずれか1によってインクリメント又は0にラップアラウンドします。
カウンタは入力\code{incr}が\code{true.B}あるときにのみインクリメントされます。
\fi

\ifshowtranssecond %(校正 TODO)
同じように動作し、アクションにインクリメントされると、バッファの最後で折り返すことに二つのポインタがあるように、我々は実装し、それらのラッピングカウンターという関数\code{counter}を定義します。
\code{log2Ceil(depth).W}で、私たちは、カウンタのビット長を計算します。
次の値のいずれか1によってインクリメント又は0にラップアラウンドします。
カウンタは入力\code{incr}が\code{true.B}あるときにのみインクリメントされます。
\fi

\ifshoworiginal
Furthermore, as we need also the
possible next value (increment or 0 on wrap around), we return this value from
the \code{counter} function as well. In Scala we can return a so called \emph{tuple},
which is simply a container to hold more than one value. The syntax to create
such a duple is simply wrapping the comma separated values in parentheses:
\fi

\ifshowtransfirst %(自動翻訳)
我々はまた、可能な次の値（増分またはラップの周りに0を）必要があるとして、さらに、我々としても\code{counter}関数からこの値を返します。
スカラ座では、単に複数の値を保持するための容器であり、いわゆる\emph{tuple}を、返すことができます。
そのようなdupleは単にコンマをラップさ作成するための構文は、括弧内の値を分離しました：
\fi

\ifshowtranssecond %(校正 TODO)
我々はまた、可能な次の値（増分またはラップの周りに0を）必要があるとして、さらに、我々としても\code{counter}関数からこの値を返します。
スカラ座では、単に複数の値を保持するための容器であり、いわゆる\emph{tuple}を、返すことができます。
そのようなdupleは単にコンマをラップさ作成するための構文は、括弧内の値を分離しました：
\fi

\index{tuple}

\begin{chisel}
  val t = (v1, v2)
\end{chisel}

\ifshoworiginal
\noindent We can deconstruct such a tuple by using the parenthesis notation
on the left hand side of the assignment:
\fi

\ifshowtransfirst %(自動翻訳)
我々は、割り当ての左側の括弧表記を使用してそのようなタプルを分解することができます。
\fi

\ifshowtranssecond %(校正 TODO)
我々は、割り当ての左側の括弧表記を使用してそのようなタプルを分解することができます。
\fi

\begin{chisel}
val (x1, x2) = t
\end{chisel}

\ifshoworiginal
For the memory we us a register of a vector (\code{Reg(Vec(depth, gen))} of
Chisel data type \code{gen}. We define two signal to increment the read and
write pointer and create the read and write pointers with the function \code{counter}.
When both pointer are equal, the buffer is either empty or full.
We define two flags to for the notion of empty and full.
\fi

\ifshowtransfirst %(自動翻訳)
メモリについては、私たち私たちのベクトルのレジスタ（\code{Reg(Vec(depth, gen))}Chiselのデータ型\code{gen}。
私たちは、読み取りと書き込みポインタをインクリメントし、機能\code{counter}と、読み取りと書き込みのポインタを作成するために、2つの信号を定義します。
両方のポインタが等しい場合、バッファが空またはフルのいずれかです。
私たちは、空とフルの概念のために二つのフラグを定義します。
\fi

\ifshowtranssecond %(校正 TODO)
メモリについては、私たち私たちのベクトルのレジスタ（\code{Reg(Vec(depth, gen))}Chiselのデータ型\code{gen}。
私たちは、読み取りと書き込みポインタをインクリメントし、機能\code{counter}と、読み取りと書き込みのポインタを作成するために、2つの信号を定義します。
両方のポインタが等しい場合、バッファが空またはフルのいずれかです。
私たちは、空とフルの概念のために二つのフラグを定義します。
\fi

\ifshoworiginal
When the producer asserts \code{valid} and the FIFO is not full we:
(1) write into the buffer, (2) ensure \code{emptyReg} is de-asserted,
(3) mark the buffer full if the write pointer will catch up with the read pointer
in the next clock cycle (compare the current read pointer with the next
write pointer), and (4) signal the write counter to increment.
\fi

\ifshowtransfirst %(自動翻訳)
\code{emptyReg}がディアサートされていることを確認バッファに（1）書き込み、（2）書き込みポインタがでリードポインタに追いつくだろう場合、（3）は、フルバッファをマーク：プロデューサーがアサートすると\code{valid}とFIFOは、私たち一杯になっていません次のクロックサイクル（次の書き込みポインタと、現在の読み出しポインタを比較されたい）、及び（4）は増加への書き込みカウンタに信号を送ります。
\fi

\ifshowtranssecond %(校正 TODO)
\code{emptyReg}がディアサートされていることを確認バッファに（1）書き込み、（2）書き込みポインタがでリードポインタに追いつくだろう場合、（3）は、フルバッファをマーク：プロデューサーがアサートすると\code{valid}とFIFOは、私たち一杯になっていません次のクロックサイクル（次の書き込みポインタと、現在の読み出しポインタを比較されたい）、及び（4）は増加への書き込みカウンタに信号を送ります。
\fi

\ifshoworiginal
When the consumer is \code{ready} and the FIFO is not empty we:
(1) ensure that the \code{fullReg} is de-asserted, (2) mark the buffer
empty if the read pointer will catch up with the write pointer in
the next clock cycle, and (3) signal the read counter to increment.
\fi

\ifshowtransfirst %(自動翻訳)
消費者が\code{ready}で、FIFOは、私たちを空にされていない場合：（1）\code{fullReg}がディアサートされていることを確認し、（2）読み出しポインタは、次のクロック・サイクルでの書き込みポインタに追いつくかどうバッファが空にマークし、 （3）は、増分に読み出しカウンタに信号を送ります。
\fi

\ifshowtranssecond %(校正 TODO)
消費者が\code{ready}で、FIFOは、私たちを空にされていない場合：（1）\code{fullReg}がディアサートされていることを確認し、（2）読み出しポインタは、次のクロック・サイクルでの書き込みポインタに追いつくかどうバッファが空にマークし、 （3）は、増分に読み出しカウンタに信号を送ります。
\fi

\ifshoworiginal
The output of the FIFO is the memory element at the read pointer address.
The ready and valid flags are simply derived from the full and empty
flags.
\fi

\ifshowtransfirst %(自動翻訳)
FIFOの出力は、読み取りポインタアドレスのメモリ素子です。
準備ができて、有効なフラグは、単にフルと空の旗から派生しています。
\fi

\ifshowtranssecond %(校正 TODO)
FIFOの出力は、読み取りポインタアドレスのメモリ素子です。
準備ができて、有効なフラグは、単にフルと空の旗から派生しています。
\fi

\ifshoworiginal
\subsection{FIFO with On-Chip Memory}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{FIFO with On-Chip Memory}
\fi
\ifshowtranssecond %(校正)
\subsection{オンチップメモリ付きFIFO (L11872 TODO)}
\fi

\ifshoworiginal
The last version of the FIFO used a register files to represent the memory,
which is a good solution for a small FIFO. For larger FIFOs it is better to
use on-chip memory.
Listing~\ref{lst:fifo:mem} shows a FIFO using a synchronous memory for
storage.
\fi

\ifshowtransfirst %(自動翻訳)
FIFOの最後のバージョンは、小さなFIFOに適したソリューションであるメモリを、表現するためにレジスタ・ファイルを使用していました。
大規模のFIFOにとっては、オンチップ・メモリを使用することをお勧めします。
一覧〜\ref{lst:fifo:mem}は、ストレージのための同期メモリを使用してFIFOを示しています。
\fi

\ifshowtranssecond %(校正 TODO)
FIFOの最後のバージョンは、小さなFIFOに適したソリューションであるメモリを、表現するためにレジスタ・ファイルを使用していました。
大規模のFIFOにとっては、オンチップ・メモリを使用することをお勧めします。
一覧〜\ref{lst:fifo:mem}は、ストレージのための同期メモリを使用してFIFOを示しています。
\fi

\verylonglist{code/fifo_mem.txt}{A FIFO with a on-chip memory.}{lst:fifo:mem}

\ifshoworiginal
The handling of read and write pointer is identical to the register memory
FIFO. However, a synchronous on-chip memory delivers the result of a read
in the next clock cycle, where the read of the register file was available in the
same clock cycle.
\fi

\ifshowtransfirst %(自動翻訳)
読み取りと書き込みポインタの取り扱いは、レジスタメモリFIFOと同じです。
しかし、同期オンチップメモリ​​は、レジスタファイルの読み出しが同じクロックサイクルで利用可能であった次のクロックサイクルにおいて、読み出しの結果を提供します。
\fi

\ifshowtranssecond %(校正 TODO)
読み取りと書き込みポインタの取り扱いは、レジスタメモリFIFOと同じです。
しかし、同期オンチップメモリ​​は、レジスタファイルの読み出しが同じクロックサイクルで利用可能であった次のクロックサイクルにおいて、読み出しの結果を提供します。
\fi

\ifshoworiginal
Therefore, we need some additional FSM and a shadow register to handle
this latency. We read the memory out and provide the value of the top of the queue
to the output port. If that value is not consumed, we need to store it in the
shadow register \code{shadowReg} while reading the next value from the memory.
The state machine consists of three states to represent: (1) an empty FIFO, (2) a valid
data read out from the memory, and (3) head of the queue in the shadow register and
valid data (the next element) from the memory.
\fi

\ifshowtransfirst %(自動翻訳)
したがって、我々はこの遅延を処理するためにいくつかの追加のFSMとシャドウレジスタを必要としています。
私たちは、メモリを読み出して出力ポートへのキューの先頭の値を提供します。
その値が消費されていない場合、我々はメモリから次の値を読みながら、シャドウ・レジスタ\code{shadowReg}に保管する必要があります。
ステートマシンが表現するために3つの状態から成る：（1）空のFIFOは、（2）有効なデータがメモリから読み出され、シャドウ・レジスタと、有効データ（次の要素）内のキューの（3）頭部から想い出。
\fi

\ifshowtranssecond %(校正 TODO)
したがって、我々はこの遅延を処理するためにいくつかの追加のFSMとシャドウレジスタを必要としています。
私たちは、メモリを読み出して出力ポートへのキューの先頭の値を提供します。
その値が消費されていない場合、我々はメモリから次の値を読みながら、シャドウ・レジスタ\code{shadowReg}に保管する必要があります。
ステートマシンが表現するために3つの状態から成る：（1）空のFIFOは、（2）有効なデータがメモリから読み出され、シャドウ・レジスタと、有効データ（次の要素）内のキューの（3）頭部から想い出。
\fi

\ifshoworiginal
The memory based FIFO can efficiently hold larger amounts of data in the queue
and has a short fall through latency. In the last design, the output of the FIFO may
come directly from the memory read. If this data path is in the critical path of the design,
we can easily pipeline our design by combining two FIFOs. Listing~\ref{lst:fifo:comb}
shows such a combination. On the output of the memory based FIFO we add a single
stage double buffer FIFO to decouple the memory read path from the output.
\fi

\ifshowtransfirst %(自動翻訳)
FIFOベースのメモリを効率的にキューに大量のデータを保持し、待ち時間を通じて短い秋を持っていることができます。
最後の設計では、FIFOの出力は、メモリの読み取りから直接来るかもしれません。
このデータパスは、デザインのクリティカル・パスにある場合は、我々は2つのFIFOを組み合わせることで簡単にパイプライン私たちのデザインをすることができます。
一覧〜\ref{lst:fifo:comb}は、このような組み合わせを示しています。
FIFOベースのメモリの出力では、我々は二重の出力からメモリ読み出し経路を分離するためにFIFOバッファを単一のステージを追加します。
\fi

\ifshowtranssecond %(校正 TODO)
FIFOベースのメモリを効率的にキューに大量のデータを保持し、待ち時間を通じて短い秋を持っていることができます。
最後の設計では、FIFOの出力は、メモリの読み取りから直接来るかもしれません。
このデータパスは、デザインのクリティカル・パスにある場合は、我々は2つのFIFOを組み合わせることで簡単にパイプライン私たちのデザインをすることができます。
一覧〜\ref{lst:fifo:comb}は、このような組み合わせを示しています。
FIFOベースのメモリの出力では、我々は二重の出力からメモリ読み出し経路を分離するためにFIFOバッファを単一のステージを追加します。
\fi

\longlist{code/fifo_comb.txt}{Combining a memory based FIFO with double-buffer
stage.}{lst:fifo:comb}

%ステージ。
%} {LST：FIFO：櫛}

\ifshoworiginal
\section{Exercises}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Exercises}
\fi
\ifshowtranssecond %(校正)
\section{演習 (L11980 TODO)}
\fi

\ifshoworiginal
This exercise section is a little bit longer as it contains two exercises:
(1) exploring the bubble FIFO and implement a different FIFO design;
and (2) exploring the UART and extending it.
Source code for both exercises is included in the
\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples} repository.
\fi

\ifshowtransfirst %(自動翻訳)
それは2つの演習が含まれているとして、この演習のセクションでは、少し長いです：（1）は、バブルFIFOを探索し、異なるFIFOの設計を実装します。及び（2）UARTを探索し、それを拡張します。
両方の練習のためのソースコードは、\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}リポジトリに含まれています。
\fi

\ifshowtranssecond %(校正 TODO)
それは2つの演習が含まれているとして、この演習のセクションでは、少し長いです：（1）は、バブルFIFOを探索し、異なるFIFOの設計を実装します。及び（2）UARTを探索し、それを拡張します。
両方の練習のためのソースコードは、\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}リポジトリに含まれています。
\fi

\ifshoworiginal
\subsection{Explore the Bubble FIFO}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{Explore the Bubble FIFO}
\fi
\ifshowtranssecond %(校正)
\subsection{バブルFIFOを探る (12004 TODO)}
\fi

\ifshoworiginal
The FIFO source also includes a tester that provokes different read and write behavior and generates a waveform in the
\myref{https://en.wikipedia.org/wiki/Value_change_dump}{value change dump (VCD)} format.
The VCD file can be viewed with a waveform viewer, such as
\myref{http://gtkwave.sourceforge.net/}{GTKWave}.
Explore the
\myref{https://github.com/schoeberl/chisel-examples/blob/master/src/test/scala/simple/FifoTester.scala}{FifoTester} in the repository.
The repository contains a \code{Makefile} to run the examples, for the FIFO example
just type:
\fi

\ifshowtransfirst %(自動翻訳)
FIFO源は、異なる読み取りおよび書き込み動作を引き起こすと\myref{https://en.wikipedia.org/wiki/Value_change_dump}{value change dump (VCD)}形式で波形を生成するテスタを含みます。
VCDファイルには、\myref{http://gtkwave.sourceforge.net/}{GTKWave}として、波形ビューアで表示できます。
リポジトリに\myref{https://github.com/schoeberl/chisel-examples/blob/master/src/test/scala/simple/FifoTester.scala}{FifoTester}を探検。
リポジトリはFIFOの例は、単に入力のために、例を実行するには\code{Makefile}が含まれていますRRR0009nmx3Tokこのmakeコマンドは、FIFOをコンパイル、テストを実行し、波形表示用にGTKWaveを開始します。
テスタと生成された波形を探検。
\fi

\ifshowtranssecond %(校正 TODO)
FIFO源は、異なる読み取りおよび書き込み動作を引き起こすと\myref{https://en.wikipedia.org/wiki/Value_change_dump}{value change dump (VCD)}形式で波形を生成するテスタを含みます。
VCDファイルには、\myref{http://gtkwave.sourceforge.net/}{GTKWave}として、波形ビューアで表示できます。
リポジトリに\myref{https://github.com/schoeberl/chisel-examples/blob/master/src/test/scala/simple/FifoTester.scala}{FifoTester}を探検。
リポジトリはFIFOの例は、単に入力のために、例を実行するには\code{Makefile}が含まれていますRRR0009nmx3Tokこのmakeコマンドは、FIFOをコンパイル、テストを実行し、波形表示用にGTKWaveを開始します。
テスタと生成された波形を探検。
\fi

\begin{verbatim}
$ make fifo
\end{verbatim}

\ifshoworiginal
This make command will compile the FIFO, run the test, and starts GTKWave for waveform
viewing. Explore the tester and the generated waveform.
\fi

\ifshowtransfirst %(自動翻訳)
このmakeコマンドでFIFOをコンパイルし、テストを実行し、波形を見るためにGTKWaveを起動します。
テスターと生成された波形を探ります。
\fi

\ifshowtranssecond %(校正 TODO)
このmakeコマンドでFIFOをコンパイルし、テストを実行し、波形を見るためにGTKWaveを起動します。
テスターと生成された波形を探ります。
\fi

\ifshoworiginal
In the first cycles, the tester writes a single word. We can observe in
the waveform how that word bubbles through the FIFO, therefore the
name \emph{bubble FIFO}. This bubbling also means that the
latency of a data word through the FIFO is equal to the depth of the FIFO.
\fi

\ifshowtransfirst %(自動翻訳)
最初のサイクルでは、テスターは、単一の単語を書き込みます。
その言葉は、したがって、FIFOを通じて名前\emph{bubble FIFO}バブルどのように我々は波形で観察することができます。
この泡立ちはまた、FIFOを介してデータワードのレイテンシはFIFOの深さに等しいことを意味します。
\fi

\ifshowtranssecond %(校正 TODO)
最初のサイクルでは、テスターは、単一の単語を書き込みます。
その言葉は、したがって、FIFOを通じて名前\emph{bubble FIFO}バブルどのように我々は波形で観察することができます。
この泡立ちはまた、FIFOを介してデータワードのレイテンシはFIFOの深さに等しいことを意味します。
\fi

\ifshoworiginal
The next test fills the FIFO until it is full. A single read follows.
Notice how the empty word bubbles from the reader side of the FIFO
to the writer side. When a bubble FIFO is full, it takes
a latency of the buffer depth for a read to affect the writer side.
\fi

\ifshowtransfirst %(自動翻訳)
それがいっぱいになるまで、次のテストでは、FIFOを埋めます。
単一の読み取りは、以下の通りです。
空の言葉は、作家側にFIFOの読者側から気泡をどのように注意してください。
バブルFIFOがフルになると、それは作家側に影響を与えるために、読み取りのためのバッファの深さの待ち時間がかかります。
\fi

\ifshowtranssecond %(校正 TODO)
それがいっぱいになるまで、次のテストでは、FIFOを埋めます。
単一の読み取りは、以下の通りです。
空の言葉は、作家側にFIFOの読者側から気泡をどのように注意してください。
バブルFIFOがフルになると、それは作家側に影響を与えるために、読み取りのためのバッファの深さの待ち時間がかかります。
\fi

\ifshoworiginal
The end of the test contains a loop that tries to write and read at maximum speed.
We can see the bubble FIFO running at maximum bandwidth, which is two
clock cycles per word. A buffer stage has always to toggle between empty
and full for a single word transfer.
\fi

\ifshowtransfirst %(自動翻訳)
試験の終わりには、試行が最大速度で読み書きすることループを含んでいます。
私たちは、バブルFIFOは、単語ごとに2回のクロックサイクルで最大帯域幅、で動作して見ることができます。
バッファ・ステージは、単一のワード転送のために、空と完全切り替えること常に有します。
\fi

\ifshowtranssecond %(校正 TODO)
試験の終わりには、試行が最大速度で読み書きすることループを含んでいます。
私たちは、バブルFIFOは、単語ごとに2回のクロックサイクルで最大帯域幅、で動作して見ることができます。
バッファ・ステージは、単一のワード転送のために、空と完全切り替えること常に有します。
\fi

\ifshoworiginal
A bubble FIFO is simple and for small buffers has a low resource requirement.
The main drawbacks of an $n$ stage bubble FIFO are: (1) maximum throughput is
one word every two clock cycles, (2) a data word has to travel $n$ clock cycles
from the writer end to the reader end, and (3) a full FIFO needs $n$ clock cycles
for the restart.
\fi

\ifshowtransfirst %(自動翻訳)
バブルFIFOは簡単で、小さなバッファ用の低リソース要件があります。
$ N $ステージバブルFIFOの主な欠点がある：一つの単語毎に2クロックサイクル、（2）データワードがリーダー端に$ Nライタ端から$クロックサイクルを移動しなければならないでスループット（1）最大値、及び（3）完全なFIFOは、再起動のために$ N $クロック・サイクルを必要とします。
\fi

\ifshowtranssecond %(校正 TODO)
バブルFIFOは簡単で、小さなバッファ用の低リソース要件があります。
$ N $ステージバブルFIFOの主な欠点がある：一つの単語毎に2クロックサイクル、（2）データワードがリーダー端に$ Nライタ端から$クロックサイクルを移動しなければならないでスループット（1）最大値、及び（3）完全なFIFOは、再起動のために$ N $クロック・サイクルを必要とします。
\fi

\ifshoworiginal
These drawbacks can be solved by a FIFO implementation with a
\myref{https://en.wikipedia.org/wiki/Circular_buffer}{circular buffer}.
The circular buffer can be implemented with a memory and
read and write pointers.
Implement a FIFO as a circular buffer with four elements, using the same
interface, and explore the different behavior with the tester.
For an initial implementation of the circular buffer use, as a shortcut,
a vector of registers (\code{Reg(Vec(4, UInt(size.W)))}).
\fi

\ifshowtransfirst %(自動翻訳)
これらの欠点は\myref{https://en.wikipedia.org/wiki/Circular_buffer}{circular buffer}とFIFOの実装によって解決することができます。
循環バッファメモリと、読み取りと書き込みポインタで実現することができます。
同じインタフェースを使用して、四つの要素を有する循環バッファとしてFIFOを実装し、テスターと異なる挙動を探ります。
ショートカットとして円形のバッファ使用、レジスタ（\code{Reg(Vec(4, UInt(size.W)))}）のベクトルの最初の実装のために。
\fi

\ifshowtranssecond %(校正 TODO)
これらの欠点は\myref{https://en.wikipedia.org/wiki/Circular_buffer}{circular buffer}とFIFOの実装によって解決することができます。
循環バッファメモリと、読み取りと書き込みポインタで実現することができます。
同じインタフェースを使用して、四つの要素を有する循環バッファとしてFIFOを実装し、テスターと異なる挙動を探ります。
ショートカットとして円形のバッファ使用、レジスタ（\code{Reg(Vec(4, UInt(size.W)))}）のベクトルの最初の実装のために。
\fi

\ifshoworiginal
\subsection{The UART}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{The UART}
\fi
\ifshowtranssecond %(校正)
\subsection{UART (L12162 TODO)}
\fi

\ifshoworiginal
For the UART example, you need an FPGA board with a serial port and
a serial port for your laptop (usually with a USB connection).
Connect the serial cable between the FPGA board and the serial port on
your laptop. Start a terminal program, e.g., Hyperterm on Windows
or \code{gtkterm} on Linux:
\fi

\ifshowtransfirst %(自動翻訳)
UARTのたとえば、（通常はUSB接続で）あなたのラップトップ用のシリアルポートを備えたFPGAボードとシリアルポートを必要としています。
あなたのラップトップ上のFPGAボードとシリアルポート間のシリアルケーブルを接続します。
、電子のターミナルプログラムを起動します。
グラム。
、Linux上でWindowsまたは\code{gtkterm}上のハイパーターミナル：RRR000kxWLefJ0設定あなたのポートが、これは多くの場合、\code{/dev/ttyUSB0}のようなものであるUSBのUARTで、正しいデバイスを使用します。
\fi

\ifshowtranssecond %(校正 TODO)
UARTのたとえば、（通常はUSB接続で）あなたのラップトップ用のシリアルポートを備えたFPGAボードとシリアルポートを必要としています。
あなたのラップトップ上のFPGAボードとシリアルポート間のシリアルケーブルを接続します。
、電子のターミナルプログラムを起動します。
グラム。
、Linux上でWindowsまたは\code{gtkterm}上のハイパーターミナル：RRR000kxWLefJ0設定あなたのポートが、これは多くの場合、\code{/dev/ttyUSB0}のようなものであるUSBのUARTで、正しいデバイスを使用します。
\fi

\begin{verbatim}
$ gtkterm &
\end{verbatim}

\ifshoworiginal
Configure your port to use the correct device, with a USB UART this
is often something like \code{/dev/ttyUSB0}. Set the baud rate to 115200
and no parity or flow control (handshake).
With the following command you can create the Verilog code for the UART:
\fi

\ifshowtransfirst %(自動翻訳)
115200のボーレートとパリティなしまたはフロー制御（ハンドシェイク）を設定します。
次のコマンドを使用すると、UARTのVerilogコードを作成することができますRRR000et1CmhaBは、次にデザインを合成するためにあなたのsynthesizeツールを使用します。
\fi

\ifshowtranssecond %(校正 TODO)
115200のボーレートとパリティなしまたはフロー制御（ハンドシェイク）を設定します。
次のコマンドを使用すると、UARTのVerilogコードを作成することができますRRR000et1CmhaBは、
\fi

\begin{verbatim}
$ make uart
\end{verbatim}

\ifshoworiginal
Then use your synthesize tool to synthesize the design.
The repository contains a Quartus project for the DE2-115 FPGA board.
With Quartus use the play button to synthesize the design and then configure
the FPGA.
After configuration, you should see a greeting message in the terminal.
\fi


\ifshowtransfirst %(自動翻訳)
次にデザインを合成するためにあなたのsynthesizeツールを使用します。
リポジトリはDE2-115 FPGAボード用のQuartusのプロジェクトが含まれています。
Quartusでデザインを合成して、FPGAを設定するには、再生ボタンを使用します。
設定が完了したら、ターミナルでの挨拶のメッセージが表示されるはずです。
\fi

\ifshowtranssecond %(校正 TODO)
次にデザインを合成するためにあなたのsynthesizeツールを使用します。
リポジトリはDE2-115 FPGAボード用のQuartusのプロジェクトが含まれています。
Quartusでデザインを合成して、FPGAを設定するには、再生ボタンを使用します。
設定が完了したら、ターミナルでの挨拶のメッセージが表示されるはずです。
\fi

\ifshoworiginal
Extend the blinking LED example with a UART and write 0 and 1 to the serial
line when the LED is off and on. Use the \code{BufferedTx}, as in the \code{Sender}
example.
\fi

\ifshowtransfirst %(自動翻訳)
UARTで点滅LEDの例を拡張し、LEDがオフとオンのとき、シリアルラインに0と1を書き込みます。
\code{Sender}の例のように、\code{BufferedTx}を使用してください。
\fi

\ifshowtranssecond %(校正 TODO)
UARTで点滅LEDの例を拡張し、LEDがオフとオンのとき、シリアルラインに0と1を書き込みます。
\code{Sender}の例のように、\code{BufferedTx}を使用してください。
\fi

\ifshoworiginal
With the slow output of characters (two per second), you can write the data
to the UART transmit register and can ignore the read/valid handshake.
Extend the example by writing repeated numbers 0-9 as fast as the baud rate allows.
In this case, you have to extend your state machine to poll the UART status
to check if the transmit buffer is free.
\fi

\ifshowtransfirst %(自動翻訳)
文字の遅い出力（毎秒2）を使用すると、登録した送信UARTにデータを書き込むことができ、リード/有効なハンドシェイクを無視することができます。
繰り返し番号を書いて0-9として速いボーレートが許す限りでの例を拡張します。
このケースでは、送信バッファが自由であるかどうかを確認するためにUARTのステータスをポーリングするためにあなたのステートマシンを拡張する必要があります。
\fi

\ifshowtranssecond %(校正 TODO)
文字の遅い出力（毎秒2）を使用すると、登録した送信UARTにデータを書き込むことができ、リード/有効なハンドシェイクを無視することができます。
繰り返し番号を書いて0-9として速いボーレートが許す限りでの例を拡張します。
このケースでは、送信バッファが自由であるかどうかを確認するためにUARTのステータスをポーリングするためにあなたのステートマシンを拡張する必要があります。
\fi

\ifshoworiginal
The example code contains only a single buffer for the \code{Tx}. Feel free to
add the FIFO that you have implemented to add buffering to the transmitter
and receiver.
\fi

\ifshowtransfirst %(自動翻訳)
例のコードは\code{Tx}ための単一のバッファを含んでいます。
あなたは送信機と受信機にバッファリングを追加するために実装されていることをFIFOを追加すること自由に感じなさい。
\fi

\ifshowtranssecond %(校正 TODO)
例のコードは\code{Tx}ための単一のバッファを含んでいます。
あなたは送信機と受信機にバッファリングを追加するために実装されていることをFIFOを追加すること自由に感じなさい。
\fi

\ifshoworiginal
\subsection{FIFO Exploration}
\fi
\ifshowtransfirst %(自動翻訳)
\subsection{FIFO Exploration}
\fi
\ifshowtranssecond %(校正)
\subsection{FIFO探査 (L12296 TODO)}
\fi

\ifshoworiginal
Write a simple FIFO with 4 buffer elements in dedicated registers.
Use 2-bit read and write counters, which can just just overflow.
As a further simplification consider the situation when the read and write
pointers are equal as empty FIFO. This means you can maximally
store 3 elements. This simplification avoids the counter function from
the example in Listing~\ref{lst:fifo:reg:mem} and the handling
of the empty or full with the same pointer values. We do not need
empty or full flags, as this can be derived form the pointer values
alone. How much simpler is this design?
\fi

\ifshowtransfirst %(自動翻訳)
専用レジスタで4つのバッファ要素を有する単純なFIFOに書き込みます。
使用2ビットの読み取りと書き込みのカウンター、できるだけちょうどオーバーフローが。
さらに簡素化したよう読み取りと書き込みポインタが空のFIFOとして等しい状況を考えます。
これは、あなたが最大限に3つの要素を格納できることを意味します。
この単純化は、一覧〜\ref{lst:fifo:reg:mem}の例と同じポインタ値を持つ空またはフルの取り扱いからカウンタ機能を回避することができます。
これは単独のポインタ値から導出することができるよう私たちは、空またはフルフラグは必要ありません。
このデザインは、どのようにはるかに簡単ですか？
\fi

\ifshowtranssecond %(校正 TODO)
専用レジスタで4つのバッファ要素を有する単純なFIFOに書き込みます。
使用2ビットの読み取りと書き込みのカウンター、できるだけちょうどオーバーフローが。
さらに簡素化したよう読み取りと書き込みポインタが空のFIFOとして等しい状況を考えます。
これは、あなたが最大限に3つの要素を格納できることを意味します。
この単純化は、一覧〜\ref{lst:fifo:reg:mem}の例と同じポインタ値を持つ空またはフルの取り扱いからカウンタ機能を回避することができます。
これは単独のポインタ値から導出することができるよう私たちは、空またはフルフラグは必要ありません。
このデザインは、どのようにはるかに簡単ですか？
\fi


\ifshoworiginal
The presented different FIFO designs have different design tradeoffs
relative to following properties: (1) maximum throughput,
(2) fall through latency, (3) resource requirement, and (4)
maximum clock frequency. Explore all FIFO variations in different sizes by
synthesizing them for an FPGA; the source is available at
\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}.
Where are the sweet spots for FIFOs of 4 words, 16 words, and 256 words?
\fi

\ifshowtransfirst %(自動翻訳)
異なるFIFO設計は、以下の特性に対して異なる設計のトレードオフを持って提示：レイテンシを介して（1）最大スループット、（2）秋、（3）リソース要件、及び（4）最大クロック周波数。
FPGAのためにそれらを合成することによって、異なるサイズのすべてのFIFOのバリエーションを探検。ソースは\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}で入手可能です。
4つのワード、16ワード、および256ワードのFIFOのためのスイートスポットはどこですか？
\fi

\ifshowtranssecond %(校正 TODO)
異なるFIFO設計は、以下の特性に対して異なる設計のトレードオフを持って提示：レイテンシを介して（1）最大スループット、（2）秋、（3）リソース要件、及び（4）最大クロック周波数。
FPGAのためにそれらを合成することによって、異なるサイズのすべてのFIFOのバリエーションを探検。ソースは\myref{https://github.com/schoeberl/chisel-examples}{chisel-examples}で入手可能です。
4つのワード、16ワード、および256ワードのFIFOのためのスイートスポットはどこですか？
\fi

\ifshoworiginal
\chapter{Design of a Processor}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Design of a Processor}
\fi
\ifshowtranssecond %(校正)
\chapter{プロセッサの設計 (L12361 TODO)} %(校正  12章 ========================================================================)
\fi

\index{Processor}
\index{Leros}

\ifshoworiginal
As one of the last chapters in this book, we present a medium size project:
the design, simulation, and testing of a microprocessor.
To keep this project manageable, we design a simple accumulator machine.
The processor is called \myref{https://leros-dev.github.io/}{Leros}~\cite{leros:arcs2019}
and is available in open source at \url{https://github.com/leros-dev/leros}.
We would like to mention that this is an advanced example and some computer
architecture knowledge is needed to follow the presented code examples.
\fi

\ifshowtransfirst %(自動翻訳)
設計、シミュレーション、およびマイクロプロセッサのテスト：この本の最後の章の一つとして、我々は中規模のプロジェクトを提示します。
このプロジェクトの扱いを保つために、我々は、単純なアキュムレータマシンを設計します。
%プロセッサは\myref{https://leros-dev.github.io/}{Leros}〜\cite{leros:arcs2019}と呼ばれ、URL {HTTPS \で、オープンソースで提供されている：// githubの。
%COM /レロス-devの/レロス}。
これは高度な例であり、いくつかのコンピュータアーキテクチャの知識が提示コード例に従うことが必要であることに言及したいと思います。
\fi

\ifshowtranssecond %(校正 TODO)
設計、シミュレーション、およびマイクロプロセッサのテスト：この本の最後の章の一つとして、我々は中規模のプロジェクトを提示します。
このプロジェクトの扱いを保つために、我々は、単純なアキュムレータマシンを設計します。
%プロセッサは\myref{https://leros-dev.github.io/}{Leros}〜\cite{leros:arcs2019}と呼ばれ、URL {HTTPS \で、オープンソースで提供されている：// githubの。
%COM /レロス-devの/レロス}。
これは高度な例であり、いくつかのコンピュータアーキテクチャの知識が提示コード例に従うことが必要であることに言及したいと思います。
\fi


\ifshoworiginal
Leros is designed to be simple, but still a good target for a C compiler.
The description of the instructions fits on one page, see Table~\ref{tab:leros:isa}.
In that table \code{A} represents the accumulator, \code{PC} is the program counter,
\code{i} is an immediate value (0 to 255), \code{Rn} a register
\code{n} (0 to 255), \code{o} a branch offset relative to the \code{PC},
and \code{AR} an address register for memory access.
\fi

\ifshowtransfirst %(自動翻訳)
レロスはシンプルに設計されたが、それでもCコンパイラのための良好な標的されます。
1ページの指示フィットの説明は、表〜\ref{tab:leros:isa}を参照してください。
そのテーブルの\code{A}アキュムレータを表し、\code{PC}はプログラムカウンタであり、\code{i}が（0〜255）即値であり、\code{Rn}レジスタRRR011tYQBO6l0（0〜255）、RRR011NpcY2k6W分岐はRRR011RQtG1BaSに対してオフセット、及びRRR011jfje2hSnのアドレスレジスタメモリアクセス。
\fi

\ifshowtranssecond %(校正 TODO)
レロスはシンプルに設計されたが、それでもCコンパイラのための良好な標的されます。
1ページの指示フィットの説明は、表〜\ref{tab:leros:isa}を参照してください。
そのテーブルの\code{A}アキュムレータを表し、\code{PC}はプログラムカウンタであり、\code{i}が（0〜255）即値であり、\code{Rn}レジスタRRR011tYQBO6l0（0〜255）、RRR011NpcY2k6W分岐はRRR011RQtG1BaSに対してオフセット、及びRRR011jfje2hSnのアドレスレジスタメモリアクセス。
\fi


\begin{table}
\centering
\begin{tabular}{lll}
\toprule
Opcode & Function & Description\\
\midrule
add & A = A + Rn & Add register Rn to A \\
addi & A = A + i & Add immediate value i to A \\
sub & A = A - Rn & Subtract register Rn from A \\
subi & A = A - i & Subtract immediate value i from A \\
shr & A = A $>>>$ 1 & Shift A logically right \\
load & A = Rn & Load register Rn into A \\
loadi & A = i & Load immediate value i into A \\
and & A = A and Rn & And register Rn with A \\
andi & A = A and i & And immediate value i with A \\
or & A = A or Rn & Or register Rn with A \\
ori & A = A or i & Or immediate value i with A \\
xor & A = A xor Rn & Xor register Rn with A \\
xori & A = A xor i & Xor immediate value i with A \\
loadhi & A$_{15-8}$ = i & Load immediate into second byte \\
loadh2i & A$_{23-16}$ = i  & Load immediate into third byte \\
loadh3i & A$_{31-24}$ = i & Load immediate into fourth byte \\
store & Rn = A & Store A into register Rn \\
jal & PC = A, Rn = PC + 2 & Jump to A and store return address in Rn \\
ldaddr & AR = A & Load address register AR with A \\
loadind & A = mem[AR+(i $<<$ 2)] & Load a word from memory into A \\
loadindbu & A = mem[AR+i]$_{7-0}$  &  Load a byte unsigned from memory into A\\
storeind & mem[AR+(i $<<$ 2)] = A & Store A into memory \\
storeindb & mem[AR+i]$_{7-0}$ = A & Store a byte into memory \\
br & PC = PC + o & Branch \\
brz & if A == 0 PC = PC + o & Branch if A is zero \\
brnz & if A != 0 PC = PC + o  & Branch if A is not zero \\
brp & if A $>=$ 0 PC = PC + o & Branch if A is positive \\
brn & if A $<$ 0 PC = PC + o & Branch if A is negative \\
scall & scall A & System call (simulation hook) \\
\bottomrule
\end{tabular}
\caption{Leros instruction set.}
\label{tab:leros:isa}
\end{table}

\ifshoworiginal
\section{Start with an ALU}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Start with an ALU}
\fi
\ifshowtranssecond %(校正)
\section{ALUから始める (L12464 TODO)}
\fi

\index{ALU}
\index{Processor!ALU}

\ifshoworiginal
A central component of a processor is the
\myref{https://en.wikipedia.org/wiki/Arithmetic_logic_unit}{arithmetic logic unit}, or ALU for short.
Therefore, we start with the coding of the ALU and a test bench.
First, we define an \code{Enum} to represent the different operations of the ALU:
\fi

\ifshowtransfirst %(自動翻訳)
プロセッサの中心的なコンポーネントは短いため\myref{https://en.wikipedia.org/wiki/Arithmetic_logic_unit}{arithmetic logic unit}、またはALUです。
したがって、我々は、ALUとテストベンチのコーディングを始めます。
まず、ALUの異なる操作を表現するために\code{Enum}を定義します。
\fi

\ifshowtranssecond %(校正 TODO)
プロセッサの中心的なコンポーネントは短いため\myref{https://en.wikipedia.org/wiki/Arithmetic_logic_unit}{arithmetic logic unit}、またはALUです。
したがって、我々は、ALUとテストベンチのコーディングを始めます。
まず、ALUの異なる操作を表現するために\code{Enum}を定義します。
\fi

\shortlist{code/leros_types.txt}

\ifshoworiginal
\noindent An ALU usually has two operand inputs (call them \code{a} and \code{b}), an operation \code{op}
(or opcode) input to select the function and an output \code{y}.
Listing~\ref{lst:leros-alu} shows the ALU.
\fi

\ifshowtransfirst %(自動翻訳)
AN ALUは、通常、2つのオペランド入力（それら\code{a}と\code{b}を呼び出す）、操作\code{op}（オペコード）機能と出力\code{y}を選択する入力を有します。
一覧〜\ref{lst:leros-alu}は、ALUを示しています。
\fi

\ifshowtranssecond %(校正 TODO)
AN ALUは、通常、2つのオペランド入力（それら\code{a}と\code{b}を呼び出す）、操作\code{op}（オペコード）機能と出力\code{y}を選択する入力を有します。
一覧〜\ref{lst:leros-alu}は、ALUを示しています。
\fi


\todo{draw a nice ALU, see Wikipedia}

\ifshoworiginal
We first define shorter names for the three inputs. The \code{switch} statement defines the
logic for the computation of \code{res}. Therefore, it gets a default assignment of 0.
The switch statement enumerates all operations and assigns the expression accordingly.
All operations map directly to a Chisel expression.
In the end, we assign the result \code{res} to the ALU output \code{y}
\fi

\ifshowtransfirst %(自動翻訳)
私たちは、最初の三つの入力のための短い名前を定義します。
\code{switch}文は\code{res}の計算のためのロジックを定義します。
したがって、0のデフォルトの割り当てを取得します。
switch文は、すべての操作を列挙し、それに応じて表現を割り当てます。
すべての操作は、リグ式に直接マッピングされています。
最後に、我々は、ALUの出力\code{y}に結果\code{res}を割り当てます
\fi

\ifshowtranssecond %(校正 TODO)
私たちは、最初の三つの入力のための短い名前を定義します。
\code{switch}文は\code{res}の計算のためのロジックを定義します。
したがって、0のデフォルトの割り当てを取得します。
switch文は、すべての操作を列挙し、それに応じて表現を割り当てます。
すべての操作は、リグ式に直接マッピングされています。
最後に、我々は、ALUの出力\code{y}に結果\code{res}を割り当てます
\fi

\longlist{code/leros_alu.txt}{The Leros ALU.}{lst:leros-alu}

\ifshoworiginal
For the testing, we write the ALU function in plain Scala, as shown in Listing~\ref{lst:leros-alu-scala}.
\fi

\ifshowtransfirst %(自動翻訳)
一覧〜\ref{lst:leros-alu-scala}に示すように、テストのために、私たちは、平野ScalaでALU関数を記述します。
\fi

\ifshowtranssecond %(校正 TODO)
一覧〜\ref{lst:leros-alu-scala}に示すように、テストのために、私たちは、平野ScalaでALU関数を記述します。
\fi

\longlist{code/leros_alu_ref.txt}{The Leros ALU function written in Scala.}{lst:leros-alu-scala}

\ifshoworiginal
\noindent While this duplication of hardware written in Chisel by a Scala implementation does not
detect errors in the specification; it is at least some sanity check.
We use some corner case values as the test vector:
\fi

\ifshowtransfirst %(自動翻訳)
Scalaの実装によってChiselに書き込まれたハードウェアのこの重複は指定のエラーを検出しませんが、それは、少なくともいくつかの健全性チェックです。
私たちは、テストベクトルとして、いくつかのコーナーケース値を使用します。
\fi

\ifshowtranssecond %(校正 TODO)
Scalaの実装によってChiselに書き込まれたハードウェアのこの重複は指定のエラーを検出しませんが、それは、少なくともいくつかの健全性チェックです。
私たちは、テストベクトルとして、いくつかのコーナーケース値を使用します。
\fi

\shortlist{code/leros_alu_testvec.txt}

\ifshoworiginal
\noindent We test all functions with those values on both inputs:
\fi

\ifshowtransfirst %(自動翻訳)
我々は両方の入力にこれらの値を持つすべての機能をテストします。
\fi

\ifshowtranssecond %(校正 TODO)
我々は両方の入力にこれらの値を持つすべての機能をテストします。
\fi

\shortlist{code/leros_alu_test.txt}

\ifshoworiginal
\noindent Full, exhaustive testing for 32-bit arguments is not possible, which was the reason we
selected some corner cases as input values. Beside testing against corner cases, it is also useful
to test against random inputs:
\fi

\ifshowtransfirst %(自動翻訳)
32ビットの引数の完全な、徹底的なテストは、我々は、入力値として、いくつかのコーナーケースを選択した理由があった、ことはできません。
コーナーケースに対してテストのほかに、それはランダムな入力に対してもテストに便利です。
\fi

\ifshowtranssecond %(校正 TODO)
32ビットの引数の完全な、徹底的なテストは、我々は、入力値として、いくつかのコーナーケースを選択した理由があった、ことはできません。
コーナーケースに対してテストのほかに、それはランダムな入力に対してもテストに便利です。
\fi

\shortlist{code/leros_alu_rand.txt}

\ifshoworiginal
\noindent You can run the tests within the Leros project with
\fi

\ifshowtransfirst %(自動翻訳)
あなたがレロスのプロジェクト内でテストを実行することができます
\fi

\ifshowtranssecond %(校正 TODO)
あなたがレロスのプロジェクト内でテストを実行することができます
\fi

\begin{verbatim}
$ sbt "test:runMain leros.AluTester"
\end{verbatim}

\ifshoworiginal
and shall produce a success message similar to:
\fi

\ifshowtransfirst %(自動翻訳)
とに似て成功メッセージを作成しなければなりません。
\fi

\ifshowtranssecond %(校正 TODO)
とに似て成功メッセージを作成しなければなりません。
\fi

\begin{verbatim}
[info] [0.001] SEED 1544507337402
test Alu Success: 70567 tests passed in 70572 cycles taking
3.845715 seconds
[info] [3.825] RAN 70567 CYCLES PASSED
\end{verbatim}

\ifshoworiginal
\section{Decoding Instructions}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Decoding Instructions}
\fi
\ifshowtranssecond %(校正)
\section{命令のデコード (L12644 TODO)}
\fi

\index{Processor!instruction decode}

\ifshoworiginal
From the ALU, we work backward and implement the instruction decoder.
However, first, we define the instruction encoding in its own Scala class and
a \emph{shared} package. We want to share the encoding constants between
the hardware implementation of Leros, an assembler for Leros, and an instruction
set simulator of Leros.
\fi

\ifshowtransfirst %(自動翻訳)
ALUから、我々は後方に働くと命令デコーダを実装しています。
しかし、最初に、我々は独自のScalaのクラスの命令エンコーディングと\emph{shared}パッケージを定義します。
私たちは、レロス、レロスのためのアセンブラのハードウェア実装、およびレロスの命令セットシミュレータ間のエンコード定数を共有したいです。
\fi

\ifshowtranssecond %(校正 TODO)
ALUから、我々は後方に働くと命令デコーダを実装しています。
しかし、最初に、我々は独自のScalaのクラスの命令エンコーディングと\emph{shared}パッケージを定義します。
私たちは、レロス、レロスのためのアセンブラのハードウェア実装、およびレロスの命令セットシミュレータ間のエンコード定数を共有したいです。
\fi

\shortlist{code/leros_constants.txt}

\todo{Update code when Leros is more complete, as stuff is missing.}


\ifshoworiginal
\noindent For the decode component, we define a \code{Bundle} for the output,
which is later fed partially into the ALU.
\fi

\ifshowtransfirst %(自動翻訳)
デコード成分のため、我々は、後でALUに部分的に供給される出力用\code{Bundle}を定義します。
\fi

\ifshowtranssecond %(校正 TODO)
デコード成分のため、我々は、後でALUに部分的に供給される出力用\code{Bundle}を定義します。
\fi

\shortlist{code/leros_decode_bundle.txt}

\ifshoworiginal
\noindent Decode takes as input an 8-bit opcode and delivers the decoded signals
as output. Those driving signals are assigned a default value with \code{WireDefault}.
\fi

\ifshowtransfirst %(自動翻訳)
デコードは、入力として、8ビットのオペコードを受け取り、出力として復号信号を送出します。
これらの駆動信号は\code{WireDefault}と、デフォルト値が割り当てられています。
\fi

\ifshowtranssecond %(校正 TODO)
デコードは、入力として、8ビットのオペコードを受け取り、出力として復号信号を送出します。
これらの駆動信号は\code{WireDefault}と、デフォルト値が割り当てられています。
\fi

\shortlist{code/leros_decode_init.txt}

\ifshoworiginal
\noindent The decoding itself is just a large switch statement on the part of the
instruction that represents the opcode (in Leros for most instructions the upper
8 bits.)
\fi

\ifshowtransfirst %(自動翻訳)
デコーディング自体はほとんどの命令上位8ビット用のレロスにオペコードを（表し命令の一部にだけ大きなスイッチ文です。）
\fi

\ifshowtranssecond %(校正 TODO)
デコーディング自体はほとんどの命令上位8ビット用のレロスにオペコードを（表し命令の一部にだけ大きなスイッチ文です。）
\fi

\shortlist{code/leros_decode.txt}

\ifshoworiginal
\section{Assembling Instructions}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Assembling Instructions}
\fi
\ifshowtranssecond %(校正)
\section{アセンブラ命令 (L12729 TODO)}
\fi

\index{Assembler}

\ifshoworiginal
To write programs for Leros we need an assembler. However, for the very first
test, we can hard code a few instructions, and put them into a Scala array,
which we use to initialize the instruction memory.
\fi

\ifshowtransfirst %(自動翻訳)
レロスの書き込みプログラムに、私たちは、アセンブラが必要です。
しかし、非常に最初のテストのために、我々はハードコード数命令することができ、私たちは命令メモリを初期化するために使用Scalaの配列、にそれらを置きます。
\fi

\ifshowtranssecond %(校正 TODO)
レロスの書き込みプログラムに、私たちは、アセンブラが必要です。
しかし、非常に最初のテストのために、我々はハードコード数命令することができ、私たちは命令メモリを初期化するために使用Scalaの配列、にそれらを置きます。
\fi

\shortlist{code/leros_asm_hard.txt}

\ifshoworiginal
\noindent However, this is a very inefficient approach to test a processor.
Writing an assembler with an expressive language like Scala is not a big project.
Therefore, we write a simple assembler for Leros, which is possible within about
100 lines of code. We define a function \code{getProgram} that calls the assembler.
For branch destinations, we need a symbol table, which we collect in a \code{Map}.
A classic assembler runs in two passes: (1) collect the values for the symbol table
and (2) assemble the program with the symbols collected in the first pass.
Therefore, we call \code{assemble} twice with a parameter to indicate which pass it is.
\fi

\ifshowtransfirst %(自動翻訳)
しかし、これは、プロセッサをテストするための非常に非効率的なアプローチです。
Scalaのような表情豊かな言語とアセンブラを書くことは、大きなプロジェクトではありません。
したがって、我々は、コードの約100ライン内で可能であるレロスのための簡単なアセンブラを書きます。
私たちは、アセンブラを呼び出す関数の\code{getProgram}を定義します。
分岐先のために、我々は我々が\code{Map}に収集シンボルテーブルを、必要とします。
2回のパスで古典アセンブラ実行：（1）シンボルテーブルの値を収集し、（2）最初のパスに収集記号でプログラムを組み立てます。
したがって、我々はそれがある渡すかを示すためにパラメータで二回\code{assemble}を呼び出します。
\fi

\ifshowtranssecond %(校正 TODO)
しかし、これは、プロセッサをテストするための非常に非効率的なアプローチです。
Scalaのような表情豊かな言語とアセンブラを書くことは、大きなプロジェクトではありません。
したがって、我々は、コードの約100ライン内で可能であるレロスのための簡単なアセンブラを書きます。
私たちは、アセンブラを呼び出す関数の\code{getProgram}を定義します。
分岐先のために、我々は我々が\code{Map}に収集シンボルテーブルを、必要とします。
2回のパスで古典アセンブラ実行：（1）シンボルテーブルの値を収集し、（2）最初のパスに収集記号でプログラムを組み立てます。
したがって、我々はそれがある渡すかを示すためにパラメータで二回\code{assemble}を呼び出します。
\fi

\shortlist{code/leros_asm_call.txt}

\ifshoworiginal
The \code{assemble} function starts with reading in the source
file\footnote{This function does not actually read the source file, but for this
discussion we can consider it as the reading function.}
and defining two helper functions to parse the two possible operands: (1) an
integer constant (allowing decimal or hexadecimal notation) and (2) to read
a register number.
\fi

\ifshowtransfirst %(自動翻訳)
\code{assemble}機能は、ソースファイル
\footnote{この関数は、実際にソースファイルを読み取ることはありませんが、この議論のために、我々は読み取り機能としてそれを考えることができるで読んで始まります。}
と二つの可能なオペランド解析するために2つのヘルパー関数を定義する：レジスタ番号を読み取るために（1）〜（10進数または16進数表記を可能にする）整数定数及び（2）。
\fi

\ifshowtranssecond %(校正 TODO)
\code{assemble}機能は、ソースファイル
\footnote{この関数は、実際にソースファイルを読み取ることはありませんが、この議論のために、我々は読み取り機能としてそれを考えることができるで読んで始まります。}
と二つの可能なオペランド解析するために2つのヘルパー関数を定義する：レジスタ番号を読み取るために（1）〜（10進数または16進数表記を可能にする）整数定数及び（2）。
\fi

\shortlist{code/leros_asm_start.txt}

\ifshoworiginal
Listing~\ref{lst:leros-asm-match} shows the core of the assembler for Leros.
A Scala \code{match} expression covers the core of the assembly function.
\todo{Some more words on the code.}
\fi

\ifshowtransfirst %(自動翻訳)
リスト〜\ref{lst:leros-asm-match}はレロスのためのアセンブラのコアを示しています。
スカラ\code{match}発現は、アセンブリ機能のコアを覆っています
\fi

\ifshowtranssecond %(校正 TODO)
リスト〜\ref{lst:leros-asm-match}はレロスのためのアセンブラのコアを示しています。
スカラ\code{match}発現は、アセンブリ機能のコアを覆っています
\fi

\longlist{code/leros_asm_match.txt}{The main part of the Leros assembler.}{lst:leros-asm-match}

\ifshoworiginal
\section{Exercise}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Exercise}
\fi
\ifshowtranssecond %(校正)
\section{演習 (L12833 TODO)}
\fi

\ifshoworiginal
This exercise assignment in one of the last Chapters is in a very free form. You are at the end
of your learning tour through Chisel and ready to tackle design problems that
you find interesting.
\fi

\ifshowtransfirst %(自動翻訳)
最後の章のいずれかで、この演習の割り当ては非常に自由な形です。
あなたはChiselを通して、あなたの学習ツアーの最後に、あなたが面白いことを設計上の問題に取り組む準備ができています。
\fi
\ifshowtranssecond %(校正 TODO)
最後の章のいずれかで、この演習の割り当ては非常に自由な形です。
あなたはChiselを通して、あなたの学習ツアーの最後に、あなたが面白いことを設計上の問題に取り組む準備ができています。
\fi

\ifshoworiginal
One option is to reread the chapter and read along with all the source code in the
\myref{https://github.com/leros-dev/leros}{Leros repository}, run the test cases,
fiddle with the code by breaking it and see that tests fail.
\fi

\ifshowtransfirst %(自動翻訳)
1つのオプションは、章を再読し、\myref{https://github.com/leros-dev/leros}{Leros repository}内のすべてのソースコードと一緒に読んで、テストケースを実行し、それを破壊することにより、コードとフィドルとテストが失敗することを確認することです。
\fi
\ifshowtranssecond %(校正 TODO)
1つのオプションは、章を再読し、\myref{https://github.com/leros-dev/leros}{Leros repository}内のすべてのソースコードと一緒に読んで、テストケースを実行し、それを破壊することにより、コードとフィドルとテストが失敗することを確認することです。
\fi

\ifshoworiginal
Another option is to write your implementation of Leros.
The implementation in the repository is just one possible organization of a pipeline.
You could write a Chisel simulation version of Leros with just a single pipeline stage,
or go creasy and superpipeline Leros for the highest possible clocking frequency.
\fi

\ifshowtransfirst %(自動翻訳)
別のオプションは、レロスの実装を記述することです。
リポジトリ内の実装は、パイプラインのひとつの可能な組織です。
あなただけの単一のパイプラインステージでレロスのChiselシミュレーションバージョンを書き込み、またはcreasyを行くと可能な限り最高のクロック周波数のためレロスをスーパーパイプがあります。
\fi

\ifshowtranssecond %(校正 TODO)
別のオプションは、レロスの実装を記述することです。
リポジトリ内の実装は、パイプラインのひとつの可能な組織です。
あなただけの単一のパイプラインステージでレロスのChiselシミュレーションバージョンを書き込み、またはcreasyを行くと可能な限り最高のクロック周波数のためレロスをスーパーパイプがあります。
\fi

\ifshoworiginal
A third option is to design your processor from scratch. Maybe the demonstration of
how to build the Leros processor and the needed tools has convinced you that processor
design and implementation is no magic art, but the engineering that can be very joyful.
\fi

\ifshowtransfirst %(自動翻訳)
第三の選択肢は最初からあなたのプロセッサを設計することです。
たぶんレロスプロセッサを構築する方法のデモンストレーションや必要なツールは、プロセッサの設計と実装は魔法アートが、非常に楽しいことができエンジニアリングではないことを確信しています。
\fi
\ifshowtranssecond %(校正 TODO)
第三の選択肢は最初からあなたのプロセッサを設計することです。
たぶんレロスプロセッサを構築する方法のデモンストレーションや必要なツールは、プロセッサの設計と実装は魔法アートが、非常に楽しいことができエンジニアリングではないことを確信しています。
\fi

\ifshoworiginal
\chapter{Contributing to Chisel}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Contributing to Chisel}
\fi
\ifshowtranssecond %(校正)
\chapter{Chisel への貢献 (L12905 mune10 初回校正済) }%(校正 7/24 mune10 13章初回終了 =======================================================)
\fi

\index{Chisel!Contribution}

\ifshoworiginal
Chisel is an open-source project under constant development and improvement.
Therefore, you can also contribute to the project. Here we describe how to
set up your environment for Chisel library development and how to contribute
to Chisel.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselは、一定の開発・改良の下でオープンソースプロジェクトです。
そのため、あなたはまた、プロジェクトに貢献することができます。
ここでは、Chiselライブラリの開発とどのようにChiselに貢献するための環境をセットアップする方法について説明します。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
Chiselは、絶えまない開発と改良のもとにあるオープンソースプロジェクトです。
そのため、あなたもプロジェクトに貢献することができます。
ここでは、Chiselのライブラリの開発のための開発環境のセットアップと、Chiselへの貢献方法について説明します。
\fi

\ifshoworiginal
\section{Setup the Development Environment}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Setup the Development Environment}
\fi
\ifshowtranssecond %(校正)
\section{開発環境の設定}
\fi

\ifshoworiginal
Chisel consists of several different repositories; all hosted at
the \myref{https://github.com/freechipsproject}{freechips organization at GitHub}.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselは、いくつかの異なるリポジトリで構成されています。すべて\myref{https://github.com/freechipsproject}{freechips organization at GitHub}でホストされています。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
Chiselは、いくつかの異なるリポジトリで構成されています。
そのすべては \myref{https://github.com/freechipsproject}{GitHub上の freechips オーガナイゼーション } でホストされています。
\fi

\ifshoworiginal
Fork the repository, which you like to contribute, into your personal GitHub account.
You can fork the repository by pressing the \code{Fork} button in the GitHub web interface.
Then from that fork, clone your fork of the repository.\footnote{Note that on a breaking
firrt/Chisel change you might need to also fork and clone firrtl}.
In our example, we change \code{chisel3}, and the clone command for my local fork is:
\fi

\ifshowtransfirst %(自動翻訳)
あなたの個人GitHubのアカウントに、貢献したいリポジトリをフォーク。
あなたはGitHubのWebインターフェイスで\code{Fork}ボタンを押すことで、リポジトリをフォークすることができます。
そして、そのフォークから、リポジトリのあなたのフォークのクローンを作成します。
\footnote{壊す最初/Chisel変化にあなたにもフォークとクローンfirrtlする必要があることに注意してください}
この例では、\code{chisel3}を変更し、私の地元のフォークのためのクローンコマンドは次のとおりです。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
あなたの個人GitHubのアカウントに、貢献したいリポジトリをフォークします。
具体的には、GitHubのWebインターフェイスで\code{Fork}ボタンを押すことで、リポジトリをフォークすることができます。
そして、そのフォークしたリポジトリをクローンします。
\footnote{Chiselとfirrtlに変更を加える場合は、firrtlについてもフォークとクローンが必要があることに注意してください}
この例では、\code{chisel3}を変更し、私のローカルのフォークをクローンするコマンドは次のとおりです。
\fi

\begin{verbatim}
$ git clone git@github.com:schoeberl/chisel3.git
\end{verbatim}

\ifshoworiginal
To compile Chisel 3 and publish as a local library execute:
\fi

\ifshowtransfirst %(自動翻訳)
ローカルライブラリとしてChisel3をコンパイルし、公開するには、実行します。RRR000fQQkcd5fを
\fi

\ifshowtranssecond %(校正 7/23 mune10)
Chisel3をコンパイルし、ローカルライブラリとして公開するには、以下を実行します。
\fi

\begin{verbatim}
$ cd chisel3
$ sbt compile
$ sbt publishLocal
\end{verbatim}

\ifshoworiginal
Watch out during the publish local command for the version string of the published
library, which contains the string \code{SNAPSHOT}.
If you use the tester and the published version is not compatible with the Chisel
SNAPSHOT, fork and clone the \myref{https://github.com/freechipsproject/chisel-testers}{chisel-tester}
repo as well and publish it locally.
\fi

\ifshowtransfirst %(自動翻訳)
文字列\code{SNAPSHOT}が含まれて出版され、ライブラリのバージョン文字列のためのローカルコマンドを発行する時に気をつけてください。
あなたはテスターと公開バージョンはChiselSNAPSHOTと互換性がありません、フォークとクローンを使用する場合\myref{https://github.com/freechipsproject/chisel-testers}{chisel-tester}も同様にレポし、ローカルに公開します。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
パブリッシュしたライブラリのバージョン文字列について、パブリッシュローカルコマンドの実行の際に気をつけてください。
文字列\code{SNAPSHOT}が含まれてパブリッシュされます。
もしあなたがテスターを用いる際に、パブリッシュしたバージョンが、Chisel の SNAPSHOTと互換性がない場合、
\myref{https://github.com/freechipsproject/chisel-testers}{chisel-tester}についても同様にフォークとクローンして、ローカルでパブリッシュしてください。
\fi

\ifshoworiginal
To test your changes in Chisel, you probably also want to set up a Chisel project,
e.g., by forking/cloning an \myref{https://github.com/schoeberl/chisel-empty}{empty Chisel project},
renaming it, and removing the \code{.git} folder from it.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselで変更をテストするには、おそらくまた、電子を掘削プロジェクトを設定します。
グラム。
、名前を変更、\myref{https://github.com/schoeberl/chisel-empty}{empty Chisel project}をクローニング/フォーク、およびそこから\code{.git}フォルダを除去することによって。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
Chiselでの変更をテストするには、おそらく、Chiselプロジェクトを作成する必要がります。
例えば、\myref{https://github.com/schoeberl/chisel-empty}{empty Chisel project}をクローニング/フォークして名前を変更します。
そこから\code{.git}フォルダは削除しておきます。
\fi

\ifshoworiginal
Change the \code{build.sbt} to reference the locally published version of Chisel.
Furthermore, at the time of this writing, the head of Chisel source uses Scala 2.12, but Scala
2.12 has troubles with
\myref{https://github.com/freechipsproject/chisel-template/issues/35}{anonymous bundles}.
Therefore, you need to add the following Scala option: \code{"-Xsource:2.11"}.
The \code{build.sbt} should look similar to:
\fi

\ifshowtransfirst %(自動翻訳)
Chiselのローカルに発行されたバージョンを参照するように\code{build.sbt}を変更します。
さらに、この記事の執筆時点では、Chisel元のヘッドは、Scalaの2を使用しています。
12、しかし、スカラ2。
12は\myref{https://github.com/freechipsproject/chisel-template/issues/35}{anonymous bundles}とのトラブルを持っています。
\code{"-Xsource:2.11"}：そのためには、次のScalaのオプションを追加する必要があります。
\code{build.sbt}はのようになります。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
ローカルにパブリッシュされたバージョンの Chisel を参照するように\code{build.sbt}を変更します。
さらに、この記事の執筆時点では、Chisel元のヘッドは、Scala の 2.12 を使用しています。
しかし、Scala 2.12 は問題\myref{https://github.com/freechipsproject/chisel-template/issues/35}{anonymous bundles}があります。
その回避のために、、次のScalaのオプション、\code{"-Xsource:2.11"} を追加する必要があります。
\code{build.sbt}は次のようになります。
\fi

\begin{verbatim}
scalaVersion := "2.12.6"

scalacOptions := Seq("-Xsource:2.11")

resolvers ++= Seq(
  Resolver.sonatypeRepo("snapshots"),
  Resolver.sonatypeRepo("releases")
)

libraryDependencies +=
  "edu.berkeley.cs" %% "chisel3" % "3.2-SNAPSHOT"
libraryDependencies +=
  "edu.berkeley.cs" %% "chisel-iotesters" % "1.3-SNAPSHOT"
\end{verbatim}



\ifshoworiginal
Compile your Chisel test application and take a close look if it picks up the local published
version of the Chisel library (there is also a SNAPSHOT version published, so if, e.g.,
the Scala version is different between your Chisel library and your application code,
it picks up the SNAPSHOT version from the server instead of your local published
library.)
\fi

\ifshowtransfirst %(自動翻訳)
、もしそうであれば、電子をごChiselテストアプリケーションをコンパイルし、それがChiselライブラリのローカル公開バージョンを拾った場合に発行されSNAPSHOTバージョンもある（近い見てみましょう。
グラム。
、ScalaのバージョンがChiselライブラリとアプリケーションコードの間で異なっている、それは代わりに、あなたの地元の公表ライブラリのサーバからのスナップショットのバージョンをピックアップ。
）
\fi

\ifshowtranssecond %(校正 7/23 mune10)
Chiselのテストアプリケーションをコンパイルして、
それがChiselライブラリのローカルパブリッシュバージョンを使っているか注意する。
（例えば、アプリケーションコードとChiselライブラリのScalaのバージョンが異なっている場合、
ローカルパブリッシュバージョンではなく、サーバからのSNAPSHOTバージョンを選択している。）
\fi

\ifshoworiginal
See also \myref{https://github.com/freechipsproject/chisel3}{some notes at the Chisel repo}.
\fi

\ifshowtransfirst %(自動翻訳)
また\myref{https://github.com/freechipsproject/chisel3}{some notes at the Chisel repo}を参照してください。
\fi
\ifshowtranssecond %(校正 7/23 mune10)
\myref{https://github.com/freechipsproject/chisel3}{some notes at the Chisel repo}も参照しておいてください。
\fi

\ifshoworiginal
\section{Testing}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Testing}
\fi
\ifshowtranssecond %(校正)
\section{テスト}
\fi

\ifshoworiginal
When you change the Chisel library, you should run the Chisel tests.
In an \code{sbt} based project, this is usually run with:
\fi

\ifshowtransfirst %(自動翻訳)
あなたはChiselライブラリを変更するときは、リグのテストを実行する必要があります。
\code{sbt}ベースのプロジェクトでは、これは通常で実行されます。
\fi
\ifshowtranssecond %(校正 7/23 mune10)
Chiselライブラリを変更する際は、Chiselのテストも実行する必要があります。
\code{sbt}ベースのプロジェクトでは、下記のように実行します。
\fi

\begin{verbatim}
$ sbt test
\end{verbatim}

\ifshoworiginal
Furthermore, if you add functionality to Chisel, you should also provide tests for the
new features.
\fi

\ifshowtransfirst %(自動翻訳)
あなたはChiselに機能を追加する場合はさらに、あなたはまた、新機能のテストを提供する必要があります。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
また、あなたはChiselに機能を追加する場合は、その新機能のテストを提供する必要があります。
\fi

\ifshoworiginal
\section{Contribute with a Pull Request}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Contribute with a Pull Request}
\fi
\ifshowtranssecond %(校正)
\section{プルリクエストで貢献する}
\fi

\ifshoworiginal
In the Chisel project, no developer commits directly to the main repository.
A contribution is organized via a
\myref{https://help.github.com/articles/creating-a-pull-request-from-a-fork/}{pull request}
from a branch in a forked version of the library.
For further information, see the documentation at GitHub on
\myref{https://help.github.com/categories/collaborating-with-issues-and-pull-requests/}{collaboration with pull requests}.
The Chisel group started to document
\myref{https://github.com/freechipsproject/chisel-lang-governance/blob/master/reviewer_guidelines.md}{contribution guidelines}.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselプロジェクトでは、何の開発者がメインリポジトリに直接コミットしていません。
寄与は、ライブラリのフォーク版の枝から\myref{https://help.github.com/articles/creating-a-pull-request-from-a-fork/}{pull request}を経て編成されています。
詳細については、\myref{https://help.github.com/categories/collaborating-with-issues-and-pull-requests/}{collaboration with pull requests}上のGitHubのドキュメントを参照してください。
Chiselグループは\myref{https://github.com/freechipsproject/chisel-lang-governance/blob/master/reviewer_guidelines.md}{contribution guidelines}を文書化し始めました。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
Chiselプロジェクトでは、開発者はメインリポジトリに直接コミットできません。
貢献は、ライブラリのフォーク版の作業ブランチから\myref{https://help.github.com/articles/creating-a-pull-request-from-a-fork/}{pull request、プルリクエスト}で行います。
詳細については、GitHub上のドキュメント\myref{https://help.github.com/categories/collaborating-with-issues-and-pull-requests/}{collaboration with pull requests、プルリクエストによるコラボレーション}を参照してください。
Chiselのグループでも貢献方法について文書化 \myref{https://github.com/freechipsproject/chisel-lang-governance/blob/master/reviewer_guidelines.md}{contribution guidelines、貢献ガイドライン} を始めています。 
\fi

\ifshoworiginal
\section{Exercise}
\fi
\ifshowtransfirst %(自動翻訳)
\section{Exercise}
\fi
\ifshowtranssecond %(校正)
\section{演習}
\fi

\ifshoworiginal
Invent a new operator for the \code{UInt} type, implement it in the Chisel library,
and write some usage/test code to explore the operator. It does not need to be
a useful operator; just anything will be good, e.g., a ? operator that delivers the lefthand side
if it is different from 0 otherwise the righthand side. Sounds like a multiplexer, right?
How many lines of code did you need to add?\footnote{A quick and dirty implementation
needs just two lines of Scala code.}
\fi

\ifshowtransfirst %(自動翻訳)
\code{UInt}タイプのための新しい演算子を発明、Chiselライブラリにそれを実装し、オペレータを探索するためにいくつかの使用方法/テストコードを書きます。
これは、便利なオペレータである必要はありません。何でもいい、Eになります。
グラム。
、？それはそうでなければ0右側異なる場合左側を配信オペレータ。
%マルチプレクサのようなサウンド、右？コードの行数は、あなたが追加する必要がありましたか？\脚注は{間に合わせの実装は、Scalaのコードのわずか2行を必要とします。
%｝
\fi

\ifshowtranssecond %(校正 7/23 mune10)
\code{UInt}タイプの新しいオペレータ（演算子）を追加します。
Chiselライブラリに組み込み、オペレータの使用例として、いくつかの使用例とテストコードを作成します。
とりあえず、便利なオペレータである必要はありませんので、何でもよいです。
例えば ゼロでなければ左辺を、それ以外の場合は右辺を返す、マルチプレクサのような、「?」オペレータを考えます。
そのためには、そのくらいのコード行数が必要でしょうか？
\footnote{てっとりばやい実装では、2行ほどのScalaコードになります}
\fi

\ifshoworiginal
As simple as this was, please be not tempted to fork the Chisel project and
add your little extensions. Changes and extension shall be coordinated with the
main developers.
This exercise was just a simple exercise to get you started.
\fi

\ifshowtransfirst %(自動翻訳)
このような単純な、Chiselプロジェクトをフォークし、あなたの小さな拡張子を追加するように誘惑されていないしてくださいました。
変更点と拡張機能は、メインの開発者と調整されなければなりません。
この演習では、あなたが始めるために、単純な運動でした。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
ただし、このような感じで、些細なオペレータを追加するためにChiselプロジェクトをフォークしたりしないでください。
Chiselの変更や拡張は、メインの開発者（達）と相談の上すすめなくてはなりません。
この演習は、そうした活動を始めるにあたっての簡単な練習です。
\fi

\ifshoworiginal
If you are getting bold, you could pick one of the
\myref{https://github.com/freechipsproject/chisel3/issues}{open issues} and try to solve it.
Then contribute with a pull request to Chisel.
However, probably first watch the style of development in Chisel by watching the GitHub
repositories.
See how changes and pull requests are handled in the Chisel open-source project.
\fi

\ifshowtransfirst %(自動翻訳)
あなたが太字になっている場合は、\myref{https://github.com/freechipsproject/chisel3/issues}{open issues}のいずれかを選んで、それを解決しようとすることができます。
そして、Chiselにプル要求に貢献します。
しかし、おそらく最初のGitHubリポジトリを見てChiselでの開発のスタイルを見て。
Chiselのオープンソースプロジェクトでどのように扱われるかの変更とプル要求を参照してください。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
もしあなたが慣れてきたら、
\myref{https://github.com/freechipsproject/chisel3/issues}{open issues、未解決の課題}
のいずれかを選んで、その解決を試みるすることもできます。
そして、プルリクエストをChiselに送り、貢献します。
まず最初は、GitHubリポジトリでの Chiselの開発スタイルを見て
Chiselのオープンソースプロジェクト内で、その変更とプルリクエストがどのように扱われているかを見てみましょう。
\fi

\ifshoworiginal
\chapter{Summary}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Summary}
\fi
\ifshowtranssecond %(校正)
\chapter{まとめ (L12556 mune10 初回校正済)} %(校正 7/23 mune10 14章初回終了 ==========================================================))
\fi

\label{sec:conclusion}

\ifshoworiginal
This book presented an introduction to digital design using the
hardware construction language Chisel.
We have seen several simple to medium-sized digital circuits
described in Chisel.
Chisel is embedded in Scala and therefore inherits the powerful
abstraction of Scala.
As this book is intended as an introduction, we have restricted
our examples to simple uses of Scala.
A next logical step is to learn a few basics of Scala and apply them
to your Chisel project.
\fi

\ifshowtransfirst %(自動翻訳)
この本は、ハードウェア構成の言語Chiselを使用してデジタル設計への導入を発表しました。
私たちは、Chiselで説明した中型のデジタル回路にいくつかの簡単なを見てきました。
ChiselはScalaで埋め込まれたので、スカラ座の強力な抽象化を継承しています。
この本は導入として意図されているように、私たちはScalaの簡単な使い方に私たちの例を制限しています。
次の論理的なステップは、スカラ座のいくつかの基本を学び、あなたのChiselのプロジェクトに適用することです。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
この本は、ハードウェア構成の言語である Chisel を用いた デジタル回路設計の入門書です。
シンプルなものから中規模の Chiselで記述されたデジタル回路設計を見てきました。
ChiselはScalaベースのDSLですので、Scalaの強力な抽象化を継承しています。
この本は入門書として意図されているため、本書での記述は Scalaの簡単な使い方にとどめています。
次の論理的なステップは、Scalaの基本を学び、それをあなたのChiselのプロジェクトに適用してゆくことです。
\fi

\ifshoworiginal
I would be happy to receive feedback on the book, as I will further
improve it and will publish new editions. You can contact me at
\url{mailto:masca@dtu.dk}, or with an issue request on the GitHub
repository. I am also happily accepting pull requests
for the book repository for any fixes and improvements.
\fi

\ifshowtransfirst %(自動翻訳)
私はさらにそれを改善するように、本にフィードバックを受け取るために幸せになると新しい版を公開します。
リポジトリで私に連絡することができます。
また、私は喜んで任意の修正と改良のための本リポジトリのプル要求を受け入れています。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
本書のフィードバックをお寄せください、それは本書を改善し、次の版に反映されるでしょう。
私の連絡先は \url{mailto:masca@dtu.dk} です。
GitHub 上で Issue リクエスト を出していただいても構いません。
本書の修正や改善の関する Pull リクエストもお待ちしております。
（日本語版につきましては、Chisel勉強会のSlackまで \url{https://chisel-jp-slackin.herokuapp.com/}）
\fi

\section*{Source Access}

\ifshoworiginal
This book is available in open source.
The repository also contains slides for a Chisel course and
all Chisel examples: \url{https://github.com/schoeberl/chisel-book}
\fi

\ifshowtransfirst %(自動翻訳)
この本は、オープンソースで提供されています。
リポジトリはまた、ChiselコースとすべてのChisel例についてのスライドが含まれています：\ URL {https：//でgithubのを。
COM / schoeberl /Chiselブック}
\fi

\ifshowtranssecond %(校正 7/23 mune10)
本書はオープンソースで提供されています。
リポジトリには、ChiselコースとすべてのChiselのサンプルコードについてのスライドも含まれています：\url{https://github.com/schoeberl/chisel-book}
（日本語版は：\url{https://github.com/chisel-jp/chisel-book} の japanese ブランチを参照してください）
\fi

\ifshoworiginal
A collection of medium-sized examples, which most are referenced
in the book, is also available in open source. This collection
also contains projects for various popular FPGA boards:
\fi

\ifshowtransfirst %(自動翻訳)
ほとんどの本の中で参照されている中規模例のコレクションは、またオープンソースで提供されています。
このコレクションは、様々な人気のFPGAボードのためのプロジェクトが含まれています。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
本書の中でも参照している、中規模の実装例はオープンソースとして提供されています。
\url{https://github.com/schoeberl/chisel-examples} はこうした様々なFPGAをターゲットとしたプロジェクトを含む実装例です。
\fi

\appendix

%\chapter{Chisel Projects}
\chapter{Chiselを使っているプロジェクト一覧 (L12650 mune20 初回校正済)} %(校正 7/23 mune10 付録A 初回終了 ====================================))
\ifshoworiginal
\fi
\ifshowtransfirst %(自動翻訳)
\fi
\ifshowtranssecond %(校正)
\fi

\index{Chisel!Examples}

\ifshoworiginal
Chisel is not (yet) used in many projects. Therefore, open-source Chisel code
to learn the language and the coding style is rare. Here we list several projects
we are aware of that use Chisel and are in open source.
\fi

\ifshowtransfirst %(自動翻訳)
Chiselは、多くのプロジェクトで使用される（まだ）ありません。
そのため、言語やコーディングスタイルを学ぶためのオープンソースのChiselコードは稀です。
ここでは、我々はその使用Chiselを認識しており、オープンソースであるいくつかのプロジェクトを一覧表示します。
\fi
\ifshowtranssecond %(校正 7/23 mune10)
Chiselは（まだ）多くのプロジェクトで使用されているわけではありません。
そのため、言語やコーディングスタイルを学ぶためのオープンソースのChiselの実装コードはそんなにありません。
ここでは、私が把握している、オープンソースで公開されている Chiselを使ったプロジェクトを紹介します。
\fi

\begin{description}

\ifshoworiginal
\item[\myref{https://github.com/chipsalliance/rocket-chip}{Rocket Chip}]
is a \myref{https://en.wikipedia.org/wiki/RISC-V}{RISC-V}~\cite{risc-v}
processor-complex generator that comprises the Rocket
microarchitecture and TileLink interconnect generators.  Originally developed
at UC Berkeley as the first chip-scale Chisel project~\cite{rocket:techrep}, Rocket Chip is now
commercially supported by \myref{https://www.sifive.com/}{SiFive}.
%The codebase at SiFive serves as a major test bench for Chisel and new Chisel features
%need to pass the tests at SiFive.
\fi

\ifshowtransfirst %(自動翻訳)
\item[\myref{https://github.com/chipsalliance/rocket-chip}{Rocket Chip}]
ロケットマイクロアーキテクチャとTileLink配線発生器を含む\myref{https://en.wikipedia.org/wiki/RISC-V}{RISC-V}〜\cite{risc-v}プロセッサ複合発電機です。
もともと最初のチップスケールChiselプロジェクト〜\cite{rocket:techrep}としてカリフォルニア大学バークレー校で開発され、ロケットチップは現在、商業的に\myref{https://www.sifive.com/}{SiFive}によってサポートされています。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
\item[\myref{https://github.com/chipsalliance/rocket-chip}{Rocket Chip}]
はロケットマイクロアーキテクチャとTileLinkインターコネクト(バス)生成器を含む
\myref{https://en.wikipedia.org/wiki/RISC-V}{RISC-V}~\cite{risc-v}プロセッサシステムの生成器です。
もともと最初のチップスケール Chiselプロジェクト ~\cite{rocket:techrep} としてカリフォルニア大学バークレー校で開発されました。
現在、ロケットチップは\myref{https://www.sifive.com/}{SiFive}によって商業的にサポートされています。
\fi

\ifshoworiginal
\item[\myref{https://github.com/ucb-bar/riscv-sodor}{Sodor}] is a collection of RISC-V
implementations intended for educational use. It contains 1, 2, 3, and 5 stages pipeline
implementations. All processors use a simple scratchpad memory shared by instruction
fetch, data access, and program loading via a debug port. Sodor is mainly intended to
be used in simulation.
\fi

\ifshowtransfirst %(自動翻訳)
\item[\myref{https://github.com/ucb-bar/riscv-sodor}{Sodor}]
実装は、教育の使用を意図しました。
これは、1、2、3、及び5段パイプラインの実装を含んでいます。
すべてのプロセッサがデバッグポートを経由して、簡単な命令フェッチで共有スクラッチパッドメモリ、データアクセス、およびプログラムのロードを使用します。
ソドー島は主にシミュレーションで使用されることを意図しています。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
\item[\myref{https://github.com/ucb-bar/riscv-sodor}{Sodor}]
は教育目的での利用を意図したRISC-V実装です。
1、2、3、及び5段のパイプラインの実装を含んでいます。
すべてのプロセッサは、デバッグポートを介して、命令フェッチ、データアクセス、およびプログラムのロードがシンプルな共有スクラッチパッドメモリを使用します。
Sodorは主にシミュレーションで使用されることを意図しています。
\fi

\ifshoworiginal
\item[\myref{https://github.com/t-crest/patmos}{Patmos}] is an implementation of a
processor optimized for real-time systems~\cite{patmos:rts2018}. The Patmos repository
includes several multicore communication architectures, such as a time-predictable memory
arbiter~\cite{t-crest:memnoc}, a network-on-chip~\cite{s4nocni:arcs2019}
a shared scratchpad memory with an ownership~\cite{t-crest:ownspm}.
At the time of this writing, Patmos is still described in Chisel 2.
\fi

\ifshowtransfirst %(自動翻訳)
\item[\myref{https://github.com/t-crest/patmos}{Patmos}]
リアルタイムシステム〜\cite{patmos:rts2018}のために最適化されたプロセッサ。
パトモスリポジトリは、〜\cite{t-crest:memnoc}アービタ時間予測可能なメモリなどのいくつかのマルチコア通信アーキテクチャ、ネットワーク・オン・チップ〜\cite{s4nocni:arcs2019}所有〜\cite{t-crest:ownspm}と共有スクラッチパッドメモリを含みます。
この記事の執筆時点では、パトモスはまだChisel2に記載されています
\fi

\ifshowtranssecond %(校正 7/23 mune10)
\item[\myref{https://github.com/t-crest/patmos}{Patmos}]
はリアルタイムシステム~\cite{patmos:rts2018}向けに最適化されたプロセッサです。
Patmos のリポジトリにはいくつかのマルチコア通信アーキテクチャが含まれます。
時間予測可能なメモリアービタ ~\cite{t-crest:memnoc}、
ネットワーク・オン・チップ~\cite{s4nocni:arcs2019}、
オーナーシップ対応の共有スクラッチパッドメモリ ~\cite{t-crest:ownspm}、などを含みます。
この記事の執筆時点では、Patmos はまだChisel2 で記述されています
\fi

\ifshoworiginal
\item[\myref{https://github.com/pretis/flexpret}{FlexPRET}] is an implementation of a
precision timed architecture~\cite{Zimmer:EECS-2015-181}. FlexPRET implements
the RISC-V instruction set and has been updated to Chisel 3.1.
\fi

\ifshowtransfirst %(自動翻訳)
\item[\myref{https://github.com/pretis/flexpret}{FlexPRET}] 
精度はアーキテクチャ〜\cite{Zimmer:EECS-2015-181}をタイムアウトしました。
FlexPRETは、RISC-Vの命令セットを実装し、Chisel3に更新されました。
１。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
\item[\myref{https://github.com/pretis/flexpret}{FlexPRET}] 
は高時間精度アーキテクチャ~\cite{Zimmer:EECS-2015-181}の実装です。
FlexPRETは、RISC-Vの命令セットを実装し、Chisel3.1 に更新されました。
\fi

\ifshoworiginal
\item[\myref{https://github.com/schoeberl/lipsi}{Lipsi}] is a tiny processor intended
for utility functions on a system-on-chip~\cite{lipsi:arcs2018}. As the code base of
Lipsi is very small, it can serve as an easy starting point for processor design in Chisel.
Lipsi also showcases the productivity of Chisel/Scala. It took me 14 hours to describe the
hardware in Chisel and run it on an FPGA, write an assembler in Scala, write a
Lipsi instruction set simulator in Scala for co-simulation, and write a few test cases
in Lipsi assembler.
\fi

\ifshowtransfirst %(自動翻訳)
\item[\myref{https://github.com/schoeberl/lipsi}{Lipsi}] 
システム・オン・チップ〜\cite{lipsi:arcs2018}上のユーティリティ関数について。
Lipsiののコードベースが非常に小さいように、Chiselのプロセッサ設計の容易な出発点として役立つことができます。
LipsiのもChisel/スカラ座の生産性を紹介しています。
これは、Chiselで、ハードウェアを記述し、FPGA上でそれを実行し、スカラ座でのアセンブラを書き、協調シミュレーションのためのScalaの中Lipsiの命令セットシミュレータを書き、Lipsiのアセンブラでは、いくつかのテストケースを書くために私に14時間かかりました。
\fi
\ifshowtranssecond %(校正 7/23 mune10)
\item[\myref{https://github.com/schoeberl/lipsi}{Lipsi}] 
はシステム・オン・チップ でのユーティリティ機能向けの小型プロセッサです~\cite{lipsi:arcs2018} 。
Lipsiののコードベースは非常に小さく、Chiselのプロセッサ設計の最初の出発点として利用することができます。
また、LipsiはChisel/Scalaの生産性の高さの実例でもあります。
私はChiselで、ハードウェアを記述し、FPGA上でそれを実行し、Scalaでアセンブラを書き、ScalaでLipsiの命令セットシミュレータを書き、いくつかのテストケースを書くのに14時間ほどかかりました。
\fi

\ifshoworiginal
\item[\myref{http://www.opensocfabric.org/}{OpenSoC Fabric}] is an open-source NoC
generator written in Chisel~~\cite{OpenSoC:ispass2016}. It is intended to provide a
system-on-chip for large-scale design exploration. The NoC itself is a state-of-the-art design with wormhole routing, credits for flow control, and virtual channels.
OpenSoC Fabric is still using Chisel~2.
\fi

\ifshowtransfirst %(自動翻訳)
\item[\myref{http://www.opensocfabric.org/}{OpenSoC Fabric}] 
Chisel~~ \cite{OpenSoC:ispass2016}で書かれた発電機。
大規模な設計探索のためのシステム・オン・チップを提供することを意図しています。
NoC自体がワームホール・ルーティング、フロー制御のためのクレジット、及び仮想チャネルを有する最先端の設計です。
OpenSoCファブリックはまだChisel〜2を使用しています
\fi

\ifshowtranssecond %(校正 7/23 mune10)
\item[\myref{http://www.opensocfabric.org/}{OpenSoC Fabric}] 
はChiselで記述された、オープンソースの NoC (Network on Chip) 生成器です ~\cite{OpenSoC:ispass2016}。
大規模な設計探索のためのシステム・オン・チップを提供することを意図しています。
NoC自体は、ワームホール・ルーティング、フロー制御のためのクレジット、及び仮想チャネルのための最先端の設計です。
OpenSoCファブリックはまだChisel 2を使用しています
\fi

\ifshoworiginal
\item[\myref{https://github.com/bu-icsg/xfiles-dana}{DANA}] is a neural network accelerator
that integrates with the RISC-V Rocket processor using the Rocket Custom Coprocessor (RoCC) interface~\cite{RoCC:2015}.
DANA supports inference and learning.
\fi

\ifshowtransfirst %(自動翻訳)
\item[\myref{https://github.com/bu-icsg/xfiles-dana}{DANA}] 
そのロケット〜\cite{RoCC:2015}インターフェースカスタムコプロセッサ（ROCC）を使用して、RISC-Vロケットプロセッサと統合されています。
DANAは推論と学習をサポートしています。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
\item[\myref{https://github.com/bu-icsg/xfiles-dana}{DANA}] 
はロケットカスタムコプロセッサインターフェース（ROCC）を使用したニューラルネットワークアクセラレータと統合されたRISC-Vロケットプロセッサです ~\cite{RoCC:2015}。
DANAは推論と学習をサポートしています。
\fi

\ifshoworiginal
\item[\myref{https://github.com/antonblanchard/chiselwatt}{Chiselwatt}] is an implementation
of the POWER Open ISA. It includes instruction to run Micropython.
\fi

\ifshowtransfirst %(自動翻訳)
\item[\myref{https://github.com/antonblanchard/chiselwatt}{Chiselwatt}] 
POWERオープンISAの。
それはMicropythonを実行するための命令を含んでいます。
\fi
\ifshowtranssecond %(校正 7/23 mune10)
\item[\myref{https://github.com/antonblanchard/chiselwatt}{Chiselwatt}] 
は POWER Open ISA の実装です。
Micropythonを実行するための命令を含んでいます。
\fi

\end{description}

\ifshoworiginal
If you know an open-source project that uses Chisel, please drop me a note
so I can include it in a future edition of the book.
\fi

\ifshowtransfirst %(自動翻訳)
あなたがChiselを使用するオープンソースプロジェクトを知っていれば、私はこの本の将来版に含めることができますので、私にメールを送ってください。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
Chiselを使用するオープンソースプロジェクトに心当たりがありましたら、その情報を私までメールを送ってください。
その情報を、この本の将来版に含めるたいと思います。
\fi

\ifshoworiginal
\chapter{Chisel 2}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Chisel 2}
\fi
\ifshowtranssecond %(校正)
\chapter{Chisel 2 (L12866 mune10 初回校正済)} %(校正 7/23 mune10 付録B 初回終了  ===========================================================))
\fi

\index{Chisel 2}

\ifshoworiginal
This book covers version 3 of Chisel. Moreover, Chisel 3 is recommended for new designs.
However, there is still Chisel 2 code out in the wild, which has not yet been converted
to Chisel 3. There is documentation available on how to convert a Chisel 2 project to
Chisel 3:
\fi

\ifshowtransfirst %(自動翻訳)
この本はChiselのバージョン3をカバーしています。
また、Chisel3は新規設計用に推奨されます。
しかし、まだChisel3に変換されていない野生Chisel2コードoutは、依然として存在します。
Chisel3にChisel2プロジェクトを変換する方法で利用可能なドキュメントがあります：
\fi
\ifshowtranssecond %(校正 7/23 mune10)
この本はChiselのバージョン3に対応しています。
また、新規設計用にはChisel3が推奨されています。
しかし、世の中には、まだChisel3に変換されていない Chisel2のコードが依然として存在しています。
Chisel2のプロジェクトをChisel3に変換する方法に関するドキュメントとして以下の２つがあります：
\fi

\begin{itemize}
\item \myref{https://github.com/freechipsproject/chisel3/wiki/Chisel3-vs-Chisel2}{Chisel2 vs. Chisel3}
\item \myref{https://github.com/schoeberl/chisel-examples/blob/master/TowardsChisel3.md}{Towards Chisel 3}
\end{itemize}

\ifshoworiginal
However, you might get involved in a project that still uses Chisel 2,
e.g., the \myref{https://github.com/t-crest/patmos}{Patmos}~\cite{patmos:rts2018} processor.
Therefore, we provide here some information on Chisel 2 coding for those who
have started with Chisel 3.
\fi

\ifshowtransfirst %(自動翻訳)
しかし、あなたはまだChisel2、Eを使用するプロジェクトに関わってしまうかもしれません。
グラム。
、\myref{https://github.com/t-crest/patmos}{Patmos}〜\cite{patmos:rts2018}プロセッサ。
したがって、我々はここにChisel3で開始している人のためのコーディングChisel2にいくつかの情報を提供します。
\fi
\ifshowtranssecond %(校正 7/23 mune10)
しかしながら、あなたがまだChisel2 を使用するプロジェクトに関わるかもしれません。
例えば、\myref{https://github.com/t-crest/patmos}{Patmos}~\cite{patmos:rts2018} プロセッサはChisel2で設計されていいます。
したがって、すでにChisel3で設計を始めている人向けに、Chisel2に関する情報を提供したいと思います。
\fi

\ifshoworiginal
First, all documentation on Chisel 2 has been removed from the web sites
belonging to Chisel. We have rescued those PDF documents and put them
on GitHub at \url{https://github.com/schoeberl/chisel2-doc}.
You can use the Chisel 2 tutorial by switching to the Chisel 2 branch:
\fi

\ifshowtransfirst %(自動翻訳)
まず、Chisel2上のすべてのドキュメントは、Chiselに属するウェブサイトから削除されました。
私たちは、これらのPDF文書を救出し、\ {URLのhttpsでGitHubの上にそれらを入れている：// githubの。
COM / schoeberl / chisel2-docの}。
あなたはChisel2ブランチに切り替えることにより、Chisel2チュートリアルを使用することができます。
\fi
\ifshowtranssecond %(校正 7/23 mune10)
まず、Chisel2上のすべてのドキュメントは、Chiselに属するウェブサイトから削除されています。
私たちはこれらのPDF文書を救出して、GitHub \url{https://github.com/schoeberl/chisel2-doc} に保存しています。
Chisel2のブランチに切り替えることで、Chisel2のチュートリアルにアクセスできます。
\fi

\begin{chisel}
$ git clone https://github.com/ucb-bar/chisel-tutorial.git
$ cd chisel-tutorial
$ git checkout chisel2
\end{chisel}

\ifshoworiginal
The main visible difference between Chisel 3 and 2 are the definitions of
constants, bundles for IO, wires, memories, and probably older forms of register
definitions.
\fi


\ifshowtransfirst %(自動翻訳)
Chisel3と2の間の主な目に見える違いは、定数の定義、IO、ワイヤ、メモリのバンドル、およびレジスタ定義の恐らく古い形態です。
\fi
\ifshowtranssecond %(校正 7/23 mune10)
Chisel3と2の間の目に見える大きな違いは、定数の定義、IO、ワイヤ、メモリのバンドル、および古いレジスタ定義方法になります。
\fi

\ifshoworiginal
Chisel 2 constructs can be used, to some extent, in a Chisel 3 project by
using the compatibility layer using as package \code{Chisel} instead of \code{chisel3}.
However, using this compatibility layer should only be used in a transition phase.
Therefore, we do not cover it here.
\fi

\ifshowtransfirst %(自動翻訳)
Chisel2構築物は、パッケージ\code{Chisel}代わりに\code{chisel3}として用いた互換性レイヤを使用して、Chisel3プロジェクトで、ある程度、使用することができます。
しかし、この互換性レイヤを使用することのみ遷移段階で使用されるべきです。
したがって、我々はここでそれをカバーしていません。
\fi
\ifshowtranssecond %(校正 7/23 mune10)
Chisel2の実装は、\code{chisel3}の代わりに、\code{Chisel} パッケージを使い、この互換性レイヤを介することで、Chisel3プロジェクトである程度利用することができます。
しかし、この互換性レイヤの使用は、あくまで遷移期間に留めるべきであり、ここでは詳しくは述べません。
\fi

\ifshoworiginal
Here are two examples of basic components, the same that have been presented
for Chisel 3. A module containing combinational logic:
\fi

\ifshowtransfirst %(自動翻訳)
ここでは基本的なコンポーネントの2つの例、Chisel3のために提示されているものと同じです。
組み合わせロジックを含むモジュール：
\fi
\ifshowtranssecond %(校正 7/23 mune10)
ここで紹介する基本的なコンポーネントの２つの例は、Chisel3 と同じものです。
組み合わせロジックを含むモジュール例：
\fi

\shortlist{chisel2/src/main/scala/Logic.scala}

\ifshoworiginal
Note that the \code{Bundle} for the IO definition is \emph{not} wrapped into
an \code{IO()} class.  Furthermore, the direction of the different IO ports is defined
as part of the type definition, in this example as \code{INPUT} and \code{OUTPUT}
as part of \code{UInt}. The width is given as the second parameter.
\fi

\ifshowtransfirst %(自動翻訳)
IO定義の\code{Bundle}が\emph{not}が\code{IO()}クラスにラップされていることに注意してください。
さらに、異なるIOポートの方向は\code{UInt}の一部として\code{INPUT}と\code{OUTPUT}この例では、タイプ定義の一部として定義されます。
幅は2番目のパラメータとして与えられます。
\fi
\ifshowtranssecond %(校正 7/23 mune10)
IO定義の\code{Bundle}が\code{IO()}クラスにラップされて \emph{いない} ことに注意してください。
さらに、それぞれのIOポートはタイプ定義の一部として定義されます。
この \code{INPUT}と\code{OUTPUT}例では\code{UInt}の一部として定義されています。
また、信号の幅は2番目のパラメータで与えられています。
\fi

\begin{minipage}{\linewidth}

\ifshoworiginal
The 8-bit register example in Chisel 2:
\fi

\ifshowtransfirst %(自動翻訳)
Chisel2の8ビット・レジスタの例：
\fi
\ifshowtranssecond %(校正 7/23 mune10)
Chisel2 での8ビット・レジスタの記述例：
\fi

\shortlist{chisel2/src/main/scala/Register.scala}
\end{minipage}

\ifshoworiginal
Here you see a typical register definition with a reset value passed in as
a \code{UInt} to the named parameter \code{init}. This form is still valid in Chisel 3,
but the usage of \code{RegInit} and \code{RegNext} is recommended for new Chisel 3 designs.
Note also here the constant definition of an 8-bit wide 0 as \code{UInt(0, 8)}.
\fi

\ifshowtransfirst %(自動翻訳)
ここでは、\code{init}という名前のパラメータに\code{UInt}として渡されたリセット値との典型的なレジスタの定義を参照してください。
この形式は、Chisel3でまだ有効ですが、\code{RegInit}と\code{RegNext}の使用は、新たなChisel3設計用に推奨されます。
ここでまた、8ビット幅の0 \code{UInt(0, 8)}などの一定の定義を注意してください。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
ここでは、\code{init}という名前のパラメータに\code{UInt}を介して渡されたリセット値を用いる典型的なレジスタの定義方法を紹介しています。
この形式は、Chisel3でもまだ有効ですが、新たなChisel3設計用には、\code{RegInit}と\code{RegNext}の使用が推奨されています。
またここでは、\code{UInt(0, 8)}で8ビット幅の定数0を定義しています。
\fi

\ifshoworiginal
Chisel based testing C++ code and Verilog code are generated by calling \code{chiselMainTest}
and \code{chiselMain}. Both ``main'' functions take a \code{String} array for further parameters.
\fi

\ifshowtransfirst %(自動翻訳)
ChiselベースのテストC ++コードおよびVerilogコードが\code{chiselMainTest}と\code{chiselMain}を呼び出すことによって生成されます。
どちらの ``メイン「」の機能は、他のパラメータのための\code{String}配列を取ります。
\fi
\ifshowtranssecond %(校正 7/23 mune10)
Chiselベースのテスト用C++コードとVerilogコードは、\code{chiselMainTest} と \code{chiselMain} を呼び出すことで生成されます。
どちらのメイン関数もパラメータとして文字列(\code{String}) の配列を取ります。
\fi

\shortlist{chisel2/src/main/scala/LogicTester.scala}

\shortlist{chisel2/src/main/scala/LogicHardware.scala}

\ifshoworiginal
A memory with sequential registered read and write ports is defined in Chisel 2 as:
\fi

\ifshowtransfirst %(自動翻訳)
シーケンシャル登録読み取りおよび書き込みポートを持つメモリは、Chisel2で次のように定義されます。
\fi

\ifshowtranssecond %(校正 7/23 mune10)
読み書きが一旦レジスタにラッチされるメモリは、Chisel2では以下のように記述されています。
\fi

\begin{chisel}
  val mem = Mem(UInt(width = 8), 256, seqRead = true)
  val rdData = mem(Reg(next = rdAddr))
  when(wrEna) {
    mem(wrAddr) := wrData
  }
\end{chisel}

\ifshoworiginal
\chapter{Acronyms}
\fi
\ifshowtransfirst %(自動翻訳)
\chapter{Acronyms}
\fi
\ifshowtranssecond %(校正)
\chapter{略語 (L13080 mune10 初回校正済)} %(校正 3/9 mune10 付録C 初回終了  ================================================================))
\fi

\ifshoworiginal
Hardware designers and computer engineers like to use acronyms.
However, it needs time to get used to them. Here is a list of common terms
related to digital design and computer architecture.
\fi

\ifshowtransfirst %(自動翻訳)
ハードウェア設計者とコンピュータのエンジニアは頭字語を使用するようにしたいです。
しかし、それはそれらに慣れるための時間が必要です。
ここではデジタル設計とコンピュータアーキテクチャに関連する一般的な用語のリストです。
\fi

\ifshowtranssecond %(校正 3/9 mune10)
ハードウェア設計者やコンピュータのエンジニアは略語を好みます。
しかしながら、そうした略語になれるには時間がかかります。
以下に、デジタル設計やコンピュータ・アーキテクチャで一般的に使われる略語を列挙します。
\fi

\begin{description}
\item [ADC] analog-to-digital converter
\item [ALU] arithmetic and logic unit
\item [ASIC] application-specific integrated circuit
\item [CFG] control flow graph
\item [Chisel] constructing hardware in a Scala embedded language
\item [CISC] complex instruction set computer
\item [CPI] clock cycles per instruction
\item [CRC] cyclic redundancy check
\item [DAC] digital-to-analog converter
\item [DFF] D flip-flop, data flip-flop
\item [DMA] direct memory access
\item [DRAM] dynamic random access memory
\item [EMC] electromagnetic compatibility
\item [ESD] electrostatic discharge
\item [FF] flip-flop
\item [FIFO] first-in, first-out
\item [FPGA] field-programmable gate array
% \item [GC] garbage collect(ion/or)
\item [HDL] hardware description language
\item [HLS] high-level synthesis
\item [IC] instruction count
\item [IDE] integrated development environment
\item [ILP] instruction level parallelism
\item [IO] input/output
\item [ISA] instruction set architecture
\item [JDK] Java development kit
\item [JIT] just-Iin-time
\item [JVM] Java virtual machine
\item [LC] logic cell
\item [LRU] least-recently used
\item [MMIO] memory-mapped IO
\item [MUX] multiplexer
\item [OO] object oriented
\item [OOO] out-of order
\item [OS] operating system
\item [RISC] reduced instruction set computer
%\item [RT] Real-Time
%\item [RTOS] Real-Time Operating System
\item [SDRAM] synchronous DRAM
\item [SRAM] static random access memory
\item [TOS] top-of stack
\item [UART] universal asynchronous receiver/transmitter
\item [VHDL] VHSIC hardware description language
\item [VHSIC] very high speed integrated circuit
\item [WCET] Worst-Case Execution Time
\end{description}

\bibliographystyle{plain}
\bibliography{chisel}

\printindex

\end{document}

\chapter{Headings}

\todo{Collect the headings here, but only elevate them to chapter level when some
writing is going on.}

\section{Introduction}

 * Why Chisel, what is cool about it
 * What this book is (and what not)
 * Overview of the following Chapters

\section{Basic Circuits}

 * Combinational expressions (basic gates with logic tables)
 * Combinational base circuits (chapter 8 in Culler)
 * Multiplexer (just the simple one for a start)
 * Registers

1. base functions: +, - , and or, register (with reset, with enable)

\section{Build Process and Testing}

 * A full example (blinking LED again)
 * Packages
 * Source organization (Scala)
 * Object to generate Verilog
 * Testing
 * sbt

\section{Components/Modules}

\section{Building Blocks}

 * building blocks (adder, mux, ALU, counter, memory)
 * maybe split into combinational and sequential

\section{Bundles and Vecs (better title needed)}

\section{Medium Complex Circuits (better title needed)}

3. small designs (better name): UART, FIFO, PWM, VGA, sigma delta

\section{State Machines and Data Path}

 * Covered in stuff for Dally book lecture spring 2019

\section{Memory}

 * Vec based ROM with address register
 * Vec based read/write
 * All other variations
 * Escape code in VHDL and Verilog for unsupported memories

\section{Tips and Tricks (better title needed)}

Stuff that saves a little hardware, but might not worse the less readable code

 * Counter to -1
 * Shared adder and subtractor
 * Mux with one hot encoding of select
 * little tricks: count down, add/sub

\section{Scala for Hardware Developers}

 * Simple Scala (for, if else)
 * functions for hardware generation
 * Classes and constructor

 \section{More Complex Testing}

  * As we know now sone Scala it is time to use the power of Scala for better testing

\section{Hardware Generation}

 * More advanced stuff
 * Table generation (sinus, assembler)

 \section{Leros}

  * as a more complex design
  4. full design(s): processor

\section{Chisel 2}

 * Some notes for reading Chisel 2 code
 * Update Lipsi to Chisel 3 to work on the 2 to 3 documentation

 \section{Chisel Projects}

  * Projects written in Chisel, as paper reference, some words and a URL.

\section{Appendix}

 * Basic digital circuits, e.g., transistor based inverter, half and full adder
 * With lot of links to Wikipedia

\end{document}

\subsection*{Course Abstract}

Chisel is a hardware construction language implemented as a domain specific language in Scala. Therefore, the full power of a modern programming language is available to describe hardware and, more important, hardware generators. Chisel has been developed at UC Berkeley and successfully used for several tape outs of RISC-V. Here at DTU we used Chisel in the T-CREST project and in teaching advanced computer architecture.

In this course I will give an overview of Chisel to describe circuits at the RTL, how to use the Chisel tester functionality to test and simulate digital circuits, present how to synthesize circuits for an FPGA, and present advanced functionality of Chisel for the description of circuit generators. Besides lecturing we will have lab sessions to describe small circuits and evaluate them in an FPGA.

The aim of the course is to get a basic understanding of a modern hardware description language and be able to describe simple circuits in Chisel. This course shall give a basis to explore more advanced concepts of circuit generators written in Chisel/Scala.
